<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>导出功能优化</title>
    <url>/2019/10/11/2019-10-11-%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li>以解决问题为最终目的，而不是凑合改完就好了，凑合改完最终的效果只是好一点，但功能能不能用真的不一定；</li>
</ol>
<span id="more"></span>

<ol>
<li>改一个功能的时候，就不是我对之前的代码怎么修修补补，现在就变成了我在写代码了，我觉得他的不对，我就要改成我的，所以别人再看代码的时候，就会问你用这个表干什么，这个代码虽然最初的版本不是你的，但现在已经是你的了；</li>
<li>优化，有问题的地方，就要多去尝试看看怎么改，以功能最终能用为主。</li>
<li>回答问题的时候，不知道的地方，不要立马说不知道，先拖一拖，立马去看看，看看代码是怎么写的，表是怎么建的，看完就知道了，东西都在自己手里，说不知道就很麻烦。因为马上就可以知道。。。总计，不知道先不要立马回复，要去弄清楚。</li>
<li>大的改动，跟领导确认后再调整。</li>
</ol>
<!-- more -->

<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述：</strong></h2><p>在数据库查出几千条数据后，对数据进行处理的时间超出了连接池回收空闲链接的时间，Connection has already been closed.导致事物关闭，运行报错。JDBC begin transaction failed:</p>
<p>解决方法：</p>
<ol>
<li><p>调大数据库对于事物回收地 空闲时间：<img src="/images/2019-10-11-%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/1570775473735.png" alt="1570775473735"></p>
<p>参考：<a href="https://my.oschina.net/liufq/blog/1539905">参数意义</a></p>
</li>
<li><p>优化代码，减少查出的数据处理时间。</p>
</li>
</ol>
<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><h3 id="1-数据库优化"><a href="#1-数据库优化" class="headerlink" title="1.数据库优化"></a>1.数据库优化</h3><p>​        代码里查的是视图，但是视图和表的区别并不大，并没有做过滤，<strong>且有调整的字段在本次需要优化的功能中并未用到</strong>，所以可以改为直接查询表，<strong>但是不能直接带代码里改</strong>，因为底层的这个方法是共用的，其他调用可能会用到。<img src="/images/2019-10-11-%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/1570773384484.png" alt="1570773384484"></p>
<p><strong>调整：</strong></p>
<p>​        新增方法，把查询视图改为查询表，并<strong>添加索引</strong>，同时在查询时sql过滤掉不需要的数据；注意不能影响其他功能，如果只有这一次使用这个查询，可以直接修改完事；</p>
<h3 id="2-优化对数据逻辑处理"><a href="#2-优化对数据逻辑处理" class="headerlink" title="2.优化对数据逻辑处理"></a>2.优化对数据逻辑处理</h3><p><img src="/images/2019-10-11-%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E4%BC%98%E5%8C%96/1570775692313.png" alt="1570775692313"></p>
<p><strong>优化：</strong></p>
<ol>
<li>在循环外把接口调用的数据先查询出来放在map中，需要是直接在map中查询。</li>
</ol>
<h4 id="2-1-优化："><a href="#2-1-优化：" class="headerlink" title="2.1 优化："></a>2.1 优化：</h4>]]></content>
      <categories>
        <category>功能优化</category>
      </categories>
      <tags>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.11.28记录</title>
    <url>/2019/11/28/2019-11-28%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="2019-11-28【周四】"><a href="#2019-11-28【周四】" class="headerlink" title="2019.11.28【周四】"></a>2019.11.28【周四】</h3><p>​    今天是28号，感恩节。</p>
<span id="more"></span>

<p>​    我现在工资13k了，大概已经不少了。但是却真的开心不起来，因为加班太猛了，也不猛，其实九点多还好，是自己前几天太不适应了。</p>
<p>​    也是因为之前的一个月太闲了，都没写代码了，结果一下子需要上手，太多东西一下子压到自己身上，加班公司还有无意义的加班，就搞的很难受。</p>
<p>​        最重要的是把生活作息给规律起来，不能因为突然晚上要多干一会儿，明明不管自己的事，也要搞的腰酸背痛的，还饿着，到八九点钟就扛不住了。不合适，也划不来，虽然现在13k在前同事眼里很冒烟，但是现在我通过几次的面试，知道了自己的差距，知道了自己和大厂的差距，这个时候，是需要奋起直追的，而不是就此开始适应现在的环境。</p>
<p>​        列一下后期的计划，结合现在的工作，把自己在工作和业余时间的事，好好想一想。</p>
<p>​    </p>
<p>​        代码这些东西，包括在公司里的任务安排，这个自己要积极起来，自己列个计划，好好的搞起来，这周把整个整个需要过的东西都好好讲一遍，下周开始好好看代码，，好好做记录，好好梳理一遍，能做好记录都做好，特别是需要我坐的东西，好好记下来，好好看看。</p>
<p>​        只能说，前期项目上线，加班多也算正常。</p>
<p><strong>计划：</strong></p>
<ol>
<li>项目、需求，跟着勇哥好好做，好好学东西</li>
<li>博客，多总结，自己要多做记录，项目里自己没接触过的东西，要多学习，把东西搞搞懂</li>
<li>Java编程思想，还是要好好看的</li>
<li>对于这些人项目里用到的东西，要好好看看，业务逻辑代码搞清楚，对于项目里没用过的东西，要及时好好查查看看，多问</li>
<li>一批一批的接口逻辑总结起来，代码逻辑总结起来，整个业务流程是怎么运转的，搞懂了，就问题不大了，多总结，多问，特别是最近，再不问就没机会了</li>
<li>有时间还是要多学东西的，现在也是个机会，多搞搞</li>
<li>睡觉。</li>
</ol>
<h3 id="2019-12-1【周日】"><a href="#2019-12-1【周日】" class="headerlink" title="2019.12.1【周日】"></a>2019.12.1【周日】</h3><p>​        要把自己的总结给上传到不同的平台，也不会需要太多的时间，只是在周末把内容复制一下就好了、</p>
<p>​        可以考虑在B站，开一个视频，能够自己讲讲， 分享一些不同形式的视频，参考学习一下其他人的模式。</p>
<p>​        抄袭复制是没有尽头的，没有人愿意去看，要在看书的同时去时间，只有代码敲出来，做出来了才能记得牢，再加上总结，面试还怕个球。</p>
<ol>
<li>办招商银行卡</li>
<li>整理待复印东西</li>
<li>五笔输入法学习-无感学习法</li>
<li>看代码，整理技术点</li>
<li>学习spring cloud系列技术，代码敲出来，自己做过一遍</li>
<li>送老杜回学校</li>
<li>定位本次公司工作的目的和结果</li>
</ol>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>Autowired和Resource区别</title>
    <url>/2019/11/16/Autowired%E5%92%8CResource%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>自己在实际开发中一直在使用@Autowired从spring中获取bean，但也常看到 @Resource 的使用，特地搜了搜区别：实际作用来说，没什么区别；</p>
<span id="more"></span>

<h3 id="一、-Autowired："><a href="#一、-Autowired：" class="headerlink" title="一、@Autowired："></a>一、@Autowired：</h3><p>1、Spring 2.5 引入了 @Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired 的使用来消除 set ，get 方法。</p>
<p>这个注解就是 spring 可以自动帮你把 bean 里面引用的对象的 setter/getter 方法省略，它会自动帮你 set/get。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;...&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;userDao&quot;</span>&gt;</span><br><span class="line">&lt;ref bean=<span class="string">&quot;userDao&quot;</span>/&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>这样你在 userService 里面要做一个 userDao 的 setter/getter 方法。<br>但如果你用了 @Autowired 的话，你只需要在 UserService 的实现类中声明即可。<br>@Autowired<br>private IUserDao userdao;</p>
<p>PS：</p>
<p>1、@Autowired 是根据类型进行自动装配的。</p>
<p>2、@Autowired 也可以手动指定按照 byName 方式注入，使用 @Qualifier 标签，例如：</p>
<p>@Autowired() @Qualifier(“baseDao”)<br>private BaseDao baseDao;</p>
<p>二、@Resource 的作用相当于 @Autowired，只不过 @Autowired 按 byType 自动注入，而 @Resource 默认按 byName 自动注入。<br>@Resource 有两个属性是比较重要的，分是 name 和 type，Spring 将 @Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。<br>@Resource 装配顺序　　</p>
<ol>
<li>如果同时指定了 name 和 type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常　　</li>
<li>如果指定了 name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常</li>
<li>如果指定了 type，则从上下文中找到类型匹配的唯一 bean 进行装配，找不到或者找到多个，都会抛出异常　　</li>
<li>如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li>
</ol>
<p>三、@Autowired 与 @Resource 的区别<br>1、@Autowired 与 @Resource 都可以用来装配 bean. 都可以写在字段上，或写在 setter 方法上。<br>2、@Autowired 默认按类型装配（这个注解是属业 spring 的），默认情况下必须要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false。<br>3、@Resource（这个注解属于 J2EE 的），默认安照名称进行装配，名称可以通过 name 属性进行指定，<br>如果没有指定 name 属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在 setter 方法上默认取属性名进行装配。 当找不到与名称匹配的 bean 时才按照类型进行装配。但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配。<br>ps: @Resource 注解在字段上，这样就不用写 setter 方法了，并且这个注解是属于 J2EE 的，减少了与 spring 的耦合。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Autowired</tag>
        <tag>Resource</tag>
      </tags>
  </entry>
  <entry>
    <title>DateTimeFormat和JsonFormat区别</title>
    <url>/2019/12/10/DateTimeFormat%E5%92%8C-JsonFormat%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="使用位置不同"><a href="#使用位置不同" class="headerlink" title="使用位置不同"></a>使用位置不同</h3><p><strong>@DateTimeFormat注解解决前台string类型与后台date类型的转换，使用@JsonFormat注解解决后台date类型与前台string类型的转换</strong></p>
<span id="more"></span>

<p><strong>注意：</strong></p>
<ol>
<li><em><strong>注意这两个注解的注解位置</strong></em></li>
<li><em><strong>注意被注解的字段应该是Date类型</strong></em></li>
<li><em><strong>一般会用在VO中</strong></em></li>
<li><em><strong>@JsonFormat不要忘了加GMT+8</strong></em></li>
<li><em>**@DateTimeFormat要注意前台传过的日期格式是yyyy-MM-dd的形式，如果你传了一个yyyyMMdd的形式会报错（*<em>*日期*</em>*格式基于下面的程序）：</em>**</li>
</ol>
<h3 id="HH与hh区别："><a href="#HH与hh区别：" class="headerlink" title="HH与hh区别："></a><strong>HH与hh区别：</strong></h3><p>pojo类上的哪个Date类型的字段需要，就用@DateTimeFormat(pattern = “yyyy-MM-dd hh:mm:ss”)  标记</p>
<p>这样前端页面传递过来的String类型的时间  ‘2016-11-11 11:11:11’ 会转换为 Date 类型</p>
<p><img src="/images/DateTimeFormat%E5%92%8C-JsonFormat%E5%8C%BA%E5%88%AB/1041767-20161115151638576-506989670.png" alt="img"></p>
<p>注意点来啦！！！</p>
<p>之前我用这个注解一直不起效，一直报错误！</p>
<p>我是这样写的：</p>
<p><img src="/images/DateTimeFormat%E5%92%8C-JsonFormat%E5%8C%BA%E5%88%AB/1041767-20161115151815060-876537661.png" alt="img"></p>
<p>后来改了一个地方，他就好啦，就是将hh改为大写。</p>
<p>一开始我写的是小写的h，那个值代表着1-12，比如，我是在下午16:30传入参数的，而小写的h最大只能接受12的值，传入16就出错了，所有无法将String转为Date类型。</p>
]]></content>
      <tags>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork/Join框架使用</title>
    <url>/2019/11/02/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Fork-Join多线程框架"><a href="#Fork-Join多线程框架" class="headerlink" title="Fork/Join多线程框架"></a>Fork/Join多线程框架</h2><span id="more"></span>

<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/images/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/1572654730540.png" alt="1572654730540"></p>
<p>​        采用分而治之的方法，递归实现大任务切分成小人物的方法，多线程实现已经封转，直接使用就可以了。使用场景应该是比较广泛的。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.qxzssb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fork join学习</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以下计算 1 + 2 + 3 + 4 + ... + n 的结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * RecursiveTask 和 RecursiveAction 的区别就是前者有返回值，后者无返回值</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 通过这个例子，进一步了解ForkJoinTask，ForkJoinTask与一般任务的主要区别在于它需要实现compute方法，</span></span><br><span class="line"><span class="comment"> * 在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。</span></span><br><span class="line"><span class="comment"> * 如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，</span></span><br><span class="line"><span class="comment"> * 看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用join方法会等待子任务执行完并得到其结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_HOLD = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinTest</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果任务足够小就计算</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THREAD_HOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//模拟耗时计算</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;任务足够小了，直接计算，计算结果:&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;任务还不够小，继续分割，middle:&quot;</span> + middle);</span><br><span class="line"> </span><br><span class="line">            ForkJoinTest left = <span class="keyword">new</span> ForkJoinTest(start, middle);</span><br><span class="line">            ForkJoinTest right = <span class="keyword">new</span> ForkJoinTest(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="comment">//获取子任务结果</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//join() 方法会阻塞到结果算出来</span></span><br><span class="line">            <span class="keyword">int</span> lResult = left.join();</span><br><span class="line">            <span class="keyword">int</span> rResult = right.join();</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            sum = lResult + rResult;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果 sum：&quot;</span> + sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTest task = <span class="keyword">new</span> ForkJoinTest(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = pool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            Integer sum = result.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms，计算结果：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h3><p><img src="/images/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/1572655005040.png" alt="1572655005040"></p>
<p><img src="/images/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/1572655183671.png" alt="1572655183671"></p>
<h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="/images/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/1572655296766.png" alt="1572655296766"></p>
<p>参考博客：</p>
<ol>
<li><p><a href="https://blog.csdn.net/lichuangcsdn/article/details/80866497">代码</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/senlinyang/p/7885964.html">底层代码</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Form 表单中 post 和 get 的区别</title>
    <url>/2019/11/12/Form-%E8%A1%A8%E5%8D%95%E4%B8%AD-post-%E5%92%8C-get-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>1、Get 方法通过 URL 请求来传递用户的数据，将表单内各字段名称与其内容，以成对的字符串连接，置于 action 属性所指程序的 url 后，如 [url] <a href="http://www.mdm.com/test.asp?name=asd&amp;password=sad">http://www.mdm.com/test.asp?name=asd&amp;password=sad</a> [/url]，数据都会 直接显示在 url 上，就像用户点击一个链接一样；</p>
<span id="more"></span>

<p>Post 方法通过 HTTP post 机制，将表单内各字段名称与其内容放置在 HTML 表头 (header) 内一起传送给服务器端交由 action 属性能所指的程序处理，该程序会通过标准输入 (stdin) 方式，将表单的数据读出并加以处理</p>
<p>2、 Get 方式需要使用 Request.QueryString 来取得变量的值；而 Post 方式通过 Request.Form 来访问提交的内容</p>
<p>3、Get 方式传输的数据量非常小，一般限制在 2 KB 左右，但是执行效率却比 Post 方法好；而 Post 方式传递的数据量相对较大，它是等待服务器来读取数据，不过也有字节限制，这是为了避免对服务器用大量数据进行恶意攻击，根据微软方面的说法，微软对用 Request.Form () 可接收的最大数据有限制，IIS 4 中为 80 KB 字节，IIS 5 中为 100 KB 字节</p>
<p>建议：除非你肯定你提交的数据可以一次性提交，否则请尽量用 Post 方法</p>
<p>4、Get 方式提交数据，会带来安全问题，比如一个登陆页面，通过 Get 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问客户这台机器，就可以从历史记录获得该用户的帐号和密码，所以表单提交建议使用 Post 方法；Post 方法提交的表单页面常见的问题是，该页面如果刷新的时候，会弹出一个对话框</p>
<p>建议：出于安全性考虑，建议最好使用 Post 提交数据</p>
<p><strong>二者主要区别如下：</strong></p>
<p> 1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。<br> 2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用 “?” 连接，而各个变量之间使用 “&amp;” 连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。<br> 3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求 URL 记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。<br> 4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。<br> 5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。<br>6、Get 是 Form 的默认方法。</p>
<p><strong>GET 和 POST 的数据格式都是一样的： GET 支持的最大字节限制是 2048 Bytes POST 支持的最大字节限制是 2GB</strong></p>
<hr>
<p>form 表单可以给后台传递数据，在后台直接可以用 request 对象去向前台请求数据。<br>form 表单传递数据有两种方式：<br>method=”post”: 这是传递大量数据时用的，在数据传递之前会先将数据打包，因此这种传递数据的方式会效率会比较慢，但是穿过的数据都能正确解析，因此传中文不会有乱码。<br>method=”get”：以 URL 传递的，因为地址栏长度有限，所以对数据量是有限制的，而且传递的数据必须是 ASCCI 码值范围内的，因此，传中文会有乱码，需特殊处理。</p>
<p>url 跳转到 action 只能通过 url 的参数来传递数据，action? 参数名 = 参数值 &amp;……，在后台也可以用 request 对象去向前台请求 url 的参数值（url 传中文参数需要进行特殊处理）</p>
<p><a href="http://www.voidcn.com/article/p-oawiozkz-yd.html">参考</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>form</tag>
      </tags>
  </entry>
  <entry>
    <title>Form表单提交方式</title>
    <url>/2019/11/12/Form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="form-表单常用属性"><a href="#form-表单常用属性" class="headerlink" title="form 表单常用属性"></a>form 表单常用属性</h3><ul>
<li>action：url 地址，服务器接收表单数据的地址</li>
</ul>
<span id="more"></span>

<ul>
<li><p>method：提交服务器的http方法，一般为post和get</p>
</li>
<li><p>name：最好好吃name属性的唯一性</p>
</li>
<li><p>enctype: 表单数据提交时使用的编码类型，默认使用”pplication/x-www-form-urlencoded”，如果是使用POST请求，则请求头中的content-type指定值就是该值。如果表单中有上传文件，编码类型需要使用”multipart/form-data”，类型，才能完成传递文件数据。</p>
</li>
<li><p> enctype 为 form 表单数据的编码格式，Content-type 为 Http 传输的数据的编码格式。分清两者</p>
</li>
</ul>
<h3 id="浏览器提交表单时，执行步骤"><a href="#浏览器提交表单时，执行步骤" class="headerlink" title="浏览器提交表单时，执行步骤"></a>浏览器提交表单时，执行步骤</h3><p>1、识别出表单中表单元素的有效项，作为提交项</p>
<p>2、构建一个表单数据集</p>
<p>3、根据form表单中的enctype属性的值作为content-type对数据进行编码</p>
<p>4、根据form表单中的action属性和method属性向指定的地址发送数据</p>
<p>3、提交方式</p>
<p>1、get:表单数据会被encodeURIComponent后以参数的形式:name1=value1&amp;name2=value2 附带在url?后面，再发送给服务器，并在url中显示出来。</p>
<p>2、post：enctype 默认”application/x-www-form-urlencoded”对表单数据进行编码，数据以键值对在http请求体重发送给服务器；如果enctype 属性为”multipart/form-data”，则以消息的形式发送给服务器。</p>
<p>　</p>
<h3 id="Http-协议行为：Http1-1-协议"><a href="#Http-协议行为：Http1-1-协议" class="headerlink" title="Http 协议行为：Http1.1 协议"></a>Http 协议行为：Http1.1 协议</h3><p>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>
<p><method> <request-URL> <version> <headers> <entity-body>　　</p>
<p>协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。</p>
<p>所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分</p>
<p>Post 请求下的 Content-Type 类型（编码类型）</p>
<ol>
<li><p>application/x-www-form-urlencoded</p>
</li>
<li><p>multipart/form-data </p>
</li>
<li><p>application/json</p>
</li>
</ol>
<p> <strong>表单提交方式一</strong>：直接利用 form 表单提交<br>html 页面代码： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> controller 页面代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;返回值是》》&quot;</span>+username+<span class="string">&quot;----&gt;&quot;</span>+password);</span><br><span class="line">		String str = <span class="string">&quot;返回值是&quot;</span>+username+password;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>表单提交方式二</strong>：使用 ajax 提交<br>html 页面代码： (重点：ajax传递数据类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--  --&gt;</span><br><span class="line">&lt;form  method=<span class="string">&quot;post&quot;</span> onsubmit=<span class="string">&quot;return false&quot;</span> action=<span class="string">&quot;##&quot;</span> id=<span class="string">&quot;formtest&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">	username:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> /&gt;&lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	password:&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;登录&quot;</span> onclick=<span class="string">&quot;login()&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/jquery.easyui.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/extJquery.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/extEasyUI.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="function">function <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">    <span class="comment">//几个参数需要注意一下</span></span><br><span class="line">        type: <span class="string">&quot;POST&quot;</span>,<span class="comment">//方法类型</span></span><br><span class="line">        dataType: <span class="string">&quot;text&quot;</span>,<span class="comment">//预期服务器返回的数据类型 如果是对象返回的是json 如果是字符串这里一定要定义text 之前我就是定义json 结果字符串的返回一直到额error中去</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        dataType:</span></span><br><span class="line"><span class="comment">			要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：</span></span><br><span class="line"><span class="comment">			xml：返回XML文档，可用JQuery处理。</span></span><br><span class="line"><span class="comment">			html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。</span></span><br><span class="line"><span class="comment">			script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。</span></span><br><span class="line"><span class="comment">			json：返回JSON数据。</span></span><br><span class="line"><span class="comment">			jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。</span></span><br><span class="line"><span class="comment">			text：返回纯文本字符串。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        url: <span class="string">&quot;http://localhost:8080/user&quot;</span>,<span class="comment">//url</span></span><br><span class="line">        data: $(<span class="string">&#x27;#formtest&#x27;</span>).serialize(),<span class="comment">//这个是form表单中的id   jQuery的serialize()方法通过序列化表单值</span></span><br><span class="line">        success: function (result) &#123;</span><br><span class="line">        	alert(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">            console.log(result);<span class="comment">//打印服务端返回的数据(调试用)</span></span><br><span class="line">            <span class="keyword">if</span> (result.resultCode == <span class="number">200</span>) &#123;</span><br><span class="line">                alert(<span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ;</span><br><span class="line">        &#125;,</span><br><span class="line">        error : function(s,s2,s3) &#123;</span><br><span class="line">			<span class="comment">//数据成功传到后台 也有返回值 但就是报错 parsererror ：参考</span></span><br><span class="line">			https:<span class="comment">//blog.csdn.net/AinGates/article/details/75250223 / </span></span><br><span class="line">			https:<span class="comment">//blog.csdn.net/AinGates/article/details/75250223</span></span><br><span class="line">        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        	    写了一个ajax方法，后台一切正常，通过浏览器的F12工具查看XMLHttpRequest.status返回200，XMLHttpRequest.readyState返回4，也都没有问题。但是回调函数跳到error里，报parsererror的错误。经过排查，发现是因为后台返回时用了@ResponseBody注解（SpringMVC返回json格式的注解），但前台ajax提交没有定义dataType属性（定义服务器返回的数据类型）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			    还有一种情况是ajax方法中定义了 dataType:&quot;json&quot;属性，就一定要返回标准格式的json字符串，要不jQuery1.4+以上版本会报错的，因为不是用eval生成对象了，用的JSON.parse，如果字符串不标准就会报错。比如只返回一个简单的字符串“success”，“fail”， true，false，并不是标准的json字符串就会报错。</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		               首先，jQuery 1.4版本之后对服务端返回的JSON 数据要求比较严格，必须严格按照JSON的标准来了。</span></span><br><span class="line"><span class="comment">        	*/</span></span><br><span class="line">			</span><br><span class="line">			console.log(s)</span><br><span class="line">        	console.log(s2)</span><br><span class="line">        	console.log(s3)</span><br><span class="line">        	</span><br><span class="line">            alert(<span class="string">&quot;异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里遇到一个问题：就是传过去数据后，返回值正常，但进入了 error ，使用 console 打印 error 时出现 parsererror</p>
<p>错误原因：ajax 的 datatype 设置问题 我之前设置为 json , 这种只能是接收后台传回来的 json 值 传回其他值就会出现这种错误</p>
<p>解决办法：将 datatype 的类型改为 text</p>
<h3 id="action和onsubmit区别"><a href="#action和onsubmit区别" class="headerlink" title="action和onsubmit区别"></a>action和onsubmit区别</h3><p> Action 是 Form 的属性；onsubmit 是事件！ </p>
<p>执行的先后顺序，onSubmit 在先，先验证，验证返回 false 时，则无法到达 action=”url” 地址。如果是返回 true 或者没有返回值，则通过 action 转向 url 地址。 </p>
<p>也就是说 onsubmit 可以阻止 action 的提交</p>
<p>onSubmit=”return check();” 这里的 return 是一定要写的。不可写成 οnsubmit=check（）;</p>
<h3 id="onsubmit-和-submit"><a href="#onsubmit-和-submit" class="headerlink" title="onsubmit 和 submit"></a>onsubmit 和 submit</h3><p>onsubmit: 一般会用在表单验证中，当返回 false 时，会阻止表单提交，返回 true, 则表单提交成功。</p>
<p>submit: 表单提交方法。</p>
<p>关于这两个方法的用法，却有几个让人迷惑不解的地方，看下面这个表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&#x27;alert(&#x27;</span><span class="attr">submit</span>&#x27;);<span class="attr">return</span> <span class="attr">false</span>&#x27; &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;submit&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当点击提交按钮时，会触发 onsubmit 方法，弹出 alert 框，返回 false, 此时阻止了表单提交。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&#x27;alert(&#x27;</span><span class="attr">submit</span>&#x27;);<span class="attr">return</span> <span class="attr">false</span>&#x27; &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;button&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">onclick</span>=<span class="string">&quot;function()&#123;this.form.submit();&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>此时点击提交，却不会触发 onsubmit 方法，表单成功提交了。</p>
<h3 id="action与submit区别"><a href="#action与submit区别" class="headerlink" title="action与submit区别"></a>action与submit区别</h3><p>action是属性，submit是提交事件</p>
<p>参考2： <a href="http://www.anyrt.com/blog/list/submit.html">http://www.anyrt.com/blog/list/submit.html</a> </p>
<p><img src="/images/Form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/1573638295992.png" alt="1573638295992"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>form表单</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8中处理日期和时间示例</title>
    <url>/2019/12/10/Java-8%E4%B8%AD%E5%A4%84%E7%90%86%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是<code>java.util</code>和<code>java.sql</code>中，都包含<code>Date</code>类，如果要进行时间格式化，还需要<code>java.text.DateFormat</code>类处理。同时<code>java.util.Date</code>中既包含了日期，又包含了时间，所以java8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方日期库<code>joda</code>很多的优点。</p>
<p>在java8中，<code>java.time</code>包下主要包含下面几个主要的类：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant：时间戳</span><br><span class="line">Duration：持续时间，时间差</span><br><span class="line">LocalDate：只包含日期，比如：<span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br><span class="line">LocalTime：只包含时间，比如：<span class="number">23</span>:<span class="number">12</span>:<span class="number">10</span></span><br><span class="line">LocalDateTime：包含日期和时间，比如：<span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">21</span></span><br><span class="line">Period：时间段</span><br><span class="line">ZoneOffset：时区偏移量，比如：+<span class="number">8</span>:<span class="number">00</span></span><br><span class="line">ZonedDateTime：带时区的时间</span><br><span class="line">Clock：时钟，比如获取目前美国纽约的时间</span><br></pre></td></tr></table></figure>

<p>以及<code>java.time.format</code>包中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter：时间格式化</span><br></pre></td></tr></table></figure>

<p>下面我们通过例子来看如何使用java8新的日期时间库</p>
<h4 id="1、获取今天的日期"><a href="#1、获取今天的日期" class="headerlink" title="1、获取今天的日期"></a>1、获取今天的日期</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate todayDate = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期：&quot;</span>+todayDate);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">今天的日期：<span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br></pre></td></tr></table></figure>

<h4 id="2、指定日期，进行相应操作"><a href="#2、指定日期，进行相应操作" class="headerlink" title="2、指定日期，进行相应操作"></a>2、指定日期，进行相应操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取2016年10月的第1天</span></span><br><span class="line">LocalDate firstDay = oneday.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">System.out.println(firstDay);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//取2016年10月的第1天，另外一种写法</span></span><br><span class="line">LocalDate firstDay2 = oneday.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">System.out.println(firstDay2);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//取2016年10月的最后1天，不用考虑大月，小月，平年，闰年</span></span><br><span class="line">LocalDate lastDay = oneday.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(lastDay);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//当前日期＋1天</span></span><br><span class="line">LocalDate tomorrow = oneday.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为闰年</span></span><br><span class="line"><span class="keyword">boolean</span> isLeapYear = tomorrow.isLeapYear();</span><br><span class="line">System.out.println(isLeapYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">21</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="3、生日检查或者账单日检查"><a href="#3、生日检查或者账单日检查" class="headerlink" title="3、生日检查或者账单日检查"></a>3、生日检查或者账单日检查</h4><p>开发过程中，经常需要为过生日的用户送上一些祝福，例如，用户的生日为1990-10-12，如果今天是2016-10-12，那么今天就是用户的生日（按公历／身份证日期来算），那么通过java8新的日期库，我们该如何来进行判断？</p>
<p>在java8中，可以使用<code>MonthDay</code>，该类不包含年份信息，当然还有一个类是<code>YearMonth</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(<span class="number">1990</span>, <span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.of(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">12</span>)); </span><br><span class="line">        System.out.println(today.equals(birthdayMd));</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="4、获取当前的时间"><a href="#4、获取当前的时间" class="headerlink" title="4、获取当前的时间"></a>4、获取当前的时间</h4><p>日期主要是使用LocalTime，该类不包含日期，只有时间信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前的时间</span></span><br><span class="line">LocalTime nowTime = LocalTime.now(); <span class="comment">//结果14:29:40.558</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//如果不想显示毫秒</span></span><br><span class="line">LocalTime nowTime2 = LocalTime.now().withNano(<span class="number">0</span>); <span class="comment">//14:43:14</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//指定时间</span></span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">14</span>, <span class="number">10</span>, <span class="number">21</span>); <span class="comment">//14:10:21</span></span><br><span class="line">LocalTime time2 = LocalTime.parse(<span class="string">&quot;12:00:01&quot;</span>); <span class="comment">// 12:00:01</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//当前时间增加2小时</span></span><br><span class="line">LocalTime nowTimePlus2Hour = nowTime.plusHours(<span class="number">2</span>); <span class="comment">//16:47:23.144</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LocalTime nowTimePlus2Hour2 = nowTime.plus(<span class="number">2</span>, ChronoUnit.HOURS);</span><br></pre></td></tr></table></figure>

<h4 id="5、日期前后比较"><a href="#5、日期前后比较" class="headerlink" title="5、日期前后比较"></a>5、日期前后比较</h4><p>比较2个日期哪个在前，哪个在后，java8 LocalDate提供了2个方法，<code>isAfter()</code>,<code>isBefore</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate specifyDate = LocalDate.of(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(today.isAfter(specifyDate)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="6、处理不同时区的时间"><a href="#6、处理不同时区的时间" class="headerlink" title="6、处理不同时区的时间"></a>6、处理不同时区的时间</h4><p>java8中，将日期，时间，时区都很好的进行了分离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看当前的时区</span></span><br><span class="line">ZoneId defaultZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(defaultZone); <span class="comment">//Asia/Shanghai</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//查看美国纽约当前的时间</span></span><br><span class="line">ZoneId america = ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">LocalDateTime shanghaiTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime americaDateTime = LocalDateTime.now(america);</span><br><span class="line">System.out.println(shanghaiTime); <span class="comment">//2016-11-06T15:20:27.996</span></span><br><span class="line">System.out.println(americaDateTime); <span class="comment">//2016-11-06T02:20:27.996 ，可以看到美国与北京时间差了13小时</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//带有时区的时间</span></span><br><span class="line">ZonedDateTime americaZoneDateTime = ZonedDateTime.now(america);</span><br><span class="line">System.out.println(americaZoneDateTime); <span class="comment">//2016-11-06T02:23:44.863-05:00[America/New_York]</span></span><br></pre></td></tr></table></figure>

<h4 id="7、比较两个日期之前时间差"><a href="#7、比较两个日期之前时间差" class="headerlink" title="7、比较两个日期之前时间差"></a>7、比较两个日期之前时间差</h4><p>在项目中，经常需要比较两个日期之间相差几天，或者相隔几个月，我们可以使用java8的Period来进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate specifyDate = LocalDate.of(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">Period period = Period.between(specifyDate, today);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getDays());  <span class="comment">//4</span></span><br><span class="line">System.out.println(period.getMonths()); <span class="comment">//1</span></span><br><span class="line">System.out.println(specifyDate.until(today, ChronoUnit.DAYS)); <span class="comment">//401</span></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">401</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，我们使用Period类比较天数，比较奇怪，他返回的值，并不是2个日期之间总共的天数差，而是一个相对天数差，比如，5月1日，和10月2日，他比较的是仅仅2个天之间的差，那1号和2号，相差1天，而实际上，因为中间相差了好几个月，所以真正的天数差肯定不是1天，所以我们可以使用until，并指明精度单位是days，就可以计算真正的天数差了。</p>
<h4 id="8、日期时间格式解析、格式化"><a href="#8、日期时间格式解析、格式化" class="headerlink" title="8、日期时间格式解析、格式化"></a>8、日期时间格式解析、格式化</h4><p>在java8之前，我们进行时间格式化主要是使用<code>SimpleDateFormat</code>，而在java8中，主要是使用<code>DateTimeFormatter</code>,java8中，预定义了一些标准的时间格式，我们可以直接将时间转换为标准的时间格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String specifyDate = <span class="string">&quot;20151011&quot;</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;</span><br><span class="line">LocalDate formatted = LocalDate.parse(specifyDate,formatter); </span><br><span class="line">System.out.println(formatted); </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">10</span>-<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>当然，很多时间标准的时间格式可能也不满足我们的要求，我们需要转为自定义的时间格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;YYYY MM dd&quot;</span>);</span><br><span class="line">System.out.println(formatter2.format(LocalDate.now()));</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">2015</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h4 id="9、java8-时间类与Date类的相互转化"><a href="#9、java8-时间类与Date类的相互转化" class="headerlink" title="9、java8 时间类与Date类的相互转化"></a>9、java8 时间类与Date类的相互转化</h4><p>在转换中，我们需要注意，因为java8之前Date是包含日期和时间的，而LocalDate只包含日期，LocalTime只包含时间，所以与Date在互转中，势必会丢失日期或者时间，或者会使用起始时间。如果转LocalDateTime，那么就不存在信息误差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Date与Instant的相互转化</span></span><br><span class="line">Instant instant  = Instant.now();</span><br><span class="line">Date date = Date.from(instant);</span><br><span class="line">Instant instant2 = date.toInstant();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//Date转为LocalDateTime</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.ofInstant(date2.toInstant(), ZoneId.systemDefault());</span><br><span class="line">        </span><br><span class="line"><span class="comment">//LocalDateTime转Date</span></span><br><span class="line">LocalDateTime localDateTime3 = LocalDateTime.now();</span><br><span class="line">Instant instant3 = localDateTime3.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date3 = Date.from(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDate转Date</span></span><br><span class="line"><span class="comment">//因为LocalDate不包含时间，所以转Date时，会默认转为当天的起始时间，00:00:00</span></span><br><span class="line">LocalDate localDate4 = LocalDate.now();</span><br><span class="line">Instant instant4 = localDate4.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date4 = Date.from(instant);</span><br></pre></td></tr></table></figure>



<p>作者：陶清清<br>链接：<a href="https://www.jianshu.com/p/2949db9c3df5">https://www.jianshu.com/p/2949db9c3df5</a></p>
]]></content>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Http 协议</title>
    <url>/2019/11/08/Http-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求头描述了客户端向服务器发送请求时使用的 http 协议类型，所使用的编码，以及发送内容的长度，refer，等等。refer 干嘛的，一般用来做简单的防跨站攻击。</p>
<span id="more"></span>

<p>相应的响应头用来描述服务器回给你对所返回的 content 的一些一些描述，我是什么服务器，我返回的是啥编码，我返回的内容有多长等等。</p>
<p><strong>示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">OST /otn/login/loginAysnSuggest HTTP/1.1Host: kyfw.12306.cnConnection: keep-aliveContent-Length: 203Accept: */*Origin: https://kyfw.12306.cnX-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)                         Chrome/39.0.2171.95 Safari/537.36Content-Type: application/x-www-form-urlencoded; charset=UTF-8Referer: https://kyfw.12306.cn/otn/login/initAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: JSESSIONID=059319E9BB0614197D515D6A0213EC58;     _jc_save_fromStation=%u6DF1%u5733%2CSZQ; _jc_save_toStation=%u5409%u5B89%2CVAG;     _jc_save_fromDate=2015-02-13; _jc_save_toDate=2014-12-16; _jc_save_wfdc_flag=dc;     BIGipServerotn=854589962.50210.0000; _jc_save_detail=true; current_captcha_type=C上面的是请求头，</span><br><span class="line">下面的是相应头</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 29 Dec 2014 02:48:04 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">X-Powered-By: Servlet 2.5; JBoss-5.0/JBossWeb-2.1</span><br><span class="line">ct: c2_50</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Content-Length: 164</span><br><span class="line">X-Via: 1.1 zhj168:5 (Cdn Cache Server V2.0)Connection: keep-alive</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Plus使用</title>
    <url>/2019/12/07/Mybatis_Plus/</url>
    <content><![CDATA[<h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis Plus"></a>Mybatis Plus</h1><h2 id="quickstart：MyBatis-Plus-快速开始示例（Spring-Boot版本）"><a href="#quickstart：MyBatis-Plus-快速开始示例（Spring-Boot版本）" class="headerlink" title="quickstart：MyBatis-Plus 快速开始示例（Spring Boot版本）"></a>quickstart：MyBatis-Plus 快速开始示例（Spring Boot版本）</h2><span id="more"></span>

<ol>
<li><p>设置mapper位置<br><img src="https://paper-attachments.dropbox.com/s_B7895C81F7DC60793FF90222BE18E91C68138E66A34D93E2912DF8CA5F846440_1575702100334_image.png"></p>
</li>
<li><p>数据库配置<br><img src="https://paper-attachments.dropbox.com/s_B7895C81F7DC60793FF90222BE18E91C68138E66A34D93E2912DF8CA5F846440_1575702356213_image.png"></p>
</li>
<li><p>@Resource与@Autowired功能一直，都是对spring对象的引入</p>
</li>
<li><p>执行结果<br><img src="https://paper-attachments.dropbox.com/s_B7895C81F7DC60793FF90222BE18E91C68138E66A34D93E2912DF8CA5F846440_1575702878094_image.png"></p>
</li>
</ol>
<h2 id="quickstart-springmvc：（Spring-MVC版本）"><a href="#quickstart-springmvc：（Spring-MVC版本）" class="headerlink" title="quickstart-springmvc：（Spring MVC版本）"></a>quickstart-springmvc：（Spring MVC版本）</h2><ol>
<li>介绍了spring mvc形式的mybatis plus配置，使用spring.xml形式配置，用过tomcat运行。<h2 id="reduce-springmvc：MyBatis-Plus-简化掉默认mapper类示例"><a href="#reduce-springmvc：MyBatis-Plus-简化掉默认mapper类示例" class="headerlink" title="reduce-springmvc：MyBatis-Plus 简化掉默认mapper类示例"></a>reduce-springmvc：MyBatis-Plus 简化掉默认mapper类示例</h2></li>
<li>，，，有点看不懂，是spring mvc的配置，没有spring boot相关</li>
</ol>
]]></content>
      <tags>
        <tag>spring boot demo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql Sql性能优化</title>
    <url>/2019/11/07/Mysql%20Sql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="一-优化-SQL-步骤"><a href="#一-优化-SQL-步骤" class="headerlink" title="一.优化 SQL 步骤"></a><strong>一.优化 SQL 步骤</strong></h2><span id="more"></span>
<p><strong>1. 通过 show status 和应用特点了解各种 SQL 的执行频率</strong><br>  通过 SHOW STATUS 可以提供服务器状态信息，也可以使用 mysqladmin extende d-status 命令获得。 SHOW STATUS 可以根据需要显示 session 级别的统计结果和 global 级别的统计结果。</p>
<p>如显示当前 session： SHOW STATUS like “Com_%”; 全局级别：show global status;<br>  以下几个参数对 Myisam 和 Innodb 存储引擎都计数：</p>
<p>1）. Com_select 执行 select 操作的次数，一次查询只累加 1 ；</p>
<p>2）. Com_insert 执行 insert 操作的次数，对于批量插入的 insert 操作，只累加一次 ；</p>
<p>3）. Com_update 执行 update 操作的次数；</p>
<p>4）. Com_delete 执行 delete 操作的次数；</p>
<p>以下几个参数是针对 Innodb 存储引擎计数的，累加的算法也略有不同：</p>
<p>1）. Innodb_rows_read select 查询返回的行数；</p>
<p>2）. Innodb_rows_inserted 执行 Insert 操作插入的行数；</p>
<p>3）. Innodb_rows_updated 执行 update 操作更新的行数；</p>
<p>4）. Innodb_rows_deleted 执行 delete 操作删除的行数；</p>
<p>通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还 是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计 数，是对执行次数的计数，不论提交还是回滚都会累加。<br>  对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回 滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。此外，以下几个参数便于我们了解数据库的基本情况：</p>
<p>1）. Connections 试图连接 Mysql 服务器的次数<br> 2）. Uptime 服务器工作时间<br> 3）. Slow_queries 慢查询的次数</p>
<p>**2. 定位执行效率较低的 SQL 语句<br>**   可以通过以下两种方式定位执行效率较低的 SQL 语句：<br>   1）. 可以通过慢查询日志定位那些执行效率较低的 sql 语句，用 –log-slow-queries [=file_name] 选项启动时， mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。可以链接到管理维护中的相关章节。<br>   2）. 使用 show processlist 查看当前 MYSQL 的线程， 命令慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查 询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前 MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看 SQL 执行情况， 同时对一些锁表操作进行优化。<br>   3）. 通过 EXPLAIN 分析低效 SQL 的执行计划：<br>     通过以上步骤查询到效率低的 SQL 后，我们可以通过 explain 或者 desc 获取 MySQL 如何执行 SELECT 语句的信息，包括 select 语句执行过程表如何连接和连接 的次序。</p>
<h2 id="二-MySQL-索引"><a href="#二-MySQL-索引" class="headerlink" title="二. MySQL 索引"></a><strong>二. MySQL 索引</strong></h2><p>**<br>**<strong>1. mysql 如何使用索引</strong><br>    索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高 SELECT 操作性能的最佳途径。<br>    查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列 索引，那么只有查询条件使用了多列关键字最左边的前缀时（前缀索引），才可以使用索引，否则 将不能使用索引。</p>
<p>下列情况下， Mysql 不会使用已有的索引：<br>   1）. 如果 mysql 估计使用索引比全表扫描更慢，则不使用索引。例如：如果 key_part 1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：<br>    SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90<br>   2）. 如果使用 heap 表并且 where 条件中不用＝索引列，其他 &gt; 、 &lt;、&gt;= 、 &lt;= 均不使 用索引（MyISAM 和 innodb 表使用索引）；</p>
<p>3）. 使用 or 分割的条件，如果 or 前的条件中的列有索引，后面的列中没有索引，那么涉及到的索引都不会使用。<br>   4）. 如果创建复合索引，如果条件中使用的列不是索引列的第一部分；（不是前缀索引）<br>   5）. 如果 like 是以％开始；<br>   6）. 对 where 后边条件为字符串的一定要加引号，字符串如果为数字 mysql 会自动转 为字符串，但是不使用索引。</p>
<p>**2. 查看索引使用情况<br>**    如果索引正在工作， Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使 用。<br>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，<br>该值较高。通常说明表索引不正确或写入的查询没有利用索引。<br>    语法：<br>    <strong>mysql&gt; show status like ‘Handler_read%’;</strong></p>
<h2 id="三。具体优化查询语句"><a href="#三。具体优化查询语句" class="headerlink" title="三。具体优化查询语句"></a><strong>三。具体优化查询语句</strong></h2><p> <strong>1. 查询进行优化，应尽量避免全表扫描</strong><br>  对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</p>
<p>.  尝试下面的技巧以避免优化器错选了表扫描：</p>
<p>・  使用 ANALYZE TABLEtbl_name 为扫描的表更新关键字分布。</p>
<p>・  对扫描的表使用 FORCEINDEX 告知 MySQL，相对于使用给定的索引表扫描将非常耗时。</p>
<p>SELECT * FROM t1, t2 FORCE INDEX (index_for_column)  WHERE t1.col_name=t2.col_name；</p>
<p>・  用 –max-seeks-for-key=1000 选项启动 mysqld 或使用 SET max_seeks_for_key=1000 告知优化器假设关键字扫描不会超过 1,000 次关键字搜索。</p>
<p> 1). 应尽量避免在 where 子句中对字段进行 null 值判断</p>
<p>否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num is null</p>
<p>NULL 对于大多数数据库都需要特殊处理，MySQL 也不例外，它需要更多的代码，更多的检查和特殊的索引逻辑，有些开发人员完全没有意识到，创建表时 NULL 是默认值，但大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默 认值。</p>
<p>不能用 null 作索引，任何包含 null 值的列都将不会被包含在索引中。即使索引有多列这样的情况下，只要这些列中有一列含有 null，该列  就会从索引中排除。也就是说如果某列存在空值，即使对该列建索引也不会提高性能。 任何在 where 子句中使用 is null 或 is not null 的语句优化器是不允许使用索引的。</p>
<p>此例可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：</p>
<p>select id  from t where num=0</p>
<p> 2). 应尽量避免在 where 子句中使用！= 或 &lt;&gt; 操作符</p>
<p>否则将引擎放弃使用索引而进行全表扫描。<br>     MySQL 只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的 LIKE。</p>
<p>可以在 LIKE 操作中使用索引的情形是指另一个操作数不是以通配符（% 或者_）开头的情形。例如:<br>     SELECT id FROM t WHERE col LIKE ‘Mich%’; # 这个查询将使用索引，<br>     SELECT id FROM t WHERE col LIKE ‘% ike’;  #这个查询不会使用索引。</p>
<p> 3). 应尽量避免在 where 子句中使用 or 来连接条件</p>
<p>否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num=10 or num=20</p>
<p>可以 使用 UNION 合并查询： select id from t where num=10 union all select id from t where num=20</p>
<p>在某些情况下，or 条件可以避免全表扫描的。</p>
<p>  1 .where 语句里面如果带有 or 条件，myisam 表能用到索引， innodb 不行。</p>
<p>​    2 . 必须所有的 or 条件都必须是独立索引</p>
<p>mysql or 条件可以使用索引而避免全表</p>
<ol start="4">
<li>.in 和 not in 也要慎用，否则会导致全表扫描，</li>
</ol>
<p>如：</p>
<p>select id from t where num in(1,2,3)</p>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<p>Select id from t where num between 1 and 3</p>
<p> 5). 下面的查询也将导致全表扫描：</p>
<p>select id from t where name like ‘% abc%’ 或者</p>
<p>select id from t where name like ‘% abc’ 或者</p>
<p>若要提高效率，可以考虑全文检索。</p>
<p>而 select id from t where name like ‘abc%’ 才用到索引</p>
<p> 6). 如果在 where 子句中使用参数，也会导致全表扫描。</p>
<p>因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推 迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<p>select id from t where num=@num</p>
<p>可以改为强制查询使用索引： select id from t with (index (索引名)) where num=@num</p>
<p> 7). 应尽量避免在 where 子句中对字段进行表达式操作，</p>
<p>这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num/2=100</p>
<p>应改为: select id from t where num=100*2</p>
<p> 8). 应尽量避免在 where 子句中对字段进行函数操作，</p>
<p>这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where substring(name,1,3)=’abc’  –name</p>
<p>select id from t where datediff(day,createdate,’2005-11-30’)=0–‘2005-11-30’</p>
<p>生成的 id 应改为:</p>
<p>select id from t where name like ‘abc%’</p>
<p>select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’</p>
<p>9). 不要在 where 子句中的 “=” 左边进行函数、算术运算或其他表达式运算，</p>
<p>否则系统将可能无法正确使用索引。</p>
<p>10). 索引字段不是复合索引的前缀索引</p>
<p>例如 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p><strong>2 . 其他一些注意优化：</strong><br>11). 不要写一些没有意义的查询，</p>
<p>如需要生成一个空表结构：</p>
<p>select col1,col2 into #t from t where 1=0</p>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t (…)</p>
<p>12). 很多时候用 exists 代替 in 是一个好的选择：</p>
<p>select num from a where num in(select num from b)</p>
<p>用下面的语句替换：</p>
<p>select num from a where exists(select 1 from b where num=a.num)</p>
<p>13). 并不是所有索引对查询都有效，</p>
<p>SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。</p>
<p>14). 索引并不是越多越好，</p>
<p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
<p>15). 应尽可能的避免更新 clustered 索引数据列，</p>
<p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>16). 尽量使用数字型字段，</p>
<p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>17). 尽可能的使用 varchar/nvarchar 代替 char/nchar ，</p>
<p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>18). 最好不要使用 “*” 返回所有： select * from t ，</p>
<p>用具体的字段列表代替 “*”，不要返回用不到的任何字段。</p>
<p>**3. 临时表的问题：<br>**19). 尽量使用表变量来代替临时表。</p>
<p>如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>20). 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>21). 临时表并不是不可使用，</p>
<p>适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
<p>22). 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；</p>
<p>如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。</p>
<p>23). 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>**4. 游标的问题：<br>**24). 尽量避免使用游标，</p>
<p>因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</p>
<p>25). 使用基于游标的方法或临时表方法之前，</p>
<p>应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>26). 与临时表一样，游标并不是不可使用。</p>
<p>对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括 “合计” 的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>27). 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。</p>
<p>无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<p><strong>5. 事务的问题：</strong><br>28). 尽量避免大事务操作，提高系统并发能力。</p>
<p><strong>6. 数据量的问题</strong><br>29). 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。<br>**7. COUNT 优化：<br>*<em>30) count (</em>) 优于 count (1) 和 count (primary_key)</p>
<p>　　很多人为了统计记录条数，就使用 count (1) 和 count (primary_key) 而不是 count (<em>) ，他们认为这样性能更好，其实这是一个误区。对于有些场景，这样做可能性能会更差，应为数据库对 count (</em>) 计数操作做了一些特别的优化。<br>31）count (column) 和 count (*) 是不一样的</p>
<p>　　这个误区甚至在很多的资深工程师或者是 DBA 中都普遍存在，很多人都会认为这是理所当然的。实际上，count (column) 和 count (<em>) 是一个完全不一样的操作，所代表的意义也完全不一样。<br>　　count (column) 是表示结果集中有多少个 column 字段不为空的记录<br>　　count (</em>) 是表示整个结果集有多少条记录</p>
<p><strong>8. 优化 order by 语句</strong><br>   基于索引的排序<br>   MySQL 的弱点之一是它的排序。虽然 MySQL 可以在 1 秒中查询大约 15,000 条记录，但由于 MySQL 在查询时最多只能使用一个索引。因此，如果 WHERE 条件已经占用了索引，那么在排序中就不使用索引了，这将大大降低查询的速度。我们可以看看如下的 SQL 语句:<br>   SELECT * FROM SALES WHERE NAME = “name” ORDER BY SALE_DATE DESC;<br>   在以上的 SQL 的 WHERE 子句中已经使用了 NAME 字段上的索引，因此，在对 SALE_DATE 进行排序时将不再使用索引。为了解决这个问题，我们可以对 SALES 表建立复合索引:<br>   ALTER TABLE SALES DROP INDEX NAME, ADD INDEX (NAME,SALE_DATE)<br>   这样再使用上述的 SELECT 语句进行查询时速度就会大副提升。但要注意，在使用这个方法时，要确保 WHERE 子句中没有排序字段，在上例中就是不能用 SALE_DATE 进行查询，否则虽然排序快了，但是 SALE_DATE 字段上没有单独的索引，因此查询又会慢下来。</p>
<p>在某些情况中， MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。 where 条件和 order by 使用相同的索引，并且 order by 的顺序和索引顺序相 同，并且 order by 的字段都是升序或者都是降序。例如：下列 sql 可以使用索引。<br>   SELECT * FROM t1 ORDER BY key_part1,key_part2,… ;<br>   SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;<br>   SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;<br>  但是以下情况不使用索引：<br>   SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC ； –order by 的字段混合 ASC 和 DESC<br>   SELECT * FROM t1 WHERE key2=constant ORDER BY key1 ；– 用于查询行的关键字与 ORDER BY 中所使用的不相同<br>   SELECT * FROM t1 ORDER BY key1, key2 ；– 对不同的关键字使用 ORDER BY ：</p>
<p>*<em>9. 优化 GROUP BY<br>**   默认情况下， MySQL 排序所有 GROUP BY col1 ， col2 ， …. 。查询的方法如同在查询中指定 ORDER BY col1 ， col2 ， … 。如果显式包括一个包含相同的列的 ORDER BY<br>子句， MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括 GROUP BY 但你想要避免排序结果的消耗，你可以指定 ORDER BY NULL 禁止排序。<br>例如 ：<br>INSERT INTO foo SELECT a, COUNT(</em>) FROM bar GROUP BY a ORDER BY NULL;</p>
<p><strong>10. 优化 OR</strong><br>具体详解看：mysql or 条件可以使用索引而避免全表</p>
<h2 id="四-Explain-解释说明"><a href="#四-Explain-解释说明" class="headerlink" title="四. Explain 解释说明"></a><strong>四. Explain 解释说明</strong></h2><p>explain 显示了 mysql 如何使用索引来处理 select 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。<br>使用方法，在 select 语句前加上 explain 就可以了：<br>如：</p>
<p>explain select surname,first_name form a,b where a.id=b.id<br>分析结果形式如下：<br><strong>table | type | possible_keys | key | key_len | ref | rows | Extra<br>EXPLAIN 列的解释：</strong><br>**1 table:<br>**显示这一行的数据是关于哪张表的<br><strong>2 type:</strong><br>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为：system、const、eg_reg、ref、ref_or_null、 range、indexhe、 ALL。<br>    system: 表仅有一行 (= 系统表)。这是 const 联接类型的一个特例<br>    const:(PRIMARY KEY 或 UNIQUE)<br>      表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。<br>      const 表很快，因为它们只读取一次！<br>      const 用于用常数值比较 PRIMARY KEY 或 UNIQUE 索引的所有部分时。<br>      在下面的查询中，tbl_name 可以用于 const 表：<br>SELECT * from tbl_name WHERE primary_key=1；<br>    eq_reg:key<br> 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了 const 类型。<br>      它用在一个索引的所有部分被联接使用并且索引是 UNIQUE 或 PRIMARY KEY。<br>      eq_ref 可以用于使用 = 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。<br> 在下面的例子中，MySQL 可以使用 eq_ref 联接来处理 ref_tables：<br>SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;<br>  SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column<br>                         AND ref_table.key_column_part2=1; </p>
<p>ref:key<br> 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用 ref。</p>
<p>如果使用的键仅仅匹配少量行，该联接类型是不错的。<br> ref 可以用于使用 = 或 &lt;=&gt; 操作符的带索引的列。<br> 在下面的例子中，MySQL 可以使用 ref 联接来处理 ref_tables：</p>
<p>SELECT * FROM ref_table WHERE key_column=expr;<br> SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;<br> SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column<br>             AND ref_table.key_column_part2=1;<br>   ref_or_null:Or Is null<br>该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。在解决子查询中经常使用该联接类型的优化。<br>    在下面的例子中，MySQL 可以使用 ref_or_null 联接来处理 ref_tables：<br>SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL;<br>   range:=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN<br> 只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引。<br>     key_len 包含所使用索引的最长关键元素。在该类型中 ref 列为 NULL。<br>当使用 =、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符，用常量比较关键字列时，可以使用 range：<br>SELECT * FROM tbl_name WHERE key_column = 10;<br>SELECT * FROM tbl_name WHERE key_column BETWEEN 10 and 20;<br>SELECT * FROM tbl_name WHERE key_column IN (10,20,30);<br>SELECT * FROM tbl_name WHERE key_part1= 10 AND key_part2 IN (10,20,30);<br>   indexhe:<br>该联接类型与 ALL 相同，除了只有索引树被扫描。这通常比 ALL 快，因为索引文件通常比数据文件小。<br>当查询只使用作为单索引一部分的列时，MySQL 可以使用该联接类型。<br>   ALL：<br>对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记 const 的表，<br>    这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用 ALL，<br>    使得行能基于前面的表中的常数值或列值被检索出。<br><strong>3 possible_keys :</strong><br>  显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从 WHERE 语句中<br>  选择一个合适的语句<br>**4 key ：<br>** 实际使用的索引。如果为 NULL，则没有使用索引。很少的情况下，MYSQL 会选择优化不足的索引 。<br> 这种情况下，可以在 SELECT 语句中使用 USEINDEX（indexname）来强制使用一个索引或者用 IGNORE INDEX（indexname）来强制 MYSQL 忽略索引<br><strong>5key_len:</strong><br>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
<p>**6 ref<br>**显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
<p><strong>7 rows</strong><br>MYSQL 认为必须检查的用来返回请求数据的行数 (扫描行的数量)</p>
<p><strong>8 Extra</strong><br> 该列包含 MySQL 解决查询的详细信息<br> 关于 MYSQL 如何解析查询的额外信息。将在表 4.3 中讨论，但这里可以看到的坏的例子是 Using temporary 和 Using filesort，<br> 意思 MYSQL 根本不能使用索引，结果是检索会很慢</p>
<p>extra 列返回的描述的意义</p>
<p><strong>Distinct:</strong><br>一旦 MYSQL 找到了与行相联合匹配的行，就不再搜索了<br>**Not exists :<br>**MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行， 就不再搜索了<br>    面是一个可以这样优化的查询类型的例子：<br>SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL；<br>假定 t2.id 定义为 NOT NULL。在这种情况下，MySQL 使用 t1.id 的值扫描 t1 并查找 t2 中的行。<br>    如果 MySQL 在 t2 中发现一个匹配的行，它知道 t2.id 绝不会为 NULL，并且不再扫描 t2 内有相同的 id 值的行。<br>    换句话说，对于 t1 的每个行，MySQL 只需要在 t2 中查找一次，无论 t2 内实际有多少匹配的行。<br>**Range checked for each Record（index map:#）<br>**没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL 检查使用哪个索引，并用它来从表中返回行。<br>    这是使用索引的最慢的连接之一<br>    MySQL 没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。<br>    对前面的表的每个行组合，MySQL 检查是否可以使用 range 或 index_merge 访问方法来索取行。<br>    关于适用性标准的描述参见 7.2.5 节，“范围优化” 和 7.2.6 节，“索引合并优化”，<br>    不同的是前面表的所有列值已知并且认为是常量。这并不很快，但比执行没有索引的联接要快得多。<br><strong>Using filesort</strong><br>看到这个的时候，查询就需要优化了。MYSQL 需要进行额外的步骤来发现如何对返回的行排序。<br>    它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行<br><strong>Using index</strong><br>列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，<br>    这发生在对表的全部的请求列都是同一个索引的部分的时候<br><strong>Using temporary</strong><br>看到这个的时候，查询需要优化了。这里，MYSQL 需要创建一个临时表来存储结果，这通常发生在对不同的列集进行 ORDER BY 上，而不是 GROUP BY 上<br><strong>Using where</strong><br>使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，<br>    并且连接类型 ALL 或 index，这就会发生，或者是查询有问题<br>Impossible WHERE noticed after reading const table…</p>
<h2 id="五-SQL-核心语句-非常实用的几个技巧"><a href="#五-SQL-核心语句-非常实用的几个技巧" class="headerlink" title="五 SQL 核心语句 (非常实用的几个技巧)"></a><strong>五 SQL 核心语句 (非常实用的几个技巧)</strong></h2><p><strong>1) 插入数据</strong></p>
<p><strong>批量插入:</strong></p>
<p>INSERT mytable (first_column,second_column,third_column) VALUES (‘some data’,’some more data’,’yet more data’) , VALUES (‘some data’,’some more data’,’yet more data’) , VALUES (‘some data’,’some more data’,’yet more data’) **<br>**</p>
<p><strong>2）. 清空数据表</strong></p>
<p>TRUNCATE TABLE <code>mytable</code> </p>
<p>注意：删除表中的所有记录，应使用 TRUNCATE TABLE 语句。注意这里为什么要用 TRUNCATE TABLE 语句代替 DELETE 语句：当你使用 TRUNCATE TABLE 语句时，记录的删除是不作记录的。也就是说，这意味着 TRUNCATE TABLE 要比 DELETE 快得多。</p>
<p><strong>3）用 SELECT 创建记录和表</strong></p>
<p>　　INSERT 语句与 DELETE 语句和 UPDATE 语句有一点不同，它一次只操作一个记录。然而，有一个方法可以使 INSERT 语句一次添加多个记录。要作到这一点，你需要把 INSERT 语句与 SELECT 语句结合起来，象这样:</p>
<p>INSERT mytable(first_column,second_column) SELECT another_first,another_second FROM anothertable WHERE another_first=’Copy Me!’; 　　</p>
<p>这个语句从 anothertable 拷贝记录到 mytable. 只有表 anothertable 中字段 another_first 的值为 ‘Copy Me!’ 的记录才被拷贝。</p>
<p>　　当为一个表中的记录建立备份时，这种形式的 INSERT 语句是非常有用的。在删除一个表中的记录之前，你可以先用这种方法把它们拷贝到另一个表中。</p>
<p>　　如果你需要拷贝整个表，你可以使用 SELECT INTO 语句。例如，下面的语句创建了一个名为 newtable 的新表，该表包含表 mytable 的所有数据:</p>
<p>SELECT * INTO newtable FROM mytable; </p>
<p>你也可以指定只有特定的字段被用来创建这个新表。要做到这一点，只需在字段列表中指定你想要拷贝的字段。另外，你可以使用 WHERE 子句来限制拷贝到新表中的记录。下面的例子只拷贝字段 second_columnd 的值等于 ‘Copy Me!’ 的记录的 first_column 字段。</p>
<p>SELECT first_column INTO newtable FROM mytable WHERE second_column=’Copy Me!’;</p>
<p>使用 SQL 修改已经建立的表是很困难的。例如，如果你向一个表中添加了一个字段，没有容易的办法来去除它。另外，如果你不小心把一个字段的数据类型给错了，你将没有办法改变它。但是，使用本节中讲述的 SQL 语句，你可以绕过这两个问题。</p>
<p>　　例如，假设你想从一个表中删除一个字段。使用 SELECT INTO 语句，你可以创建该表的一个拷贝，但不包含要删除的字段。这使你既删除了该字段，又保留了不想删除的数据。</p>
<p>　　如果你想改变一个字段的数据类型，你可以创建一个包含正确数据类型字段的新表。创建好该表后，你就可以结合使用 UPDATE 语句和 SELECT 语句，把原来表中的所有数据拷贝到新表中。通过这种方法，你既可以修改表的结构，又能保存原有的数据。</p>
<p>总结：</p>
<p>![1573133269971](/images/Mysql Sql性能优化/1573133269971.png)</p>
<p><a href="https://blog.csdn.net/hguisu/article/details/5731629">参考</a></p>
]]></content>
      <categories>
        <category>sql优化</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基本命令、优化、事物</title>
    <url>/2019/10/31/Mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E3%80%81%E4%BC%98%E5%8C%96%E3%80%81%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[<h3 id="MySQL高性能优化规范建议"><a href="#MySQL高性能优化规范建议" class="headerlink" title="MySQL高性能优化规范建议"></a>MySQL高性能优化规范建议</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE.md">参考</a> （详细）</li>
<li><a href="https://blog.csdn.net/java_mdzy/article/details/75304297">参考</a> （总结）</li>
</ul>
<span id="more"></span>

<h3 id="Mysql命令集合（一千行）"><a href="#Mysql命令集合（一千行）" class="headerlink" title="Mysql命令集合（一千行）"></a>Mysql命令集合（一千行）</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4.md">参考</a></li>
</ul>
<h3 id="Mysql框架和基本语句执行顺序"><a href="#Mysql框架和基本语句执行顺序" class="headerlink" title="Mysql框架和基本语句执行顺序"></a>Mysql框架和基本语句执行顺序</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%9C%A8mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.md">参考</a></li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md">详细参考</a></li>
<li>怎么避免事物问题</li>
</ul>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.md">参考</a></li>
</ul>
<h3 id="阿里巴巴Java开发手册数据库部分"><a href="#阿里巴巴Java开发手册数据库部分" class="headerlink" title="阿里巴巴Java开发手册数据库部分"></a>阿里巴巴Java开发手册数据库部分</h3><ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md">参考</a></li>
</ul>
<p><img src="/images/sql%E4%BC%98%E5%8C%96/1572475896688.png" alt="1572475896688"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx使用</title>
    <url>/2019/11/08/Nginx%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>百度百科上的解释如下：</p>
<span id="more"></span>

<blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
</blockquote>
<p>​        通俗的讲，反向代理就是一台负责转发请求及请求结果的服务器，在客户机看来它就是服务器。但事实上它只是服务的入口和出口，真正处理请求和返回结果的是它将请求分发给的服务器。</p>
<p>​        比如：我们让 Nginx 监听在 80 端口，但实际上处理业务的 Tomcat 使用的端口为 8080。那么当客户机发送请求到 Nginx，Nginx 再将请求转发给 Tomcat，Tomcat 处理响应的业务逻辑，并将处理结果返回给 Nginx，再由 Nginx 返回给客户机。</p>
<pre><code>     做了反向代理才能实现负载均衡。负载均衡是做反向代理的目的之一。 
</code></pre>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>保护网站安全，在 Internet 和服务器之间建立一道屏障。敏感信息加密，防止 URL 重写暴露，充当真正服务器替身防止攻击等。</p>
</li>
<li><p>提供缓存功能，减少真正服务器的压力，缓存静态文件，比如 CSS，JS，html，图片等静态资源文件。</p>
</li>
<li><p>实现负载均衡，将请求进行均衡分发，平衡每个服务器的压力</p>
</li>
</ul>
<h3 id="Nginx使用"><a href="#Nginx使用" class="headerlink" title="Nginx使用"></a>Nginx使用</h3><p>​        进入 Nginx 的安装目录的 conf 目录下（默认是在 <code>/usr/local/nginx/conf</code>），编辑 nginx.conf 文件:</p>
<p><img src="/images/Nginx%E4%BD%BF%E7%94%A8/1573027848967.png" alt="1573027848967"></p>
<p><img src="/images/Nginx%E4%BD%BF%E7%94%A8/1573027994588.png" alt="1573027994588"><img src="/images/Nginx%E4%BD%BF%E7%94%A8/1573092647459.png" alt="1573092647459"></p>
<h3 id="Nginx-禁止-ip-访问页面"><a href="#Nginx-禁止-ip-访问页面" class="headerlink" title="Nginx 禁止 ip 访问页面"></a><strong>Nginx 禁止 ip 访问页面</strong></h3><p>这样做是为了避免其他人把未备案的域名解析到自己的服务器 IP，而导致服务器被断网，我们可以通过禁止使用 ip 访问的方法，防止此类事情的发生。</p>
<p>有以下两种方法都可以做到</p>
<p>1）识别访问主机名，在原 server 段里插入如下内容：—只通过自己的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listen       <span class="number">80</span>;</span><br><span class="line">server_name  www.yuyangblog.net;</span><br><span class="line"><span class="keyword">if</span> ($host != <span class="string">&#x27;www.yuyangblog.net&#x27;</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加一个 server （注意是新增，并不是在原有的 server 基础上修改）—添加禁止</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen <span class="number">80</span> <span class="keyword">default</span>;</span><br><span class="line">  server_name _;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Null和“”的区别</title>
    <url>/2019/12/25/Null%E5%92%8C%E2%80%9C%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Null和“”的区别"><a href="#Null和“”的区别" class="headerlink" title="Null和“”的区别"></a>Null和“”的区别</h1><span id="more"></span>

<p><img src="https://paper-attachments.dropbox.com/s_F3B064B7257955F95C6DD62AA89806D5B132089178CEDA145AB3B4C779A8BA61_1577267974518_image.png"></p>
<p><strong>” 和 null 的区别</strong><br>null 是没有地址的，可以理解为空指针。当对象在构造器初始化时，如果没有被显示的赋于初值，那么会默认赋值为 null。<br>“” 空字符串是一个 String 对象是有地址的，只是内容是空。<br>关于构造器初始化，在没有显示赋予初值的情况下。默认将数值型赋为 0 ， 布尔型是 false，对象引用则是 null。<br>String 并不是基本数据类型，而是对象所以会被默认的赋予 null。</p>
<h2 id="字符串非空判断"><a href="#字符串非空判断" class="headerlink" title="字符串非空判断"></a>字符串非空判断</h2><p>isEmpty() 和 isBlank() 区别在于 isBlank() 可以多了对于空格的判断，可以根据方法名区别使用 isEmpty() 判断字符串是否为空，而 isBlank() 则是判断字符串是否是空格，空或null</p>
<p><img src="https://paper-attachments.dropbox.com/s_F3B064B7257955F95C6DD62AA89806D5B132089178CEDA145AB3B4C779A8BA61_1577269007385_image.png"></p>
<p><img src="https://paper-attachments.dropbox.com/s_F3B064B7257955F95C6DD62AA89806D5B132089178CEDA145AB3B4C779A8BA61_1577268950577_image.png"></p>
<h2 id="集合判空检查"><a href="#集合判空检查" class="headerlink" title="集合判空检查"></a>集合判空检查</h2><p>要了解集合判空方法的区别首先要理解对象为size == 0 和 null 的区别</p>
<p>size==0 和 null 的区别<br>null 是没有地址的，可以理解为空指针。当对象在构造器初始化时，如果没有被显示的赋于初值，那么会默认赋值为 null。<br>size==0 表示集合已经指向一个地址，但是指向的对象中没有元素。<br>isEmpty() 和 isBlank() 区别在于 isBlank()</p>
<p><img src="https://paper-attachments.dropbox.com/s_F3B064B7257955F95C6DD62AA89806D5B132089178CEDA145AB3B4C779A8BA61_1577269070933_image.png"></p>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p><img src="https://paper-attachments.dropbox.com/s_F3B064B7257955F95C6DD62AA89806D5B132089178CEDA145AB3B4C779A8BA61_1577269568268_image.png"></p>
<p>空指针的length会报错</p>
<p><img src="https://paper-attachments.dropbox.com/s_F3B064B7257955F95C6DD62AA89806D5B132089178CEDA145AB3B4C779A8BA61_1577270087384_image.png"></p>
<ol>
<li>对象new出来以后是有地址的，所以不为空；</li>
<li>对象不为空，但字段是null，对象.字段不会报错，但对象.字段length会报错（null.length）</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle SQL性能优化</title>
    <url>/2019/11/06/Oracle%20SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><strong>（1）</strong>   选择最有效率的表名顺序(只在基于规则的优化器中有效)：</p>
<span id="more"></span>

<p>ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.<br><strong>（2）</strong>   WHERE子句中的连接顺序．：<br>ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.<br><strong>（3）</strong>   SELECT子句中避免使用 ‘ * ‘：<br>ORACLE在解析的过程中, 会将’’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间<br><strong>（4）</strong>   减少访问数据库的次数：<br>ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等；<br><strong>（5）</strong>   在SQLPlus , SQL<em>Forms和Pro</em>C中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为200<br><strong>（6）</strong>   使用DECODE函数来减少处理时间：<br>使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表.<br><strong>（7）</strong>   整合简单,无关联的数据库访问：<br>如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)<br><strong>（8）</strong>   删除重复记录：<br>最高效的删除重复记录方法 ( 因为使用了ROWID)例子：<br>DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID)<br>FROM EMP X WHERE X.EMP_NO = E.EMP_NO);<br><strong>（9）</strong>   用TRUNCATE替代DELETE：<br>当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML)<br><strong>（10）</strong> 尽量多使用COMMIT：<br>只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少:<br>COMMIT所释放的资源:<br>a. 回滚段上用于恢复数据的信息.<br>b. 被程序语句获得的锁<br>c. redo log buffer 中的空间<br>d. ORACLE为管理上述3种资源中的内部花费<br><strong>（11）</strong> 用Where子句替换HAVING子句：<br>避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销. (非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里<br><strong>（12）</strong> 减少对表的查询：<br>在含有子查询的SQL语句中,要特别注意减少对表的查询.例子：<br>   SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT<br>TAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604)<br><strong>（13）</strong> 通过内部函数提高SQL效率.：<br>复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的<br><strong>（14）</strong> 使用表的别名(Alias)：<br>当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.<br><strong>（15）</strong> 用EXISTS替代IN、用NOT EXISTS替代NOT IN：<br>在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.<br>例子：<br>（高效）SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND <strong>EXISTS</strong> (SELECT ‘X’ FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB’)<br>(低效)SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND DEPTNO <strong>IN</strong>(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB’)<br><strong>（16）</strong> **识别’**<strong>低效执行’的SQL语句：</strong><br>虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法：<br>SELECT EXECUTIONS , DISK_READS, BUFFER_GETS,<br>ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio,<br>ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run,<br>SQL_TEXT<br>FROM V$SQLAREA<br>WHERE EXECUTIONS&gt;0<br>AND BUFFER_GETS &gt; 0<br>AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8<br>ORDER BY 4 DESC;</p>
<p><strong>（17）</strong> 用索引提高效率：<br>索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的.：<br>ALTER INDEX <INDEXNAME> REBUILD <TABLESPACENAME><br><strong>（18）</strong> 用EXISTS替换DISTINCT：<br>当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果. 例子：<br>    (低效):<br>SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP E<br>WHERE D.DEPT_NO = E.DEPT_NO<br>(高效):<br>SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X’<br>FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO);<br><strong>（19）</strong> sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行<br><strong>（20）</strong> 在java代码中尽量少用连接符“＋”连接字符串！<br><strong>（21）</strong> <strong>避免在索引列上使用NOT</strong> <strong>通常</strong>，　<br>我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描.<br><strong>（22）</strong> 避免在索引列上使用计算．<br>WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．<br>举例:<br>低效：<br>SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000;<br>高效:<br>SELECT … FROM DEPT WHERE SAL &gt; 25000/12;<br><strong>（23）</strong> 用&gt;=替代&gt;<br>高效:<br>SELECT * FROM EMP WHERE DEPTNO &gt;=4<br>低效:<br>SELECT * FROM EMP WHERE DEPTNO &gt;3<br>两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录.<br><strong>（24）</strong> *<em>用UNION</em><em>*<em>替换OR (<strong><strong>适用于索引列)</strong><br>通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引.<br>高效:<br>SELECT LOC_ID , LOC_DESC , REGION<br>FROM LOCATION<br>WHERE LOC_ID = 10<br>UNION<br>SELECT LOC_ID , LOC_DESC , REGION<br>FROM LOCATION<br>WHERE REGION = “MELBOURNE”<br>低效:<br>SELECT LOC_ID , LOC_DESC , REGION<br>FROM LOCATION<br>WHERE LOC_ID = 10 OR REGION = “MELBOURNE”<br>如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.<br><strong>（25）</strong> <strong>用IN</strong></strong>来替换OR</em>*<br>这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的．　<br>低效:<br>SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30<br>高效<br>SELECT… FROM LOCATION WHERE LOC_IN IN (10,20,30);<br><strong>（26）</strong> <strong>避免在索引列上使用IS NULL</strong></em><em>和IS NOT NULL</em>*<br>避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录.　如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空. 因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引.<br>低效: (索引失效)<br>SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL;<br>高效: (索引有效)<br>SELECT … FROM DEPARTMENT WHERE DEPT_CODE &gt;=0;<br><strong>（27）</strong> <strong>总是使用索引的第一个列****：</strong><br>如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引<br><strong>（28）</strong> <strong>用UNION-ALL</strong> <strong>替换UNION (</strong> *<em>如果有可能的话)<strong><strong>：</strong><br>当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序. 如果用UNION ALL替代UNION, 这样排序就不是必要了. 效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的优化也是相当重要的. 下面的SQL可以用来查询排序的消耗量<br>低效：<br>SELECT ACCT_NUM, BALANCE_AMT<br>FROM DEBIT_TRANSACTIONS<br>WHERE TRAN_DATE = ‘31-DEC-95’<br>UNION<br>SELECT ACCT_NUM, BALANCE_AMT<br>FROM DEBIT_TRANSACTIONS<br>WHERE TRAN_DATE = ‘31-DEC-95’<br>高效:<br>SELECT ACCT_NUM, BALANCE_AMT<br>FROM DEBIT_TRANSACTIONS<br>WHERE TRAN_DATE = ‘31-DEC-95’<br>UNION ALL<br>SELECT ACCT_NUM, BALANCE_AMT<br>FROM DEBIT_TRANSACTIONS<br>WHERE TRAN_DATE = ‘31-DEC-95’<br><strong>（29）</strong> <strong>用WHERE</strong></strong>替代ORDER BY</em><em><strong>：</strong><br>ORDER BY 子句只在两种严格的条件下使用索引.<br>ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序.<br>ORDER BY中所有的列必须定义为非空.<br>WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列.<br>例如:<br>表DEPT包含以下列:<br>DEPT_CODE PK NOT NULL<br>DEPT_DESC NOT NULL<br>DEPT_TYPE NULL<br>低效: (索引不被使用)<br>SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE<br>高效: (使用索引)<br>SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0<br><strong>（30）</strong> <strong>避免改变索引列的类型.:</strong><br>当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换.<br>假设 EMPNO是一个数值类型的索引列.<br>SELECT … FROM EMP WHERE EMPNO = ‘123’<br>实际上,经过ORACLE类型转换, 语句转化为:<br>SELECT … FROM EMP WHERE EMPNO = TO_NUMBER(‘123’)<br>幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变.<br>现在,假设EMP_TYPE是一个字符类型的索引列.<br>SELECT … FROM EMP WHERE EMP_TYPE = 123<br>这个语句被ORACLE转换为:<br>SELECT … FROM EMP WHERETO_NUMBER(EMP_TYPE)=123<br>因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型<br><strong>（31）</strong> <strong>需要当心的WHERE</strong></em><em>子句:</em>*<br>某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子.<br>在下面的例子里, (1)‘!=’ 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中. (2) ‘||’是字符连接函数. 就象其他函数那样, 停用了索引. (3) ‘+’是数学函数. 就象其他数学函数那样, 停用了索引. (4)相同的索引列不能互相比较,这将会启用全表扫描.<br><strong>（32）</strong> a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高.<br>b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!<br><strong>（33）</strong> <strong>避免使用耗费资源的操作:</strong><br>带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎<br>执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强<br><strong>（34）</strong> <strong>优化GROUP BY:</strong><br>提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多.<br>低效:<br>SELECT JOB , AVG(SAL)<br>FROM EMP<br>GROUP JOB<br>HAVING JOB = ‘PRESIDENT’<br>OR JOB = ‘MANAGER’<br>高效:<br>SELECT JOB , AVG(SAL)<br>FROM EMP<br>WHERE JOB = ‘PRESIDENT’<br>OR JOB = ‘MANAGER’<br>GROUP JOB</p>
<p><a href="https://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html">参考</a></p>
]]></content>
      <categories>
        <category>sql优化</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 11g 存储过程实现</title>
    <url>/2019/11/05/Oracle-11g-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>感觉这块没多少东西，使用场景也很明显，就是在需要进行大量数据同步时设置，知道用法就可以了。   </p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://blog.csdn.net/qq_21419015/article/details/84651944">Oracle 11g 存储过程实现</a></p>
<p><a href="https://xuexiyuan.cn/article/detail/212.html">参考2</a></p>
<span id="more"></span>

<h3 id="创建公共数据库链接"><a href="#创建公共数据库链接" class="headerlink" title="创建公共数据库链接"></a>创建公共数据库链接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> PUBLIC DATABASE LINK &quot;test_B&quot;</span><br><span class="line"> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> &quot;ORACLE&quot; IDENTIFIED <span class="keyword">BY</span> <span class="keyword">VALUES</span> <span class="string">&#x27;:1&#x27;</span></span><br><span class="line"> <span class="keyword">USING</span> <span class="string">&#x27;(DESCRIPTION =</span></span><br><span class="line"><span class="string">      (ADDRESS_LIST =</span></span><br><span class="line"><span class="string">        (ADDRESS =(PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</span></span><br><span class="line"><span class="string">      )</span></span><br><span class="line"><span class="string">      (CONNECT_DATA =(SERVICE_NAME = ORCL))</span></span><br><span class="line"><span class="string">    )&#x27;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title>SELECT * FROM A,B 能查出多少条数据？</title>
    <url>/2019/11/07/SELECT-FROM-A-B-%E8%83%BD%E6%9F%A5%E5%87%BA%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>SELECT * FROM A,B 能查出多少条数据？</strong></p>
<span id="more"></span>

<p><img src="/images/SELECT-FROM-A-B-%E8%83%BD%E6%9F%A5%E5%87%BA%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F/1573093900373.png" alt="1573093900373"></p>
<p><img src="/images/SELECT-FROM-A-B-%E8%83%BD%E6%9F%A5%E5%87%BA%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F/1573093915086.png" alt="1573093915086"></p>
<p><img src="/images/SELECT-FROM-A-B-%E8%83%BD%E6%9F%A5%E5%87%BA%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%9F/1573093958488.png" alt="1573093958488"></p>
<p><a href="https://www.cnblogs.com/hanzongze/p/oracle-sql-rows.html">参考</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Scheduled定时任务</title>
    <url>/2019/12/27/Schedule%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h2><p>一、注解示例</p>
<pre><code>@Scheduled(fixedDelay = 1000 * 10,initialDelay=1000*15)
public void Task() &#123; 
 
&#125;
</code></pre>
<span id="more"></span>

<p>二、注解说明</p>
<pre><code>@Scheduled(fixedRate=2000)：上一次开始执行时间点后2秒再次执行；
@Scheduled(fixedDelay=2000)：上一次执行完毕时间点后2秒再次执行；
@Scheduled(initialDelay=1000, fixedDelay=2000)：第一次延迟1秒执行，然后在上一次执行完毕时间点后2秒再次执行；
@Scheduled(cron=&quot;* * * * * ?&quot;)：按cron规则执行。
</code></pre>
<p>三、常用的cron表达式</p>
<pre><code>&quot;0 0 10,14,16 * * ?&quot; 每天上午10点，下午2点，4点 
&quot;0 0/30 9-17 * * ?&quot;   朝九晚五工作时间内每半小时
&quot;0 0 12 ? * WED&quot; 表示每个星期三中午12点
&quot;0 0 12 * * ?&quot; 每天中午12点触发
&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发
&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发
&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发
&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发
&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发
&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发
&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发
&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发
&quot;0 15 10 ? * 6L 20014-20018&quot; 2014年至2018年的每月的最后一个星期五上午10:15触发
&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发
&quot;0 15 10 ? * *&quot; 每天上午10:15触发
&quot;0 15 10 * * ?&quot; 每天上午10:15触发
&quot;0 15 10 * * ? *&quot; 每天上午10:15触发
&quot;0 15 10 * * ? 2017&quot; 2017年的每天上午10:15触发
</code></pre>
]]></content>
      <tags>
        <tag>spring boot demo</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream函数式编程</title>
    <url>/2020/01/10/Stream%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Session底层源码解析与实际应用</title>
    <url>/2019/11/08/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="# 简介"></a><strong># 简介</strong></h3><span id="more"></span>

<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/640.webp" alt="img"></p>
<p>session（会话），其实是一个容易让人误解的词。它总跟 web 系统的会话挂钩，利用 session，javaweb 项目实现了登录状态的控制。坊间流传，关闭浏览器，就是关闭了 web 系统的会话。</p>
<p>其实浏览器对于会话有自己的定义，而 web 系统对于会话也有自己的定义。在 tomcat 中，session 通常是指实现了 HttpSession 接口的实现类。并且不存在关闭浏览器就会关闭 tomcat 的 HttpSession 这种状况。</p>
<p>session 本身并不难，如果只是做登录校验之类的功能，并不需要深入了解，但难的是 session 和 cookie 的结合使用，在不同情况下浏览器对 cookie 的控制行为所涉及到的诸多细节，我搜查了很多资料，查看过 tomcat 源码，亦是没有找到全面的概述。</p>
<p>当然我并未看过、也不知道去哪里看比较全面的关于浏览器对 cookie 的控制资料，如果有知道的大神，还望留言链接。本文题目，之所以说是探讨，而不是了解或者介绍，因为我自己也卡在了某个点上，由于时间关系，我不能花太多时间去研究，但又不忍心就此放弃，所以先记录下来，日后有机会再研究，这期间如有大神指点，也许能让我茅塞顿开。</p>
<h3 id="Session-本质"><a href="#Session-本质" class="headerlink" title="# Session 本质"></a><strong># Session 本质</strong></h3><p>我用的是 javaweb 项目，因此这里的 session 特指 HttpSession。先来看下 tomcat 源码中对 session 的设计，在 org.apache.catalina.session 包下，有如下设计。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483597.webp)</p>
<p>平时所用到的 HttpSession 的实现类就是这个 standardSession。但是所获取的 HttpSession 实例确是外观类 StandardSessionFacade，其屏蔽了许多方法，但也增强了安全性。</p>
<p>HttpSession 提供了一些方法，来控制 session 或者获取 session 的状态，如获取 session 的 id，获取 session 的创建时间，设置 session 的 attribute，使 session 失效等。值得一提的是 session 的 attribute 其实是一个线程安全的 hashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**     * The collection of user data attributes associated with this Session.     */    protected ConcurrentMap&lt;String, Object&gt; attributes = new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>但是，创建 session、根据 id 获取 session 的方法并不在这里，而是在一个管理器中，其设计如下。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483598.webp)</p>
<p>ManagerBase 是实现了 Manager 接口的抽象类，实现了管理 session 的功能。其实现子类 PersistentManagerBase 拓展了将 session 持久化的功能。但是这里不需要讲到其子类。</p>
<p>看 ManagerBase 中的一段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The set of currently active Sessions for this Manager, keyed by</span><br><span class="line">    * session identifier.</span><br><span class="line">    */</span><br><span class="line">   protected Map&lt;String, Session&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>由此可知，所谓的 session，其实就是一个用线程安全的 hashMap 存储起来的实现了 Session 接口的 standardSession 对象，在 hashmap 中以其 id 为 key，自身为 value。</p>
<p>再看获取 session 的方法，一目了然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Session <span class="title">findSession</span><span class="params">(String id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sessions.get(id);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最重要的是看其 createSession 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Session <span class="title">createSession</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((maxActiveSessions &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                (getActiveSessions() &gt;= maxActiveSessions)) &#123;</span><br><span class="line">            rejectedSessions++;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TooManyActiveSessionsException(</span><br><span class="line">                    sm.getString(<span class="string">&quot;managerBase.createSession.ise&quot;</span>),</span><br><span class="line">                    maxActiveSessions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recycle or create a Session instance</span></span><br><span class="line">        Session session = createEmptySession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the properties of the new session and return it</span></span><br><span class="line">        session.setNew(<span class="keyword">true</span>);</span><br><span class="line">        session.setValid(<span class="keyword">true</span>);</span><br><span class="line">        session.setCreationTime(System.currentTimeMillis());</span><br><span class="line">        session.setMaxInactiveInterval(getContext().getSessionTimeout() * <span class="number">60</span>);</span><br><span class="line">        String id = sessionId;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            id = generateSessionId();</span><br><span class="line">        &#125;</span><br><span class="line">        session.setId(id);</span><br><span class="line">        sessionCounter++;</span><br><span class="line"></span><br><span class="line">        SessionTiming timing = <span class="keyword">new</span> SessionTiming(session.getCreationTime(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (sessionCreationTiming) &#123;</span><br><span class="line">            sessionCreationTiming.add(timing);</span><br><span class="line">            sessionCreationTiming.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是在什么时候调用的呢？当浏览器访问系统时，request 会解析请求中携带的 jssesionid，用它去找到存在于应用中的 session，但是如果没有找到，那么就会调用 session 的创建方法，并且生成一个新的 jssessionid，返回 session。</p>
<ul>
<li>客户端第一次请求服务器，cookie 中不存在与 url 相对应的 sessionid。所以 request headers 的 cookie 头里不包含 sessionid 的内容，甚至不包含 cookie 请求头；</li>
<li>服务端调用 request.getSession (); , 没有 sessionid 自然无法取得相应的 session 信息，立即创建新的 session；</li>
<li>新创建的 session 信息被服务端存储下来，sessionid 被添加到 response 的 set-cookie 响应头，并返回给客户端；</li>
<li>客户端接收到 response 报文的 cookie 内容，并将其保存在本地；</li>
<li>客户端再一次请求服务器，浏览器将根据 url，解析出相应的 sessionid，并添加到 cookie 请求头，发送给服务器；</li>
<li>服务端调用 request.getSession (); , 根据 sessionid 从 session 存储里获得相应的 session 信息，然后进一步操作，再响应给客户端。</li>
</ul>
<p>总而言之，session 是存在于线程安全的 map 中的值，可以通过 id 找到，也可以使用 invalidate 方法销毁，但绝不会是浏览器关闭，就能对它进行销毁的。</p>
<h3 id="Cookie-简介"><a href="#Cookie-简介" class="headerlink" title="# Cookie 简介"></a><strong># Cookie 简介</strong></h3><p>提到 session，那么 cookie 是不得不说的。至于 cookie 是什么，我就不多说了，大家都懂。直接看其内容吧。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483598.webp)</p>
<p>这是一次 http 请求中（<a href="http://localhost:8080/test1%EF%BC%89%EF%BC%8C%E5%8C%85%E5%90%AB%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%98%AF%E5%AF%B9%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%9D%E6%AC%A1%E8%AE%BF%E9%97%AE%EF%BC%8C%E7%94%A8%E7%9A%84%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%82">http://localhost:8080/test1），包含的请求和响应信息，是对一个系统的初次访问，用的谷歌浏览器。</a></p>
<p>请求头中，包含的 Cookie 信息，并没有上文提到的 jsessionid, 那是因为这是对系统的初次访问，系统还没生成 session。但是访问之后，系统就会生成一个 session，而且，会在响应流中设置响应头 Set-Cookie，其值为 JESSIONID=xxx。这样浏览器对 localhost:8080 和 cookie 的联系就有了记忆，浏览器会将其存储起来，可在调试工具中看到。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483630.webp)</p>
<p>那么再次访问 <a href="http://localhost:8080/test1">http://localhost:8080/test1</a>, 浏览器会主动在请求头添加包括 jsession 的 cookie 信息。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483665.webp)</p>
<p>系统根据这个 jsessionid 找到 session，也就不会在响应头中添加 Set-Cookie 信息。</p>
<p>这里说一下 cookie 中的两个重要属性。</p>
<ul>
<li>domain 表示的是 cookie 所在的域，默认为请求的地址，如网址为 <a href="http://www.test.com/test/test.aspx%EF%BC%8C%E9%82%A3%E4%B9%88">www.test.com/test/test.aspx，那么</a> domain 默认为 <a href="http://www.test.com.而跨域访问,如域/">www.test.com。而跨域访问，如域</a> A 为 t1.test.com，域 B 为 t2.test.com，<strong>那么在域 A 生产一个令域 A 和域 B 都能访问的 cookie 就要将该 cookie 的 domain 设置为.test.com</strong>；如果要在域 A 生产一个令域 A 不能访问而域 B 能访问的 cookie 就要将该 cookie 的 domain 设置为 t2.test.com。</li>
</ul>
<p><strong>目前开发项目解决方案：</strong></p>
<ol>
<li><strong>cookie</strong>里确实设置的domain是***.com类似后缀结尾的，相关系统的也就是其他子系统的后缀，这样在访问子系统是cookie就是共享的了。</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemSecondUrl</span>=<span class="string">.smda.sh.cn</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/1573176692611.png" alt="1573176692611"></p>
<ol start="2">
<li><p>跳转子系统过程</p>
<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/1573177099764.png" alt="1573177099764"></p>
</li>
<li><p>在跳转过来后，怎么获取当前用户的呢？其实这里首先会被shiro拦截器拦截，</p>
<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/1573177421842.png" alt="1573177421842"></p>
</li>
<li><p>子系统从cookie中获取当前用户</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">            String userId = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String userInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String loginUrl = <span class="keyword">this</span>.loginUrl;</span><br><span class="line">            <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果cookie为空，直接返回登录页面</span></span><br><span class="line">                <span class="keyword">if</span>(cookies == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    response.sendRedirect(loginUrl);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               	<span class="comment">// 从cookie中获取当</span></span><br><span class="line">                <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(SysConstant.COOKIE_USER_ID.equals(cookie.getName())</span><br><span class="line">                            &amp;&amp; StringUtils.isNotBlank(cookie.getValue()))&#123;</span><br><span class="line">                        userId = cookie.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(SysConstant.COOKIE_USER_INFO.equals(cookie.getName())</span><br><span class="line">                            &amp;&amp; StringUtils.isNotBlank(cookie.getValue()))&#123;</span><br><span class="line">                        userInfo = cookie.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取缓存是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(StringUtils.isBlank(userInfo)</span><br><span class="line">                        || StringUtils.isBlank(userId))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            session.invalidate(); <span class="comment">//（???）</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    response.sendRedirect(loginUrl);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//shiro解密</span></span><br><span class="line">                String userInfoStr = ShfdaConfusionUtil.deconfuse(userInfo);</span><br><span class="line">                String[] userInfos = userInfoStr.split(<span class="string">&quot;\\|\\|\\|&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(userInfos !=<span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; userInfos.length &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(userInfos[<span class="number">0</span>], userInfos[<span class="number">1</span>],<span class="keyword">false</span>);</span><br><span class="line">                    Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">                    currentUser.login(token);</span><br><span class="line">                    <span class="keyword">if</span>(currentUser.isAuthenticated())&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                response.sendRedirect(loginUrl);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里子系统只做校验，校验通过后，在shiro中校验当前用户名密码是否正确，设置当前用户登录，直接调到到链接登录。</p>
<p>校验代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Logger log = LoggerFactory.getLogger(UserRealm.class);</span><br><span class="line">	<span class="keyword">private</span> QxglSignUtil qxglApiUtil;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 为当前登录的Subject授予角色和权限</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 经测试:本例中该方法的调用时机为需授权资源被访问时</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 经测试:并且每次访问需授权资源时都会执行该方法中的逻辑,这表明本例中默认并未启用AuthorizationCache</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 个人感觉若使用了Spring3.1开始提供的ConcurrentMapCache支持,则可灵活决定是否启用AuthorizationCache</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 比如说这里从数据库获取权限信息时,先去访问Spring3.1提供的缓存,而不使用Shior提供的AuthorizationCache</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span></span>&#123;</span><br><span class="line">	    	Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">	    	User user = (User)currentUser.getSession().getAttribute(SysConstant.CURRENT_USER);</span><br><span class="line">	    	List&lt;String&gt; shirorolespermis = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		    <span class="keyword">if</span>(user !=<span class="keyword">null</span>)&#123;</span><br><span class="line">		    	log.info(<span class="string">&quot;doGetAuthorizationInfo================start--&quot;</span>+user.getUserName());</span><br><span class="line">		    	log.info(<span class="string">&quot;doGetAuthorizationInfo================start--&quot;</span>+user.getPassword());</span><br><span class="line">		    	<span class="comment">//获取权限</span></span><br><span class="line">		    	ResponseShfdaPermission rsp = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					qxglApiUtil = SysParameter.getInstance().getQxglApiUtil();</span><br><span class="line">					rsp = qxglApiUtil.getUserPermissions(user.getUserId(),</span><br><span class="line">							user.getUserName(), user.getPassword());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (ApiServiceException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		    	<span class="keyword">if</span>(rsp != <span class="keyword">null</span> &amp;&amp; rsp.getShfdaPermissions() != <span class="keyword">null</span> &amp;&amp; rsp.getShfdaPermissions().size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			    	<span class="keyword">for</span>(ShfdaPermission sp: rsp.getShfdaPermissions())&#123;</span><br><span class="line">			    		<span class="keyword">if</span>(StringUtils.isNotBlank(sp.getPerValue()))&#123;</span><br><span class="line">			    			shirorolespermis.add(sp.getPerValue());</span><br><span class="line">			    		&#125;</span><br><span class="line">			        &#125;</span><br><span class="line">		    	&#125;</span><br><span class="line">		    	SimpleAuthorizationInfo simpleAuthorInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">		    	simpleAuthorInfo.addStringPermissions(shirorolespermis);</span><br><span class="line">		    	<span class="keyword">return</span> simpleAuthorInfo;</span><br><span class="line">		    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		    	 <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 验证当前登录的Subject</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 经测试:本例中该方法的调用时机为LoginController.login()方法中执行Subject.login()时</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authcToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	    	UsernamePasswordToken token = (UsernamePasswordToken)authcToken;</span><br><span class="line">	        ShfdaUser shfdaUser = <span class="keyword">null</span>;</span><br><span class="line">	        qxglApiUtil = SysParameter.getInstance().getQxglApiUtil();</span><br><span class="line">	        <span class="keyword">try</span>&#123;</span><br><span class="line">	        	shfdaUser = qxglApiUtil.getUserInAllViewByUserName(token.getUsername(),</span><br><span class="line">	        			token.getUsername(),<span class="keyword">new</span> String(token.getPassword()));</span><br><span class="line">	        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">	        	ex.printStackTrace();</span><br><span class="line">	        	<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();<span class="comment">//没找到帐号</span></span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(!<span class="string">&quot;0&quot;</span>.equals(shfdaUser.getReturnCode())) &#123;</span><br><span class="line">	            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();<span class="comment">//没找到帐号</span></span><br><span class="line">	        &#125;</span><br><span class="line">	        AuthenticationInfo authcInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(shfdaUser.getUserName(), shfdaUser.getPassword(), <span class="keyword">this</span>.getName());</span><br><span class="line">	        <span class="keyword">if</span>(!shfdaUser.isHasRole())&#123;</span><br><span class="line">	        	<span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">	        &#125;</span><br><span class="line">	        User user = <span class="keyword">new</span> User();</span><br><span class="line">	        <span class="keyword">if</span>(<span class="string">&quot;SHFDA&quot;</span>.equals(shfdaUser.getUserCategory()))&#123;</span><br><span class="line">	        	JSONObject userJson = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					userJson = qxglApiUtil.getUserJsonByUserId(shfdaUser.getUserId(),</span><br><span class="line">							shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">					user = User.fromJson(userJson);</span><br><span class="line">					<span class="comment">//用户 市局处室、监管部门</span></span><br><span class="line">					<span class="keyword">if</span>(ShfdaUser.USER_TYPE_SJCS_DEPART_IDS.contains(user.getDepartId()))&#123;</span><br><span class="line">						user.setUserType(ShfdaUser.USER_TYPE_SJCS);</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ShfdaUser.USER_TYPE_ZSDW_ORG_IDS.contains(user.getOrgId()))&#123;</span><br><span class="line">						user.setUserType(ShfdaUser.USER_TYPE_ZSDW);</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						user.setUserType(ShfdaUser.USER_TYPE_SCJ);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(StringUtils.isNotBlank(user.getOrgId()))&#123;</span><br><span class="line">						ShfdaOrg shfdaOrg= qxglApiUtil.getOrgByOrgId(user.getOrgId(), shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">						<span class="keyword">if</span>(shfdaOrg!=<span class="keyword">null</span>)&#123;</span><br><span class="line">							user.setRegionId(shfdaOrg.getRegionId());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">		        	user.setUserCategory(<span class="string">&quot;SHFDA&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (ApiServiceException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">				&#125;</span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	        	user.setUserId(shfdaUser.getUserId());</span><br><span class="line">                YlqxEnpSdk ylqxEnp = <span class="keyword">null</span>;</span><br><span class="line">                QxscEnpSdk qxscEnp = <span class="keyword">null</span>;</span><br><span class="line">                EnpUser enpUser = <span class="keyword">null</span>;</span><br><span class="line">                DsfptSdk dsfptSdk = <span class="keyword">null</span>;</span><br><span class="line">                QyglApiUtil qyglApiUtil = SysParameter.getInstance().getQyglApiUtil();</span><br><span class="line">                QxscApiUtil qxscApiUtil = SysParameter.getInstance().getQxscApiUtil();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    enpUser = qxglApiUtil.getEnpUserById(shfdaUser.getUserId(),</span><br><span class="line">                            shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">                    <span class="keyword">if</span>(enpUser == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">//没找到帐号</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ylqxEnp = qyglApiUtil.getSimpleEnpById(shfdaUser.getUserId(),</span><br><span class="line">                            shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">                    qxscEnp = qxscApiUtil.getSimpleById(shfdaUser.getUserId(),</span><br><span class="line">                            shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">					dsfptSdk = qyglApiUtil.getSimpleByEnpPkId(shfdaUser.getUserId(),</span><br><span class="line">							shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">					<span class="keyword">if</span>(ylqxEnp != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(ylqxEnp.getEnpPkId()))&#123;</span><br><span class="line">                        user.setRegionId(ylqxEnp.getRegionCode());</span><br><span class="line">                        user.setOrgId(ylqxEnp.getOrgId());</span><br><span class="line">						user.setDepartId(ylqxEnp.getSupervision());</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(qxscEnp != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(qxscEnp.getEnpPkId()))&#123;</span><br><span class="line">                        user.setRegionId(qxscEnp.getRegionCode());</span><br><span class="line">                        user.setOrgId(qxscEnp.getOrgId());</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !(dsfptSdk != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(dsfptSdk.getEnpPkId())))&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EnpNotExistException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    user.setEnp(ylqxEnp);</span><br><span class="line">                    user.setQxscEnp(qxscEnp);</span><br><span class="line">					user.setDsfptSdk(dsfptSdk);</span><br><span class="line">                    user.setUserName(shfdaUser.getUserName());</span><br><span class="line">                    user.setPassword(shfdaUser.getPassword());</span><br><span class="line">                    user.setUserCategory(<span class="string">&quot;ENP&quot;</span>);</span><br><span class="line">                    user.setContact(enpUser.getContact());</span><br><span class="line">                    user.setEmail(enpUser.getEmail());</span><br><span class="line">                    user.setStatus(enpUser.getStatus());</span><br><span class="line">                    user.setIsModifPwd(enpUser.getIsModifyPwd());</span><br><span class="line">                    user.setTel(enpUser.getTel());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ApiServiceException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">                &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">this</span>.setSession(SysConstant.CURRENT_USER, user);</span><br><span class="line">	        <span class="keyword">return</span> authcInfo;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 将一些数据放到ShiroSession中,以便于其它地方使用</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 比如Controller,使用时直接用HttpSession.getAttribute(key)就可以取到</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSession</span><span class="params">(Object key, Object value)</span></span>&#123;</span><br><span class="line">	        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">	        <span class="keyword">if</span>(<span class="keyword">null</span> != currentUser)&#123;</span><br><span class="line">	            Session session = currentUser.getSession();</span><br><span class="line">	            <span class="keyword">if</span>(<span class="keyword">null</span> != session)&#123;</span><br><span class="line">	                session.setAttribute(key, value);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="5">
<li>父级系统登录时设置,设置用户信息到cookie中（userId，userInfo）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentUser.login(token);</span><br><span class="line">     	<span class="keyword">if</span>(currentUser.isAuthenticated())&#123; </span><br><span class="line">         	js.put(<span class="string">&quot;returnCode&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">          	js.put(<span class="string">&quot;returnMessage&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">          	loginLog.setRemark(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">          	loginLog.setLogType(<span class="number">0</span>);</span><br><span class="line">          	<span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         		 User currUser = (User)session.getAttribute(SysConstant.CURRENT_USER);</span><br><span class="line">         		 String userInfo = ShfdaConfusionUtil.getLoginStr(username,pwd);</span><br><span class="line">         		 Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_ID&quot;</span>, currUser.getUserId());</span><br><span class="line">         		 cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">         		 <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">         			 cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">         		 &#125;</span><br><span class="line">         		 response.addCookie(cookie);</span><br><span class="line">         		 cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_INFO&quot;</span>, userInfo);</span><br><span class="line">         		 cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">         		 <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">         			 cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">         		 &#125;</span><br><span class="line">             	 response.addCookie(cookie);</span><br><span class="line">		cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_RANGE&quot;</span>, currUser.getInfoQueryRange());</span><br><span class="line">		cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">			cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">		&#125;</span><br><span class="line">		response.addCookie(cookie);</span><br><span class="line">		<span class="comment">//获取全部权限</span></span><br><span class="line">		JSONObject json= qxglApiUtil.getAllPerssion( <span class="string">&quot;ADMIN_INNER&quot;</span>, <span class="string">&quot;ADMIN_INNER&quot;</span>);</span><br><span class="line">		JSONArray array=json.getJSONArray(<span class="string">&quot;jsonArray&quot;</span>);</span><br><span class="line">		JSONObject jsonPermission=<span class="keyword">null</span>;</span><br><span class="line">		List&lt;ShfdaPermission&gt; allPermissions=<span class="keyword">new</span> ArrayList&lt;ShfdaPermission&gt;();</span><br><span class="line">		String url = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		List&lt;String&gt; allURL = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="comment">//将json数组格式化成权限类型</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.size();i++)&#123;</span><br><span class="line">			jsonPermission=array.getJSONObject(i);</span><br><span class="line">			allPermissions.add(ShfdaPermission.fromJson(jsonPermission));</span><br><span class="line">			url = allPermissions.get(i).getUrl();</span><br><span class="line">			<span class="keyword">if</span>(url!=<span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(url))&#123;</span><br><span class="line">				allURL.add(url);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		session.setAttribute(<span class="string">&quot;allURL&quot;</span>, allURL);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>子系统单点登录功能，其实是和登录方法是一样的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/nssologin&quot;,method=&#123;RequestMethod.POST,RequestMethod.GET&#125;,produces=&#123;MediaType.APPLICATION_JSON_VALUE&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">nssologin</span><span class="params">(<span class="meta">@RequestParam(&quot;loginStr&quot;)</span> String loginStr, HttpSession session, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String[] userInfos = SsoUtil.getUserInfo(loginStr);</span><br><span class="line">           String userName = userInfos[<span class="number">0</span>];</span><br><span class="line">           qxglApiUtil = SysParameter.getInstance().getQxglApiUtil();</span><br><span class="line">           ShfdaUser user = qxglApiUtil.getUserByUserName(userName,<span class="string">&quot;ADMIN_INNER&quot;</span>,<span class="string">&quot;ADMIN_INNER&quot;</span>);</span><br><span class="line">           UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(user.getUserName(),</span><br><span class="line">                   user.getPassword(),<span class="keyword">false</span>);</span><br><span class="line">           Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">           currentUser.login(token);</span><br><span class="line">           <span class="keyword">if</span>(currentUser.isAuthenticated())&#123;</span><br><span class="line">               ServletContext application = session.getServletContext();</span><br><span class="line">               application.setAttribute(userName,session.getId());</span><br><span class="line">               <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   ShfdaUser currUser = getCurrentUser(session);</span><br><span class="line">                   String userInfo = ShfdaConfusionUtil.getLoginStr(userName,user.getPassword());</span><br><span class="line">                   Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_ID&quot;</span>, currUser.getUserId());</span><br><span class="line">                   cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                   <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">                       cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">                   response.addCookie(cookie);</span><br><span class="line">                   cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_INFO&quot;</span>, userInfo);</span><br><span class="line">                   cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                   <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">                       cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">                   response.addCookie(cookie);</span><br><span class="line">                   <span class="comment">//清除错误次数缓存</span></span><br><span class="line">                   qxglApiUtil.clearLoginErrorCountCache(userName, currUser.getUserName(), currUser.getPassword());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;redirect:/login&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>path 表示 cookie 所在的目录，默认为 /，就是根目录。在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个 cookie1 的 path 为 /test/，cookie2 的 path 为 /test/cd/，那么 test 下的所有页面都可以访问到 cookie1，而 /test/ 和 /test/dd/ 的子页面不能访问 cookie2。这是因为 cookie 能让其 path 路径下的页面访问。</li>
</ul>
<h3 id="疑点"><a href="#疑点" class="headerlink" title="# 疑点"></a><strong># 疑点</strong></h3><p>下面，就该说下我的疑点了。</p>
<h4 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a><strong>情况 1</strong></h4><p>但是当我在 8081 的一个方法中，重定向到 8080 的一个路径时，发现了奇怪的现象。</p>
<p>8081 系统的方法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        String id = session.getId();</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;http://localhost:8080/test1&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>8080 系统的被重定向路径如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get11</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       HttpSession session = request.getSession();</span><br><span class="line">       String id = session.getId();</span><br><span class="line">       System.out.println(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>1、初次访问 localhost:8081/test 得到两次请求的信息，一次是重定向的，一次是 8080 的。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483698.webp)</p>
<p>这说明对 8081 系统的初次访问，是没有发送 jsessionid 信息的，而 8081 系统生成了一个 id 为 CAAB6AED34716A0394705BDE8CAC0042 的 session 并设置到了响应头，再次访问 8081 时理应会带上这么一个 id。</p>
<p>2、</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483702.webp)</p>
<p>这个对 8080 系统的请求中带有 jsessionid 为 CAAB6AED34716A0394705BDE8CAC0042 的 cookie 信息，要知道，我们对 8080 的访问也是初次的，那么为什么会带上 jsessionid 呢？而且这个 jsessionid 明显是在 8081 系统中生成并设置到响应头的的 jsessionid。这个现象我用谷歌和 edge 浏览器分别尝试过，都是这样。那么是不是说明，浏览器把这个重定向到 localhost:8080 的请求当成是同域的请求了 。</p>
<p>暂且放下这个疑惑，继续往下验证。由于这个请求是对 8080 的系统的访问，由于是初次访问，系统根本没有 id 为 CAAB6AED34716A0394705BDE8CAC0042 的 session，因此只好生成一个新的 session，在响应头中增加 Set-Cookie。</p>
<p>3、<br>再次访问 localhost:8081/test，这时根据上文说的，“再次访问 8081 时理应会带上这么一个 id”，也就是在 cookie 中带上 JSESSION=CAAB6AED34716A0394705BDE8CAC0042, 但是，我发现它带的却是在系统 8080 中生成的 BA0D2C939ADEC087C0A5F0C9B3354891 ！！！</p>
<p>这就导致了 8081 找不到 session 又再次生成了一个新的 session，循环往复，每次对 8081 的访问都会产生新的 session。而这情况，我觉得很明显，是浏览器把对 8081 的访问当成是于 8080 同源的了。</p>
<p>基于此推论，我模拟了另一种实验情况，去掉重定向的功能：</p>
<h4 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a><strong>情况 2</strong></h4><h4 id="在本地开两个-web-服务，端口分别是-8080-8081。"><a href="#在本地开两个-web-服务，端口分别是-8080-8081。" class="headerlink" title="在本地开两个 web 服务，端口分别是 8080,8081。"></a>在本地开两个 web 服务，端口分别是 8080,8081。</h4><p>localhost:8081/test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       HttpSession session = request.getSession();</span><br><span class="line">       String id = session.getId();</span><br><span class="line">       System.out.println(id);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>localhost:8080/test1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get11</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      HttpSession session = request.getSession();</span><br><span class="line">      String id = session.getId();</span><br><span class="line">      System.out.println(id);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、第一次访问-8081-test"><a href="#1、第一次访问-8081-test" class="headerlink" title="1、第一次访问 8081/test"></a>1、第一次访问 8081/test</h4><p>![img](/images/说说你对 Session 的理解？/640-1573167483742.webp)</p>
<p>没有 cookie，服务器设置 set-cookie，正常。</p>
<h4 id="2、第二次访问-8081-test"><a href="#2、第二次访问-8081-test" class="headerlink" title="2、第二次访问 8081/test"></a>2、第二次访问 8081/test</h4><p>![img](/images/说说你对 Session 的理解？/640-1573167483777.webp)</p>
<p>cookie 与上次的 set-cookie 一致，正常。</p>
<h4 id="3、第一次访问-8080-test1"><a href="#3、第一次访问-8080-test1" class="headerlink" title="3、第一次访问 8080/test1"></a>3、第一次访问 8080/test1</h4><p>![img](/images/说说你对 Session 的理解？/640-1573167483779.webp)</p>
<p>浏览器把 8081/test 的 cookie 发过去了。8080 的服务器找不到这个 jsessionid，又重新设置了 jsessionid，等到再次访问 8081/test 时，大家也能猜到会发生什么了吧。</p>
<h3 id="推论"><a href="#推论" class="headerlink" title="# 推论"></a><strong># 推论</strong></h3><p>至此，我斗胆推论，浏览器会对同一 ip 不同端口的服务访问认定是可以进行 cookie 共享的，两个 cookie 的 domain 是一致的。而这种 cookie 的截图也一定程度上印证了我的想法。</p>
<p>![img](/images/说说你对 Session 的理解？/640-1573167483816.webp)</p>
<p>cookie 的 domain 似乎只认定域名，无关端口。</p>
<p>但是根据浏览器的同源策略，同域名不同端口的访问也应该是跨域的啊。除非浏览器的域跟 cookie 的 domain 在概念上是有区别的，对于这点，我没找到确切的官方资料，但网上大神是这么说的。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>基于上面的未查阅官方资料而做出的不严谨的推论，我想，只要完全避免同域的情况就可以避开这个问题。于是我把 8081 和 8080 系统分别部署在两个机器上。由于不同 ip，这样无论如何，两个 cookie 都不会是同 domain 的了。果然，结果是没有问题的。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>虽然这个解决方案避开了同域的问题，但是没有彻底解决，毕竟同域的系统相互之间的访问也是有必要的，为此希望能获得更多的建议或者资料，补充这方面知识的不足，让我彻底解决这个问题。</p>
<p>这里，东哥来做个总结吧，文中的作者卡在了同源策略和跨域的问题，本文描述的的问题是属于跨域的问题。</p>
<p>同源指的是协议、域名、端口都相同（可通过题图来理解此概念）。浏览器之所以要制定同源策略，其目的便是防止页面加载来源不明的脚本，而被黑客操作。</p>
<p>而跨域指的是域名不同，跟端口没有关系。比如常用的 JSONP 技术，便是利用了 <script> 标签的跨域能力来访问跨域数据。</p>
<p><a href="https://mp.weixin.qq.com/s/ffVhvQinqaGyyVfeL9Cbzg">参考</a></p>
]]></content>
      <categories>
        <category>session</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 家庭版安装docker踩坑指南</title>
    <url>/2019/12/30/Win10_%E5%AE%B6%E5%BA%AD%E7%89%88%E5%AE%89%E8%A3%85docker%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<pre><code>    最近在学习RabbitMq，需要在docker安装，本以为windows系统安装docker很简单，结果安装后因为是家庭版的原因，虚拟机不能打开。
    在程序与应用中找Hyper-V虚拟机，根本找不到，更不要提打开，所以跟docker一起安装的Oracle VM根本打不开，docker也就卡到了这一步。
    
    看到windows现在能安装linux子系统，本想着曲线救国，结果ubuntu，安装好之后，docker正确安装后，根本不能启动啊，提示[docker daemon](https://blog.csdn.net/HOOKTTG/article/details/80626369)，**目前WSL是不支持Docker的守护进程，但您可以使用**[**Docker CLI**](https://nickjanetakis.com/blog/get-to-know-dockers-ecosystem#docker-cli)**连接到通过**[**Docker for Windows**](https://nickjanetakis.com/blog/should-you-use-the-docker-toolbox-or-docker-for-mac-windows)**或您创建的任何其他VM 运行的远程Docker守护进程。**
</code></pre>
<span id="more"></span>

<p><img src="https://paper-attachments.dropbox.com/s_738771BB227B1C1F2EF6F47EFCC749FF7D49FCBE524F29CEEC917D3CE6B308B5_1577680987613_image.png"></p>
<pre><code>    所以到了这一步，又要需要docker for windows的setting里的配置开着，但是家庭版根本就打不开虚拟机，更别提到docker的配置这一步，这就尴尬了。

    同时在网上也找到了一些解释，确实不太行：
</code></pre>
<p><img src="https://paper-attachments.dropbox.com/s_738771BB227B1C1F2EF6F47EFCC749FF7D49FCBE524F29CEEC917D3CE6B308B5_1577680860573_image.png"></p>
<p><img src="https://paper-attachments.dropbox.com/s_738771BB227B1C1F2EF6F47EFCC749FF7D49FCBE524F29CEEC917D3CE6B308B5_1577680897996_image.png"></p>
<p><a href="https://www.cnblogs.com/xiaoliangge/p/9134585.html">详细介绍</a></p>
<p>所以目前来看，找个学生认证，买个服务器还是比较靠谱的。</p>
<p>可惜我今年刚超过24了，唉╮(╯▽╰)╭</p>
<p>目前其他的解决办法： 可以安装虚拟机，但是太大了，idea已经不小了，太占内存了，没有16g还是放弃吧。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>String能否被继承</title>
    <url>/2019/09/02/String%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><span id="more"></span>

<p><img src="/images/String%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/1572655588995.png" alt="1572655588995"></p>
<h3 id="final、finalize、finally"><a href="#final、finalize、finally" class="headerlink" title="final、finalize、finally"></a>final、finalize、finally</h3><p><img src="/images/String%E8%83%BD%E5%90%A6%E8%A2%AB%E7%BB%A7%E6%89%BF/20180906132649986.png" alt="img"> </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas线上排错</title>
    <url>/2019/09/20/arthas%E7%BA%BF%E4%B8%8A%E6%8E%92%E9%94%99/</url>
    <content><![CDATA[<h3 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h3><p>​    最近在优化Excel文件导入功能，用户单条输入数据太过复杂时，系统可以提供Excel导入功能，通过提供Excel导入模版，规范用户导入的数据格式，也可以通过poi工具生成Excel数据。</p>
<span id="more"></span>

<p>​    但当用户导入数据量较大时，几千条甚至上万条数据导入时，系统不能正常导入。之前一直以为是因为导入速度过慢，导致数据库连接超时或事物连接超时导致报错。今天用Arthas进行线上排查后发现数据导入时的校验速度并不慢，而是中间各种报错导致的。</p>
<h3 id="2、排错过程如下："><a href="#2、排错过程如下：" class="headerlink" title="2、排错过程如下："></a>2、排错过程如下：</h3><ol>
<li>首先复制arthas-boot.jar包到线上，通过java -jar运行</li>
</ol>
<p><img src="/images/arthas%E7%BA%BF%E4%B8%8A%E6%8E%92%E9%94%99/1572526987138.png" alt="1572526987138"></p>
<ol start="2">
<li><p>选择项目，直接输入数字即可</p>
<p><img src="/images/arthas%E7%BA%BF%E4%B8%8A%E6%8E%92%E9%94%99/1572527117799.png" alt="1572527117799"></p>
</li>
<li><p>查看类下方法每一行运行时间</p>
<p><img src="/images/arthas%E7%BA%BF%E4%B8%8A%E6%8E%92%E9%94%99/1572527539858.png" alt="1572527539858"></p>
<ol start="4">
<li>查看当前类方法的报错信息，也可以查看入参及返回结果</li>
</ol>
<p>watch  全类名.方法名 throwExp  </p>
<p>watch 全类名 (空格) 方法名 “{params,throwExp}” -e -x 2 </p>
<p>示例：watch com.springboot.controller.UserController exception “{params,throwExp}” -e -x 2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[arthas@5912]$ watch com.boor.qxzssb.service.impl.enp.EnpProductServiceImpl importEnpProDuct throwExp</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:3 , method-cnt:3) cost in 812 ms.</span><br><span class="line">ts=2019-10-31 17:19:27; [cost=152.637766ms] result=org.springframework.web.client.HttpClientErrorException: 404 Not Found</span><br><span class="line">        at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:91)</span><br><span class="line">        at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:641)</span><br><span class="line">        at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:597)</span><br><span class="line">        at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:565)</span><br><span class="line">        at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:272)</span><br><span class="line">        at com.boor.sdk.util.CpglApiUtil.getMedicalByPassNum(CpglApiUtil.java:83)</span><br><span class="line">        at com.boor.qxzssb.service.impl.enp.EnpProductServiceImpl.importEnpProDuct(EnpProductServiceImpl.java:1030)</span><br><span class="line">        at com.boor.qxzssb.service.impl.enp.EnpProductServiceImpl$$FastClassBySpringCGLIB$$8fd6895f.invoke(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:651)</span><br><span class="line">        at com.boor.qxzssb.service.impl.enp.EnpProductServiceImpl$$EnhancerBySpringCGLIB$$7ba52a68.importEnpProDuct(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line">        at com.boor.qxzssb.service.impl.enp.EnpProductServiceImpl$$FastClassBySpringCGLIB$$8fd6895f.invoke(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:651)</span><br><span class="line">        at com.boor.qxzssb.service.impl.enp.EnpProductServiceImpl$$EnhancerBySpringCGLIB$$b9c9f17e.importEnpProDuct(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line">        at com.boor.qxzssb.service.AsyncService.analysisFile(AsyncService.java:109)</span><br><span class="line">        at com.boor.qxzssb.service.AsyncService$$FastClassBySpringCGLIB$$fce482c0.invoke(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line">        at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)</span><br><span class="line">        at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:651)</span><br><span class="line">        at com.boor.qxzssb.service.AsyncService$$EnhancerBySpringCGLIB$$a85d40a9.analysisFile(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line">        at com.boor.qxzssb.service.AsyncService$$FastClassBySpringCGLIB$$fce482c0.invoke(<span class="tag">&lt;<span class="name">generated</span>&gt;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终发现问题并不是调用远程接口错误，而是里面报错问题导致的。</p>
</li>
</ol>
<p>Arthas功能很强大，能做的还很多，比如修改代码行热部署，线上debug排错等。要多看看官方文档。</p>
<h3 id="3、报错List："><a href="#3、报错List：" class="headerlink" title="3、报错List："></a>3、报错List：</h3><ol>
<li>没有Java项目运行，arthas启动不起来</li>
</ol>
<p><img src="/images/arthas%E7%BA%BF%E4%B8%8A%E6%8E%92%E9%94%99/1572526969248.png" alt="1572526969248"></p>
<ol start="2">
<li>在cmd运行时会有显示问题导致数据输入问题，且没有tab提示，可以在浏览器直接输入：localhost:8563，命令行运行</li>
<li>在arthas使用 结束后，不能直接关闭cmd，用通过 shutdown关闭arthas后，再退出，否则下次运行时会报端口占用错误，需要手动关闭线程。</li>
</ol>
<p>更多详细用法参考：</p>
<p><a href="https://segmentfault.com/a/1190000020737353">[Java诊断利器Arthas优雅排查生产环境]</a></p>
<p><a href="https://alibaba.github.io/arthas/watch.html">官方文档参数说明</a></p>
<p><a href="https://yq.aliyun.com/articles/654698">使用Arthas抽丝剥茧排查线上应用日志打满问题</a></p>
]]></content>
      <categories>
        <category>线上排错</category>
      </categories>
      <tags>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie前后端传递过程</title>
    <url>/2019/11/08/cookie%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>文章的背景是</strong>：**<code>浏览器的Cookie未被禁用</code>.**</p>
<hr>
<p>我们知道，无论是 session 还是 cookie 都是在服务端创建的，只是 cookie 不同于 session 被保存在客户端。</p>
<span id="more"></span>

<p><strong>工作流程如下：</strong></p>
<p> <img src="/images/cookie%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B/20180518141618590.png" alt="这里写图片描述"> </p>
<ul>
<li>客户端第一次请求服务器，cookie 中不存在与 url 相对应的 sessionid。所以 request headers 的 cookie 头里不包含 sessionid 的内容，甚至不包含 cookie 请求头；</li>
<li>服务端调用 request.getSession (); , 没有 sessionid 自然无法取得相应的 session 信息，立即创建新的 session；</li>
<li>新创建的 session 信息被服务端存储下来，sessionid 被添加到 response 的 set-cookie 响应头，并返回给客户端；</li>
<li>客户端接收到 response 报文的 cookie 内容，并将其保存在本地；</li>
<li>客户端再一次请求服务器，浏览器将根据 url，解析出相应的 sessionid，并添加到 cookie 请求头，发送给服务器；</li>
<li>服务端调用 request.getSession (); , 根据 sessionid 从 session 存储里获得相应的 session 信息，然后进一步操作，再响应给客户端。</li>
</ul>
<p> <strong>事实上 cookie 没那么神秘，它被抽象为一个实体类，包含着一系列属性和方法，如下：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Cookie(String name,String value) <span class="comment">//创建cookie</span></span><br><span class="line">response.addCookie(Cookie cookie) <span class="comment">//向response中添加cookie，可以多次调用以添加多个cookie</span></span><br><span class="line">　　getName() <span class="comment">//获得cookie的name</span></span><br><span class="line">　　getValue() <span class="comment">//获得cookie的value</span></span><br><span class="line">　　setValue(String newValue)  <span class="comment">//用于修改name对应的value值。</span></span><br><span class="line">　　setMaxAge(<span class="keyword">int</span> expiry) <span class="comment">//设置有效时间,单位s，缺省-1，即关闭浏览器cookie失效</span></span><br><span class="line">　　setPath(String uri)  <span class="comment">//设置路径　　</span></span><br><span class="line">　　setDomain(String pattern) <span class="comment">//设置域名，（一般浏览器会自动设置，服务端的操作无效）                   </span></span><br><span class="line">　　setDomain(<span class="string">&quot;.zyh.com&quot;</span>) <span class="comment">//如果这样设置，www.zyh.com / bbs.zyh.com 都可以访问，a.b.zyh.com无法访问</span></span><br><span class="line">isHttpOnly() <span class="comment">//是否只能在服务端操作cookie，而客户端javascript不能。不是cookie规范，而是浏览器支持</span></span><br><span class="line">　　setComment(String purpose) <span class="comment">//cookie的描述信息</span></span><br><span class="line">　　setSecure(<span class="keyword">boolean</span> flag) <span class="comment">//是否使用安全传输协议。为true时，只有用https请求时cookie才会被发</span></span><br><span class="line">　　<span class="comment">//送给服务器端，而http时不会。但是客户端还是可以接收来自服务端的cookie。缺省 false</span></span><br><span class="line">　　setVersion(<span class="keyword">int</span> v) <span class="comment">//编译规范，默认0</span></span><br></pre></td></tr></table></figure>

<p>对于客户端而言，cookie仅仅是一个对象实例，包含着 key，value，domain，path 等一系列 附加信息，序列化后被保存在客户端。而客户端可能同时保存着成百上千个这样的对象实例，确切的说是更像是cookie集合，类似于：List<Cookie>。</p>
<p>那么浏览器到底如何保证从 cookie 中解析并发送对应的 sessionId 到目标 Url 呢？</p>
<ul>
<li> 要理解浏览器如何<strong>解析</strong>出 sessionid，首先要知道<strong>包含 sessionid 的 cookie</strong> 是如何被 <strong>创建</strong>的： </li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie sessionCookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;sessionid&quot;</span>,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">sessionCookie.setPath(<span class="string">&quot;/path&quot;</span>); <span class="comment">//可以在服务端设置</span></span><br><span class="line">sessionCookie.setDomain(<span class="string">&quot;www.test.com&quot;</span>); <span class="comment">//一般情况下domain被浏览器重新设置，服务端的设置无效</span></span><br><span class="line">response.addCookie(sessionCookie);</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>List</strong> 被 <strong>序列化存储</strong>在客户端，我们可以将它理解成一个<strong>数据表</strong>，表结构如下： </li>
</ul>
<table>
<thead>
<tr>
<th>name</th>
<th>value</th>
<th>domain</th>
<th>path</th>
<th>other_info</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li> 浏览器通过 URL 来访问服务端，URL 可能是下面三种样式。在此之前要知道，无论是**<code>域名</code><strong>，</strong><code>域名+端口</code><strong>还是</strong><code>ip地址+端口</code>**，对于 <strong>Http * 协议</strong>来说都是 <strong>Domain</strong>。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">www.test.com/path/.. # 域名+路径</span><br><span class="line">www.test.com:<span class="number">8080</span>/path/.. # 域名+端口+路径，当然这种写法不常见，太丑了。</span><br><span class="line">                          #通常在服务端域名配置的时候应该已经做好了指定端口的绑定</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>/path/.. # ip地址+端口+路径，当然这种写法也只会在开发环境下存在</span><br></pre></td></tr></table></figure>

<ul>
<li> 为了方便理解，按照我们假设的存储方式，三种 Url 对应的 cookie 被存储在 <strong>cookies 数据表</strong>中 :</li>
</ul>
<p>  name    value    domain    path    other_info<br>  非 sessionid    非 sessionvalue    <a href="http://www.test.com:8080/">www.test.com:8080</a>    path    其他信息<br>  非 sessionid    非 sessionvalue    127.0.0.1:8080    path    其他信息<br>  非 sessionid    非 sessionvalue    <a href="http://www.test.com/">www.test.com</a>    path    其他信息<br>  sessionid    1234    <a href="http://www.test.com/">www.test.com</a>    path    其他信息</p>
<ul>
<li> 同理，浏览器从 cookie 中解析出目标 URL 对应 sessionid 的过程，我们可以简单理解为对数据表的查询。假设，我们访问 url：**<code>http://www.test.com/path/../..</code>**， select 语句如下： </li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select name , value </span><br><span class="line">from cookies </span><br><span class="line">where domain=<span class="string">&#x27;www.test.com&#x27;</span> and path=<span class="string">&#x27;path&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li> 查询结果如下： </li>
</ul>
<p>  name    value    domain    path    other_info<br>  非 sessionid    非 sessionvalue    <a href="http://www.test.com/">www.test.com</a>    path    其他信息<br>  sessionid    1234    <a href="http://www.test.com/">www.test.com</a>    path    其他信息</p>
<ul>
<li> 只有 <code>name = &#39;sessionid&#39;</code> 的那条 cookie 才是我们想要的 <strong>存储 sessionid 的 cookie</strong>，这步筛选过程，当然 <strong>只会在服务端发生</strong>。此时 <strong>request</strong> 的 <strong>请求头</strong>内容如下： </li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request Headers</span><br><span class="line">Cookie：sessionid=<span class="number">1234</span>; 非sessionid=非sessionid</span><br></pre></td></tr></table></figure>

<p> <strong>注意</strong> </p>
<ul>
<li> 上述例子中，cookie 中包含<strong>中文信息</strong>，实际使用，中文信息需要<strong>编码 / 解码</strong>。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送cookie</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(URLEncoder.encode(<span class="string">&quot;非sessionid&quot;</span>)</span><br><span class="line">                          ,URLEncoder.encode(<span class="string">&quot;非sessionvalue&quot;</span>));</span><br><span class="line">cookie.setComment(URLEncoder.encode(<span class="string">&quot;其他信息&quot;</span>));</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得cookie中文内容</span></span><br><span class="line">URLDecoder.decoder(request.getCookie().getName);<span class="comment">//获取name</span></span><br><span class="line">URLDecoder.decoder(request.getCookie().getValue);<span class="comment">//获取value</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p> <strong>Cookie</strong> 的 <strong><code>Domain</code><strong>与</strong><code>Path</code><strong>属性，是根据 <strong>url</strong> 解析出对应 cookie 的</strong><code>充分必要条件</code></strong> </p>
</li>
<li><p>setDomain(String urlPattern); // 尽管服务端开放了操作 Domain 属性的方法，但是一般情况下，浏览器会自动重写该属性，所以服务端的设置通常是无效的。</p>
</li>
<li><p>setPath(String path); // 服务端可以对 Path 进行设置，不会被浏览器复写，通常有效。</p>
<ul>
<li> <strong>手动设置</strong> </li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie sessionCookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;sessionid&quot;</span>,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">sessionCookie.setPath(<span class="string">&quot;/path&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  <img src="/images/cookie%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B/1573195042420.png" alt="1573195042420"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>登录</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>count*和count1区别</title>
    <url>/2019/11/05/count-%E5%92%8Ccount1%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><span id="more"></span>

<p><img src="/images/count-%E5%92%8Ccount1%E5%8C%BA%E5%88%AB/1572941000489.png" alt="1572941000489"></p>
<p><img src="/images/count-%E5%92%8Ccount1%E5%8C%BA%E5%88%AB/1572941177778.png" alt="1572941177778"></p>
]]></content>
      <categories>
        <category>sql优化</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>equals与==的区别</title>
    <url>/2019/11/10/equals%E4%B8%8E==%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="Equals源码实现"><a href="#Equals源码实现" class="headerlink" title="Equals源码实现"></a>Equals源码实现</h3><p>Object 类的两个方法 hashCode 和 equals，我们先来看一下这两个方法的默认实现：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** JNI，调用底层其它语言实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 默认同==，直接比较对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-Equals"><a href="#String-Equals" class="headerlink" title="String Equals"></a>String Equals</h3><p> equals 方法我们太熟悉了，我们经常用于字符串比较，String 类中重写了 equals 方法，比较的是字符串值，看一下源码实现： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		String anotherString = (String) anObject;</span><br><span class="line">		<span class="keyword">int</span> n = value.length;</span><br><span class="line">		<span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">			<span class="keyword">char</span> v1[] = value;</span><br><span class="line">			<span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 逐个判断字符是否相等</span></span><br><span class="line">			<span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  重写 equals 要满足几个条件： （特性）</p>
<ul>
<li>自反性：对于任何非空引用值 x，x.equals (x) 都应返回 true。 </li>
<li>对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals (x) 返回 true 时，x.equals (y) 才应返回 true。 </li>
<li>传递性：对于任何非空引用值 x、y 和 z，如果 x.equals (y) 返回 true，并且 y.equals (z) 返回 true，那么 x.equals (z) 应返回 true。 </li>
<li>一致性：对于任何非空引用值 x 和 y，多次调用 x.equals (y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </li>
<li>对于任何非空引用值 x，x.equals (null) 都应返回 false。 </li>
</ul>
<h3 id="Object-Equals"><a href="#Object-Equals" class="headerlink" title="Object  Equals"></a>Object  Equals</h3><p>Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<p><strong>对象必须为相同引用，相同hash码，且值相同时，才返回true。</strong></p>
<blockquote>
<p> 有对象 A 和 B， A.equals (B) == true, A 和 B 的 hashCode 可以不同 </p>
</blockquote>
<p> 答案是否定的。如果 A 和 B equals 的话，那么他们的哈希值一定要相同。 </p>
<h3 id="hashCode-的计算"><a href="#hashCode-的计算" class="headerlink" title="hashCode 的计算"></a><strong>hashCode 的计算</strong></h3><p>举个例子，在没有 hashCode 的情况下，在 Set 集合中存储 1000 个对象的话需要用 equals 来比较对象的值是否重复， 我们知道 Set 是不允许重复对象存在的， 那么当这一千个对象都不重复的情况下， 第 1000 个对象的存储需要调用 1000 次 equals 去进行比较，这是非常低效的。</p>
<p>而 hashCode 能解决这种问题，对象的存储不再是顺序存放，而是通过 hashCode 直接计算出存储的位置， (可以理解为内存地址，虽然并不是) 之后新对象在存储的时候如果 hashCode 跟之前的没有重复则直接存储，如果重复了则用 equals () 校验是否相等， 如果不相等的话，以 HashMap 作为例子，默认是在同一个地址上用链表存储起来新的对象， 这在之前介绍哈希冲突的解决办法那篇文章里提到过。</p>
<ul>
<li><p>如果两个对象 equals，那么他们的 hashCode 一定要相同 (否则在 Set 中就会出现重复元素) </p>
</li>
<li><p>如果两个对象 hashCode 相同，他们可以不 equals </p>
</li>
</ul>
<p>1、如果两个对象 equals，Java 运行时环境会认为他们的 hashcode 一定相等。<br>2、如果两个对象不 equals，他们的 hashcode 有可能相等。<br>3、如果两个对象 hashcode 相等，他们不一定 equals。<br>4、如果两个对象 hashcode 不相等，他们一定不 equals。  </p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><img src="/images/equals%E4%B8%8E==%E7%9A%84%E5%8C%BA%E5%88%AB/1573366715445.png" alt="1573366715445"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Enp&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Enp enp1 = <span class="keyword">new</span> Enp();</span><br><span class="line">Enp enp2 = <span class="keyword">new</span> Enp();</span><br><span class="line">System.out.println(enp1.equals(enp2));</span><br><span class="line">map.add(enp1);</span><br><span class="line">map.add(enp2);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>map在测试时，如果对象为key，会校验hashCode和equals是否一直，但是如果为value，不会校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Enp,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Enp enp1 = <span class="keyword">new</span> Enp();</span><br><span class="line">Enp enp2 = <span class="keyword">new</span> Enp();</span><br><span class="line">System.out.println(enp1.equals(enp2));</span><br><span class="line">map.put(enp1,<span class="keyword">new</span> Object());</span><br><span class="line">map.put(enp2,<span class="keyword">new</span> Object());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p><img src="/images/equals%E4%B8%8E==%E7%9A%84%E5%8C%BA%E5%88%AB/1573366906111.png" alt="1573366906111"></p>
<p>  Java 运行时环境是怎样判断 HashSet 和 HastMap 中的两个对象相同或不同了。我的推断是：先判断 hashcode 是否相等，再判断是否 equals。  </p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>在 Java 中任何一个对象都具备 equals (Object obj) 和 hashcode () 这两个方法，因为他们是在 Object 类中定义的。 </li>
<li>equals (Object obj) 方法用来判断两个对象是否 “相同”，如果 “相同” 则返回 true，否则返回 false。 </li>
<li>hashcode () 方法返回一个 int 数，在 Object 类中的默认实现是 “将该对象的内部地址转换成一个整数返回”。</li>
<li> 规范 1：若重写 equals (Object obj) 方法，有必要重写 hashcode () 方法，确保通过 equals (Object obj) 方法判断结果为 true 的两个对象具备相等的 hashcode () 返回值。说得简单点就是：“如果两个对象相同，那么他们的 hashcode 应该 相等”。不过请注意：这个只是规范，如果你非要写一个类让 equals (Object obj) 返回 true 而 hashcode () 返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了 Java 规范，程序也就埋下了 BUG。 </li>
<li>规范 2：如果 equals (Object obj) 返回 false，即两个对象 “不相同”，并不要求对这两个对象调用 hashcode () 方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的 hashcode 可能相同”。  </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title>gateway网关总结</title>
    <url>/2019/11/15/gateway%E7%BD%91%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><p>功能设计及开发流程：</p>
<ul>
<li><p>添加表：</p>
<p>应用信息表：（参考system表，添加系统给生成的key，应用管理企业名称）</p>
<span id="more"></span>

<p>系统接口信息表：（系统编码，接口名/xxx，系统地址）</p>
<p>应用系统接口对应表（应用名，接口id，接口名，系统名）</p>
</li>
<li><p>流程：</p>
<ol>
<li>会给不同的企业分配一个key，企业调用接口时把key、系统编码，时间戳，密钥放header传过来</li>
<li>由网关（spring cloud gateway）接收，拦截后从权限管理获取token，匹配加密对不对，之后再获取该应用能调用的所有接口，网关获取后保存到缓存中，方便下次调用，如果两步鉴定正确，再把接口分配到所属系统</li>
</ol>
</li>
<li><p>开发流程：</p>
<ol>
<li>建表</li>
<li>权限管理中添加应用管理，（查询条件：应用编码，应用名称，）功能：生成key，添加系统接口权限（要能够根据系统查询），</li>
<li>开发网关系统进行鉴权</li>
<li>系统间调用，需要加一个共用sdk，方便授权其他系统调用</li>
</ol>
</li>
<li><p>好处：</p>
<ol>
<li><p>接口级控制，能够对不同系统调用本企业系统接口的调用进行控制，方便进行授权管理；</p>
</li>
<li><p>统一第三方系统调用入口，由gateway获取后分发；</p>
</li>
<li><p>能够记录接口调用日志，记录不同企业系统间的调用，</p>
</li>
</ol>
</li>
</ul>
<h3 id="职责描述："><a href="#职责描述：" class="headerlink" title="职责描述："></a>职责描述：</h3><ul>
<li>开发系统权限管理功能，给系统赋接口权限；</li>
<li>开发spring cloud gateway，通过使用feign调用权限管理接口，获取应用权限，保存到redis中，降低接口调用时间；</li>
<li>开发SDK包，集成接口加密规则，方便第三方系统调用；</li>
<li>调整业务系统通过gateway调用权限管理系统接口，已应用到线上生产环境；</li>
</ul>
<h3 id="技术描述："><a href="#技术描述：" class="headerlink" title="技术描述："></a>技术描述：</h3><p>项目使用spring cloud gateway框架开发，集成spring cloud feign进行系统接口调用，前期有集成Eurake服务，进行第三方接口调用时的系统接口权限验证，通过jar包方式部署，目前已有三个业务系统调用，整体运行正常。</p>
<p><strong>接口加密规则：</strong></p>
<p><img src="/images/gateway%E7%BD%91%E5%85%B3%E6%80%BB%E7%BB%93/1573786564259.png" alt="1573786564259"></p>
<p><strong>（见页面附录）</strong></p>
<h3 id="系统页面："><a href="#系统页面：" class="headerlink" title="系统页面："></a>系统页面：</h3><p><img src="/images/gateway%E7%BD%91%E5%85%B3%E6%80%BB%E7%BB%93/1573786456671.png" alt="1573786456671"></p>
<p><img src="/images/gateway%E7%BD%91%E5%85%B3%E6%80%BB%E7%BB%93/1573786486443.png" alt="1573786486443"></p>
<p>附录：</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1   概述"></a>1   概述</h3><p>检查管理系统V4.0（以下简称证后监管系统）提供获取化妆品经营企业检查信息、药品零售企业检查信息、医疗机构信息等Open API接口，提供相关企业的检查信息供第三方系统使用。</p>
<h4 id="1-1-Open-API-说明"><a href="#1-1-Open-API-说明" class="headerlink" title="1.1 Open API 说明"></a>1.1 Open API 说明</h4><p>Open API 提供外部应用系统通过主动调用的方式进行访问，当你的应用调用开放平台接口时，需使用 HTTPS 协议、JSON 数据格式、UTF8 编码。</p>
<p>系统管理员可通过证后监管系统对需要对接的外部应用系统进行授权和发放相关密钥信息，通过密钥可以生成每次调用接口的签名sign,密钥不会在请求调用中传输，请妥善保存。</p>
<p> sign是用来验证相关系统访问证后监管系统合法性的凭证，当外部系统调用证后监管系统接口时，证后监管系统会根据提交的AppId校验访问的合法性以及所对应的权限并返回相应的结果。</p>
<h4 id="1-2-访问频次控制说明"><a href="#1-2-访问频次控制说明" class="headerlink" title="1.2 访问频次控制说明"></a>1.2 访问频次控制说明</h4><p>Open API 的访问频次不能超过 1000次/每分钟。</p>
<h3 id="2-请求说明"><a href="#2-请求说明" class="headerlink" title="2   请求说明"></a>2   请求说明</h3><p>证后监管系统提供正式环境地址，需申请AppId和AppSecret，调用开放平台的任何接口都需要携带sign和AppId。请求响应格式目前仅支持json。所有请求需签名，签名算法目前仅支持MD5，具体签名规则在2.4中描述。</p>
<h4 id="2-1-接口地址"><a href="#2-1-接口地址" class="headerlink" title="2.1 接口地址"></a>2.1 接口地址</h4><p>正式环境：XXX </p>
<h4 id="2-2-公共请求头（Header）"><a href="#2-2-公共请求头（Header）" class="headerlink" title="2.2 公共请求头（Header）"></a>2.2 公共请求头（Header）</h4><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>类型</strong></th>
<th><strong>是否必填</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>appId</td>
<td>String</td>
<td>是</td>
<td>证后监管系统分配给开发者的应用ID</td>
</tr>
<tr>
<td>timestamp</td>
<td>String</td>
<td>是</td>
<td>时间戳，格式为yyyy-MM-dd  HH:mm:ss，时区为GMT+8，例如：2019-07-01  12:00:00。允许客户端请求最大时间误差为10分钟。</td>
</tr>
<tr>
<td>sign</td>
<td>String</td>
<td>是</td>
<td>API输入参数签名结果，签名算法参照下面的介绍</td>
</tr>
</tbody></table>
<h4 id="2-3-公共响应参数"><a href="#2-3-公共响应参数" class="headerlink" title="2.3 公共响应参数"></a>2.3 公共响应参数</h4><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>类型</strong></th>
<th><strong>是否必填</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>returnCode</td>
<td>String</td>
<td>是</td>
<td>“0”表示正常返回，“1”查看returnMessage信息，“-1”服务器异常</td>
</tr>
<tr>
<td>returnMessage</td>
<td>String</td>
<td>是</td>
<td>业务提示信息</td>
</tr>
<tr>
<td>returnDate</td>
<td>String</td>
<td>否</td>
<td>具体接口返回数据</td>
</tr>
</tbody></table>
<h4 id="2-4-签名算法"><a href="#2-4-签名算法" class="headerlink" title="2.4 签名算法"></a>2.4 签名算法</h4><p>为了防止API调用过程中被黑客恶意篡改，调用任何一个API都需要携带签名，证后监管会根据请求参数，对签名进行验证，签名不合法的请求将会被拒绝。目前仅支持MD5算法，签名大体过程如下：</p>
<p>·     对所有API请求参数（包括公共参数和业务参数，但除去sign参数），根据参数名称的<a href="http://www.asciima.com/">ASCII</a>码表的顺序排序。如：foo:1, bar:2, foo_bar:3, foobar:4排序后的顺序是bar:2, foo:1, foo_bar:3, foobar:4。</p>
<p>·     将排序好的参数名和参数值拼装在一起，根据上面的示例得到的结果为：bar2foo1foo_bar3foobar4。</p>
<p>·     把拼装好的字符串采用utf-8编码，使用签名算法对编码后的字节流进行摘要。如果使用MD5算法，则需要在拼装的字符串前后加上app的secret后，再进行摘要，如：md5(secret+bar2foo1foo_bar3foobar4+secret)。</p>
<p>·     将摘要得到的字节流结果使用十六进制表示，如：hex(“helloworld”.getBytes(“utf-8”)) = “68656C6C6F776F726C64”</p>
<h4 id="拦截器代码："><a href="#拦截器代码：" class="headerlink" title="拦截器代码："></a><strong>拦截器代码：</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.boornet.gateway.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.boor.sdk.util.ShfdaConfusionUtil;</span><br><span class="line"><span class="keyword">import</span> com.boornet.gateway.model.ApiHeaderResponse;</span><br><span class="line"><span class="keyword">import</span> com.boornet.gateway.model.ApiLog;</span><br><span class="line"><span class="keyword">import</span> com.boornet.gateway.service.QxglService;</span><br><span class="line"><span class="keyword">import</span> com.boornet.gateway.util.SignUtils;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.Minutes;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.UriComponentsBuilder;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 文天兆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 应用权限验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/28 17:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: shfda-server</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppAuthFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZE_APPID = <span class="string">&quot;appId&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZE_TIME_STAMP = <span class="string">&quot;timeStamp&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZE_APPSECRET = <span class="string">&quot;appSecret&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZE_SIGN = <span class="string">&quot;sign&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Setter</span></span><br><span class="line"><span class="comment">    @Value(&quot;#&#123;&#x27;$&#123;filter.ignore&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line"><span class="comment">    private List&lt;String&gt; ignoreLists = new ArrayList();*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QxglService qxglService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        URI uri = exchange.getRequest().getURI();</span><br><span class="line">        ApiLog apiLog = <span class="keyword">new</span> ApiLog();</span><br><span class="line">        apiLog.setUrlPath(uri.toString());</span><br><span class="line">        apiLog.setAppIp(uri.getHost());</span><br><span class="line">        apiLog.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (uri.toString().contains(<span class="string">&quot;qyglServer&quot;</span>)) &#123;</span><br><span class="line">            apiLog.setRemark(<span class="string">&quot;拦截未校验！&quot;</span>);</span><br><span class="line">            qxglService.saveApiLog(apiLog);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">//Header中参数不能为空</span></span><br><span class="line">        HttpHeaders headers = request.getHeaders();</span><br><span class="line">        String appId = headers.getFirst(AUTHORIZE_APPID);</span><br><span class="line">        String headSign = headers.getFirst(AUTHORIZE_SIGN);</span><br><span class="line">        String timaStamp = headers.getFirst(AUTHORIZE_TIME_STAMP);</span><br><span class="line">        ApiHeaderResponse headerResponse = ApiHeaderResponse.builder()</span><br><span class="line">                .appId(appId)</span><br><span class="line">                .timeStamp(timaStamp)</span><br><span class="line">                .sign(headSign)</span><br><span class="line">                .build();</span><br><span class="line">        String msg = headerResponse.checkFields();</span><br><span class="line">        apiLog.setSysCode(appId);</span><br><span class="line">        <span class="keyword">if</span> (org.apache.commons.lang3.StringUtils.isNotBlank(msg)) &#123;</span><br><span class="line">            apiLog.setRemark(<span class="string">&quot;Header中参数不能为空，校验失败！&quot;</span>);</span><br><span class="line">            qxglService.saveApiLog(apiLog);</span><br><span class="line">            response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(getResponseMsg(response, <span class="string">&quot;Header中参数不能为空！！&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//timeStamp时间校验，十分钟有效</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateTime dateTime = dateTimeFormatter.parseDateTime(timaStamp);</span><br><span class="line">            DateTime currentDateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line">            <span class="keyword">int</span> minutes = Minutes.minutesBetween(currentDateTime, dateTime).getMinutes();</span><br><span class="line">            <span class="keyword">if</span> (minutes &gt; <span class="number">10</span> || minutes &lt; -<span class="number">10</span>) &#123;</span><br><span class="line">                apiLog.setRemark(<span class="string">&quot;timeStamp超时，校验失败！&quot;</span>);</span><br><span class="line">                qxglService.saveApiLog(apiLog);</span><br><span class="line">                response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response.writeWith(Mono.just(getResponseMsg(response, <span class="string">&quot;timeStamp超时！！&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            apiLog.setRemark(<span class="string">&quot;timeStamp格式错误，校验失败！&quot;</span>);</span><br><span class="line">            qxglService.saveApiLog(apiLog);</span><br><span class="line">            response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(getResponseMsg(response, <span class="string">&quot;timeStamp格式错误！！&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        String sysSecret = qxglService.getappSecret(appId);</span><br><span class="line">        <span class="keyword">if</span> (sysSecret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            apiLog.setRemark(<span class="string">&quot;应用无权限，校验失败！&quot;</span>);</span><br><span class="line">            qxglService.saveApiLog(apiLog);</span><br><span class="line">            response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(getResponseMsg(response, <span class="string">&quot;应用无权限！！&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验签名，参数为空不校验</span></span><br><span class="line">        <span class="keyword">if</span> (!queryParams.isEmpty()) &#123;</span><br><span class="line">            Map&lt;String, String&gt; singleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            queryParams.toSingleValueMap().forEach((key, val) -&gt; singleMap.put(key, val));</span><br><span class="line">            singleMap.put(<span class="string">&quot;sign&quot;</span>, headSign);</span><br><span class="line">            <span class="keyword">if</span> (!SignUtils.checkSign(singleMap, appId, sysSecret)) &#123;</span><br><span class="line">                apiLog.setRemark(<span class="string">&quot;签名校验失败，校验失败！&quot;</span>);</span><br><span class="line">                qxglService.saveApiLog(apiLog);</span><br><span class="line">                response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response.writeWith(Mono.just(getResponseMsg(response, <span class="string">&quot;签名校验失败！！&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验接口权限</span></span><br><span class="line">        String path = uri.getPath();</span><br><span class="line">        <span class="keyword">if</span> (!qxglService.isHaveApi(appId, path)) &#123;</span><br><span class="line">            apiLog.setRemark(<span class="string">&quot;没有此接口权限，校验失败！&quot;</span>);</span><br><span class="line">            qxglService.saveApiLog(apiLog);</span><br><span class="line">            response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.writeWith(Mono.just(getResponseMsg(response, <span class="string">&quot;没有此接口权限，请向管理员申请！！&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        apiLog.setRemark(<span class="string">&quot;校验通过！&quot;</span>);</span><br><span class="line">        qxglService.saveApiLog(apiLog);</span><br><span class="line">        <span class="keyword">if</span> (uri.toString().contains(<span class="string">&quot;/zhjg/&quot;</span>) || uri.toString().contains(<span class="string">&quot;/zcbg/&quot;</span>) || uri.toString().contains(<span class="string">&quot;/zssb/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加权限管理系统权限验证参数</span></span><br><span class="line">        StringBuilder query = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String originalQuery = uri.getRawQuery();</span><br><span class="line">        <span class="keyword">if</span> (uri.toString().contains(<span class="string">&quot;/qxglServer/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(originalQuery)) &#123;</span><br><span class="line">                query.append(originalQuery);</span><br><span class="line">                <span class="keyword">if</span> (originalQuery.charAt(originalQuery.length() - <span class="number">1</span>) != <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">                    query.append(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            query.append(<span class="string">&quot;sysCode=&quot;</span> + appId + <span class="string">&quot;&amp;userToken=&quot;</span>).append(ShfdaConfusionUtil.getLoginStr(<span class="string">&quot;ADMIN_INNER&quot;</span>, <span class="string">&quot;ADMIN_INNER&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URI newUri = UriComponentsBuilder.fromUri(uri)</span><br><span class="line">                    .replaceQuery(query.toString())</span><br><span class="line">                    .build(<span class="keyword">true</span>)</span><br><span class="line">                    .toUri();</span><br><span class="line">            ServerHttpRequest request1 = exchange.getRequest().mutate()</span><br><span class="line">                    .uri(newUri)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange.mutate().request(request1).build());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid URI query: \&quot;&quot;</span> + query.toString() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataBuffer <span class="title">getResponseMsg</span><span class="params">(ServerHttpResponse response, String msg)</span> </span>&#123;</span><br><span class="line">        JSONObject message = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        message.put(<span class="string">&quot;returnCode&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        message.put(<span class="string">&quot;returnMsg&quot;</span>, msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bits = message.toJSONString().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">return</span> response.bufferFactory().wrap(bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判读是否在忽略列表中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*private boolean inIgnore() &#123;</span></span><br><span class="line"><span class="comment">        if (CollectionUtils.isEmpty(ignoreLists)) &#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //   if()</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目总结</category>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>gateway网关</tag>
        <tag>接口权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客参考</title>
    <url>/2019/10/30/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><span id="more"></span>

<p><a href="https://juejin.im/user/59c5b2eaf265da0659432394/posts">参考博客    </a></p>
<p> <img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572430725591.png" alt="1572430725591"></p>
<h3 id="3、DaoVoice安装"><a href="#3、DaoVoice安装" class="headerlink" title="3、DaoVoice安装"></a>3、DaoVoice安装</h3><p><a href="https://hoxis.github.io/hexo-next-daovoice.html">参考博客</a></p>
<p>效果：<img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572416007120.png" alt="1572416007120"></p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572416028635.png" alt="1572416028635"></p>
<p>微信提醒：</p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572418709601.png" alt="1572418709601"></p>
<p>效果：</p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572418727081.png" alt="1572418727081"></p>
<h3 id="4、阅读排行，底部版权"><a href="#4、阅读排行，底部版权" class="headerlink" title="4、阅读排行，底部版权"></a>4、阅读排行，底部版权</h3><p><a href="https://hoxis.github.io/tags/Hexo/">参考博客</a></p>
<h3 id="5、加快博客访问速度"><a href="#5、加快博客访问速度" class="headerlink" title="5、加快博客访问速度"></a>5、加快博客访问速度</h3><p><a href="https://hanhanhanxu.github.io/2019/05/15/coding/">使用国内仓库搭建同名博客</a></p>
<h3 id="6、修改头像及图标"><a href="#6、修改头像及图标" class="headerlink" title="6、修改头像及图标"></a>6、修改头像及图标</h3><p><a href="https://hanhanhanxu.coding.me/2019/05/14/%E7%BD%91%E7%AB%99%E7%BE%8E%E5%8C%96/">参考博客</a></p>
<p><a href="https://fontawesome.com/">图标网站</a></p>
<h3 id="7、添加宠物，美化，图片懒加载等"><a href="#7、添加宠物，美化，图片懒加载等" class="headerlink" title="7、添加宠物，美化，图片懒加载等"></a>7、添加宠物，美化，图片懒加载等</h3><p><a href="https://newdee.cf/posts/6ed4d3bc/">参考</a></p>
<h3 id="8、基础设置及SEO优化"><a href="#8、基础设置及SEO优化" class="headerlink" title="8、基础设置及SEO优化"></a>8、基础设置及SEO优化</h3><p><a href="https://michael728.github.io/2019/05/19/hexo-blog-full-note/">参考</a></p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572474380533.png" alt="1572474380533"></p>
<p> <a href="https://blog.rytinselver.com/Hexo/31602.html">https://blog.rytinselver.com/Hexo/31602.html</a> </p>
<ol>
<li><p>实测可用–<a href="https://yfzhou.coding.me/2018/08/29/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88SEO%E4%BC%98%E5%8C%96%EF%BC%89/">百度SEO优化</a>，<a href="https://yfzhou.coding.me/2018/08/29/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88SEO%E4%BC%98%E5%8C%96%EF%BC%89/">2</a></p>
</li>
<li><p>googleSEO–终于有一个成功了</p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572427605644.png" alt="1572427605644"></p>
</li>
</ol>
<h3 id="9、接入谷歌广告"><a href="#9、接入谷歌广告" class="headerlink" title="9、接入谷歌广告"></a>9、接入谷歌广告</h3><p><a href="https://yfzhou.coding.me/2018/08/29/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88SEO%E4%BC%98%E5%8C%96%EF%BC%89/">参考</a></p>
<h3 id="10、NexT官方文档中文版"><a href="#10、NexT官方文档中文版" class="headerlink" title="10、NexT官方文档中文版"></a>10、<a href="">NexT官方文档中文版</a></h3><h3 id="11、添加云日历，点击显示当天博客"><a href="#11、添加云日历，点击显示当天博客" class="headerlink" title="11、添加云日历，点击显示当天博客"></a>11、添加云日历，点击显示当天博客</h3><p><a href="https://www.bbsmax.com/A/RnJW3rVyJq/">参考</a></p>
<h3 id="12、Coding-net上建立镜像解决Github-Pages博客百度无法收录问题"><a href="#12、Coding-net上建立镜像解决Github-Pages博客百度无法收录问题" class="headerlink" title="12、Coding.net上建立镜像解决Github Pages博客百度无法收录问题"></a>12、<a href="https://www.atjiang.com/coding.net-pages-as-github-pages-mirror-for-baidu/">Coding.net上建立镜像解决Github Pages博客百度无法收录问题</a></h3><h3 id="13、coding-pages帮顶自定义域名-—还是官方文档写的最好"><a href="#13、coding-pages帮顶自定义域名-—还是官方文档写的最好" class="headerlink" title="13、coding pages帮顶自定义域名 —还是官方文档写的最好"></a>13、<a href="https://coding.net/help/doc/pages/domain.html">coding pages帮顶自定义域名</a> —还是官方文档写的最好</h3><p>最终在Coding部署后，百度抓取成功<img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572875407596.png" alt="1572875407596"></p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8F%82%E8%80%83/1572875455815.png" alt="1572875455815"></p>
<p>这里建议两个都加上，否则<a href="https://wentz.top/">https://wentz.top</a> 不能访问，但是有个问题，加与不加统计数量不一致，会丢失统计数量。</p>
<h3 id="修改页面显示文章数量"><a href="#修改页面显示文章数量" class="headerlink" title="修改页面显示文章数量"></a>修改页面显示文章数量</h3><p><a href="https://github.com/ahonn/hexo-theme-even/wiki/%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%95%B0%E9%87%8F">参考</a> （已修改）</p>
<h3 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h3><p><a href="https://www.jianshu.com/p/44e211829447">参考（已添加）</a></p>
<h3 id="修改文字链接"><a href="#修改文字链接" class="headerlink" title="修改文字链接"></a>修改文字链接</h3><ol>
<li>拼音</li>
<li>唯一ID</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客服务器错误</title>
    <url>/2019/11/21/hexo%E5%8D%9A%E5%AE%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>今天访问我自己的博客时，突然遇到服务器故障，登录不进去的问题，着实把我着急了一把，比较最近是在面试阶段，我的博客地址还是在简历的最上边，几乎仅次与名字的位置，唉。</p>
<span id="more"></span>

<ol>
<li><p>之前我有把简历部署到github和coding上，在浏览器上访问两个网站提供的博客域名时，都登录不上，可能是在阿里云配置的域名解析的问题；</p>
</li>
<li><p>之后ping了一下网址，发现wenta.top的域名在国内是映射的coding的博客，但是IPping不通，但github上可以ping通，马上把coding博客的域名解析全部停掉，默认使用github博客；</p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF/1574296424276.png" alt="1574296424276"></p>
<p>几分钟后，恢复正常，之前做coding博客是为了在国内访问是提升速度，没想到突然遇到这个问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo故障</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的分类和标签有什么区别</title>
    <url>/2019/11/07/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>分类由于只能隶属于一个，所以往往带有武断和不恰当的色彩，它是一个 “is a” 的问题，</p>
<span id="more"></span>

<p>属于本质论的范畴，而对事物的 “本质” 的认定，严格来说，这事只有上帝才能做，换句话说，谁做都不合适。<br>标签则不同，它是一个 “has a“的问题，说某个东西有某种属性，要求就没那么严格了。</p>
<p>总结，就是树干和枝叶的区别。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>idea内存优化总结</title>
    <url>/2019/12/01/idea%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我是8g内存，很后悔买电脑时没有加几百块买个16g的，作为开发来说，用个8g的，真是有点难搞。</p>
<span id="more"></span>

<p>chrome加idea，把内存吃的死死的。</p>
<p><img src="/images/idea%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/1575176770744.png" alt="1575176770744"></p>
<p>调整后打开速度确实有所调整，具体开发时是否卡顿，还有待确认。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>idea内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>idea的git使用</title>
    <url>/2019/12/05/idea%E7%9A%84git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java代码性能优化总结</title>
    <url>/2019/11/07/java%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>前言:</p>
<p>代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？</p>
<span id="more"></span>

<p>这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无 BUG 上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。</p>
<p>代码优化的目标是：</p>
<p>1、减小代码的体积</p>
<p>2、提高代码运行的效率</p>
<p>代码优化细节:</p>
<p>1、尽量指定类、方法的 final 修饰符</p>
<p>带有 final 修饰符的类是不可派生的。在 Java 核心 API 中，有许多应用 final 的例子，例如 java.lang.String，整个类都是 final 的。为类指定 final 修饰符可以让类不可以被继承，为方法指定 final 修饰符可以让方法不可以被重写。如果指定了一个类为 final，则该类所有的方法都是 final 的。Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大，具体参见 Java 运行期优化。此举能够使性能平均提高 50%。</p>
<p>2、尽量重用对象</p>
<p>特别是 String 对象的使用，出现字符串连接时应该使用 StringBuilder/StringBuffer 代替。由于 Java 虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p>
<p>3、尽可能使用局部变量</p>
<p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<p>4、及时关闭流</p>
<p>Java 编程过程中，进行数据库连接、I/O 流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p>
<p>5、尽量减少对变量的重复计算</p>
<p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p>
<p>for (int i = 0; i &lt; list.size(); i++)</p>
<p>{…}</p>
<p>建议替换为：</p>
<p>for (int i = 0, int length = list.size(); i &lt; length; i++)</p>
<p>{…}</p>
<p>这样，在 list.size () 很大的时候，就减少了很多的消耗</p>
<p>6、尽量采用懒加载的策略，即在需要的时候才创建</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;aaa&quot;</span>;<span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">list.add(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">list.add(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、慎用异常</p>
<p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable 接口的构造函数调用名为 fillInStackTrace () 的本地同步方法，fillInStackTrace () 方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java 虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p>
<p>8、不要在循环中使用 try…catch…，应该把其放在最外层</p>
<p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了</p>
<p>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</p>
<p>比如 ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet 等等，以 StringBuilder 为例：</p>
<p>（1）StringBuilder ()　　　　　　// 默认分配 16 个字符的空间</p>
<p>（2）StringBuilder (int size)　　// 默认分配 size 个字符的空间</p>
<p>（3）StringBuilder (String str)　// 默认分配 16 个字符 + str.length () 个字符空间</p>
<p>可以通过类（这里指的不仅仅是上面的 StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如 StringBuilder 吧，length 表示当前的 StringBuilder 能保持的字符数量。因为当 StringBuilder 达到最大容量的时候，它会将自身容量增加到当前的 2 倍再加 2，无论何时只要 StringBuilder 达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中 —- 这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放 5000 个字符而不指定长度，最接近 5000 的 2 次幂是 4096，每次扩容加的 2 不管，那么：</p>
<p>（1）在 4096 的基础上，再申请 8194 个大小的字符数组，加起来相当于一次申请了 12290 个大小的字符数组，如果一开始能指定 5000 个大小的字符数组，就节省了一倍以上的空间</p>
<p>（2）把原来的 4096 个字符拷贝到新的的字符数组中去</p>
<p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像 HashMap 这种是以数组 + 链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个 table 上只连接一个对象的可能性几乎为 0。初始大小建议设置为 2 的 N 次幂，如果能估计到有 2000 个元素，设置成 new</p>
<p>HashMap (128)、new HashMap (256) 都可以。</p>
<p>10、当复制大量数据时，使用 System.arraycopy () 命令</p>
<p>11、乘法和除法使用移位操作</p>
<p>例如：</p>
<p>for (val = 0; val &lt; 100000; val += 5)</p>
<p>{</p>
<p>a = val * 8;</p>
<p>b = val / 2;</p>
<p>}</p>
<p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p>
<p>for (val = 0; val &lt; 100000; val += 5)</p>
<p>{</p>
<p>a = val &lt;&lt; 3;</p>
<p>b = val &gt;&gt; 1;</p>
<p>}</p>
<p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p>
<p>12、循环内不要不断创建对象引用</p>
<p>例如：</p>
<p>for (int i = 1; i &lt;= count; i++)</p>
<p>{</p>
<p>Object obj = new Object();</p>
<p>}</p>
<p>这种做法会导致内存中有 count 份 Object 对象引用存在，count 很大的话，就耗费内存了，建议为改为：</p>
<p>Object obj = null;for (int i = 0; i &lt;= count; i++) { obj = new Object(); }</p>
<p>这样的话，内存中只有一份 Object 对象引用，每次 new Object () 的时候，Object 对象引用指向不同的 Object 罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p>
<p>13、基于效率和类型检查的考虑，应该尽可能使用 array，无法确定数组大小时才使用 ArrayList</p>
<p>14、尽量使用 HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用 Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</p>
<p>15、不要将数组声明为 public static final</p>
<p>因为这毫无意义，这样只是定义了引用为 static final，数组的内容还是可以随意改变的，将数组声明为 public 更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p>
<p>16、尽量在合适的场合使用单例</p>
<p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p>
<p>（2）控制实例的产生，以达到节约资源的目的</p>
<p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p>
<p>17、尽量避免随意使用静态变量</p>
<p>要知道，当某个对象被定义为 static 的变量所引用，那么 gc 通常是不会回收这个对象所占有的堆内存的，如：</p>
<p>public class A</p>
<p>{</p>
<p>private static B b = new B();</p>
<p>}</p>
<p>此时静态变量 b 的生命周期与 A 类相同，如果 A 类不被卸载，那么引用 B 指向的 B 对象会常驻内存，直到程序终止</p>
<p>18、及时清除不再需要的会话</p>
<p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为 30 分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据 MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用 HttpSession 的 invalidate () 方法清除会话。</p>
<p>19、实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历</p>
<p>这是 JDK 推荐给用户的。JDK API 对于 RandomAccess 接口的解释是：实现 RandomAccess 接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现 RandomAccess 接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用 foreach 循环；反过来，如果是顺序访问的，则使用 Iterator 会效率更高。可以使用类似如下的代码作判断：</p>
<p>if (list instanceof RandomAccess)</p>
<p>{ for (int i = 0; i &lt; list.size(); i++){}</p>
<p>}else{</p>
<p>Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext()){iterator.next()}</p>
<p>}</p>
<p>foreach 循环的底层实现原理就是迭代器 Iterator，参见 Java 语法糖 1：可变长度参数以及 foreach 循环原理。所以后半句” 反过来，如果是顺序访问的，则使用 Iterator 会效率更高” 的意思就是顺序访问的那些类实例，使用 foreach 循环去遍历。</p>
<p>20、使用同步代码块替代同步方法</p>
<p>这点在多线程模块中的 synchronized 锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
<p>21、将常量声明为 static final，并以大写命名</p>
<p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p>
<p>22、不要创建一些不使用的对象，不要导入一些不使用的类</p>
<p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import</p>
<p>java.util is never used”，那么请删除这些无用的内容</p>
<p>23、程序运行过程中避免使用反射</p>
<p>关于，请参见反射。反射是 Java 提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 Method 的 invoke 方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存 —- 用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p>
<p>24、使用数据库连接池和线程池</p>
<p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p>
<p>25、使用带缓冲的输入输出流进行 IO 操作</p>
<p>带缓冲的输入输出流，即 BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升 IO 效率</p>
<p>26、顺序插入和随机访问比较多的场景使用 ArrayList，元素删除和中间插入比较多的场景使用 LinkedList</p>
<p>这个，理解 ArrayList 和 LinkedList 的原理就知道了</p>
<p>27、不要让 public 方法中有太多的形参</p>
<p>public 方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p>
<p>1、违反了面向对象的编程思想，Java 讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p>
<p>2、参数太多势必导致方法调用的出错概率增加</p>
<p>至于这个” 太多” 指的是多少个，3、4 个吧。比如我们用 JDBC 写一个 insertStudentInfo 方法，有 10 个学生信息字段要插如 Student 表中，可以把这 10 个参数封装在一个实体类中，作为 insert 方法的形参</p>
<p>28、字符串变量和字符串常量 equals 的时候将字符串常量写在前面</p>
<p>这是一个比较常见的小技巧了，如果有以下代码：</p>
<p>String str = “123”;</p>
<p>if (str.equals(“123”)) {</p>
<p>…</p>
<p>}</p>
<p>建议修改为：</p>
<p>String str = “123”;</p>
<p>if (“123”.equals(str))</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>这么做主要是可以避免空指针异常</p>
<p>29、请知道，在 java 中 if (i == 1) 和 if (1 == i) 是没有区别的，但从阅读习惯上讲，建议使用前者</p>
<p>平时有人问，”if (i == 1)” 和”if (1== i)” 有没有区别，这就要从 C/C++ 讲起。</p>
<p>在 C/C++ 中，”if (i == 1)” 判断条件成立，是以 0 与非 0 为基准的，0 表示 false，非 0 表示 true，如果有这么一段代码：</p>
<p>int i = 2;</p>
<p>if (i == 1)</p>
<p>{</p>
<p>…</p>
<p>}else{</p>
<p>…</p>
<p>}</p>
<p>C/C++ 判断”i==1″不成立，所以以 0 表示，即 false。但是如果：</p>
<p>int i = 2;if (i = 1) { … }else{ … }</p>
<p>万一程序员一个不小心，把”if (i == 1)” 写成”if (i =</p>
<p>1)”，这样就有问题了。在 if 之内将 i 赋值为 1，if 判断里面的内容非 0，返回的就是 true 了，但是明明 i 为 2，比较的值是 1，应该返回的 false。这种情况在 C/C++ 的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在 if 语句中不正确的赋值操作，建议将 if 语句写为：</p>
<p>int i = 2;if (1 == i) { … }else{ … }</p>
<p>这样，即使开发者不小心写成了”1 =</p>
<p>i”，C/C++ 编译器也可以第一时间检查出来，因为我们可以对一个变量赋值 i 为 1，但是不能对一个常量赋值 1 为 i。</p>
<p>但是，在 Java 中，C/C++ 这种”if (i = 1)” 的语法是不可能出现的，因为一旦写了这种语法，Java 就会编译报错”Type</p>
<p>mismatch: cannot convert from int to boolean”。但是，尽管 Java 的”if (i == 1)” 和”if (1 ==</p>
<p>i)” 在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p>
<p>30、不要对数组使用 toString () 方法</p>
<p>看一下对数组使用 toString () 打印出来的是什么：</p>
<p>public static void main(String[] args)</p>
<p>{ int[] is = new int[]{1, 2, 3};</p>
<p>System.out.println(is.toString());</p>
<p>}</p>
<p>结果是：</p>
<p>[I@18a992f</p>
<p>本意是想打印出数组内容，却有可能因为数组引用 is 为空而导致空指针异常。不过虽然对数组 toString () 没有意义，但是对集合 toString () 是可以打印出集合里面的内容的，因为集合的父类 AbstractCollections<E > 重写了 Object 的 toString () 方法。</p>
<p>31、不要对超出范围的基本数据类型做向下强制转型</p>
<p>这绝不会得到想要的结果：</p>
<p>public static void main(String[] args)</p>
<p>{</p>
<p>long l = 12345678901234L;</p>
<p>int i = (int)l;</p>
<p>System.out.println(i);</p>
<p>}</p>
<p>我们可能期望得到其中的某几位，但是结果却是：</p>
<p>1942892530</p>
<p>解释一下。Java 中 long 是 8 个字节 64 位的，所以 12345678901234 在计算机中的表示应该是：</p>
<p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111</p>
<p>0010</p>
<p>一个 int 型数据是 4 个字节 32 位的，从低位取出上面这串二进制数据的前 32 位是：</p>
<p>0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>这串二进制表示为十进制 1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p>
<p>1、整型默认的数据类型是 int，long l =</p>
<p>12345678901234L，这个数字已经超出了 int 的范围了，所以最后有一个 L，表示这是一个 long 型数。顺便，浮点型的默认类型是 double，所以定义 float 的时候要写成””float f=3.5f”</p>
<p>2、接下来再写一句”int ii = l + i;” 会报错，因为 long + int 是一个 long，不能赋值给 int</p>
<p>32、公用的集合类中不使用的数据一定要及时 remove 掉</p>
<p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去 remove 掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p>
<p>33、把一个基本数据类型转为字符串，基本数据类型.toString () 是最快的方式、String.valueOf (数据) 次之、数据 +”” 最慢</p>
<p>把一个基本数据类型转为一般有三种方式，我有一个 Integer 型数据 i，可以使用 i.toString ()、String.valueOf (i)、i+”” 三种方式，三种方式的效率如何，看一个测试：</p>
<p>public static void main(String[] args)</p>
<p>{</p>
<p>int loopTime = 50000;</p>
<p>Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)</p>
<p>{</p>
<p>String str = String.valueOf(i);</p>
<p>}</p>
<p>System.out.println(“String.valueOf()：” + (System.currentTimeMillis() - startTime) + “ms”);</p>
<p>startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)</p>
<p>{</p>
<p>String str = i.toString();</p>
<p>}</p>
<p>System.out.println(“Integer.toString()：” + (System.currentTimeMillis() - startTime) + “ms”);</p>
<p>startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)</p>
<p>{</p>
<p>String str = i + “”;</p>
<p>}</p>
<p>System.out.println(“i + &quot;&quot;：” + (System.currentTimeMillis() - startTime) + “ms”);</p>
<p>}</p>
<p>运行结果为：</p>
<p>String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms</p>
<p>所以以后遇到把一个基本数据类型转为 String 的时候，优先考虑使用 toString () 方法。至于为什么，很简单：</p>
<p>1、String.valueOf () 方法底层调用了 Integer.toString () 方法，但是会在调用前做空判断</p>
<p>2、Integer.toString () 方法就不说了，直接调用了</p>
<p>3、i + “” 底层使用了 StringBuilder 实现，先用 append 方法拼接，再用 toString () 方法获取字符串</p>
<p>三者对比下来，明显是 2 最快、1 次之、3 最慢</p>
<p>34、使用最有效率的方式去遍历 Map</p>
<p>遍历 Map 的方式有很多，通常场景下我们需要的是遍历 Map 中的 Key 和 Value，那么推荐使用的、效率最高的方式是：</p>
<p>public static void main(String[] args)</p>
<p>{</p>
<p>HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();</p>
<p>hm.put(“111”, “222”);</p>
<p>Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</p>
<p>Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext())</p>
<p>{</p>
<p>Map.Entry&lt;String, String&gt; entry = iter.next();</p>
<p>System.out.println(entry.getKey() + “\t” + entry.getValue());</p>
<p>}</p>
<p>}</p>
<p>如果你只是想遍历一下这个 Map 的 key 值，那用”Set<String> keySet = hm.keySet ();” 会比较合适一些</p>
<p>35、对资源的 close () 建议分开操作</p>
<p>意思是，比如我有这么一段代码：</p>
<p>try{</p>
<p>XXX.close();</p>
<p>YYY.close();</p>
<p>}catch (Exception e)</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>建议修改为：</p>
<p>try{ XXX.close(); }catch (Exception e) { … }try{ YYY.close(); }catch (Exception e) { … }</p>
<p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一 XXX.close () 抛异常了，那么就进入了 cath 块中了，YYY.close () 不会执行，YYY 这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何 XXX 和 YYY 都会被 close 掉。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title>java序列化</title>
    <url>/2019/11/09/java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf">序列化各种使用场景</a></p>
<span id="more"></span>

<p><img src="/images/java%E5%BA%8F%E5%88%97%E5%8C%96/1573311400202.png" alt="1573311400202"></p>
<p><a href="https://www.cnblogs.com/wxgblogs/p/5849951.html">序列化问题案例分析</a></p>
<p><img src="/images/java%E5%BA%8F%E5%88%97%E5%8C%96/1573311428896.png" alt="1573311428896"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>maven知识整理</title>
    <url>/2019/11/12/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>1</p>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议整理</title>
    <url>/2019/11/12/http%E5%8D%8F%E8%AE%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>http 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的一种规定或规则，超文本传输协议 (HTTP) 是一种通信协议，它允许将超文本标记语言 (HTML) 文档从 Web 服务器传送到客户端的浏览器。</p>
<span id="more"></span>

<p>HTTP 协议，即超文本传输协议 (Hypertext transfer protocol)。是一种详细规定了浏览器和万维网 (WWW = World Wide Web) 服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<p>HTTP 协议是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示 (如文本先于图形，通过文档结构) 等。</p>
<p>HTTP 是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP 是一个无状态的协议。</p>
<p>在 Internet 中所有的传输都是通过 TCP/IP 进行的。HTTP 协议作为 TCP/IP 模型中应用层的协议也不例外。HTTP 协议通常承载于 TCP 协议之上，有时也承载于 TLS 或 SSL 协议层之上，这个时候，就成了我们常说的 HTTPS。 如下图所示：</p>
<p><img src="/images/http%E5%8D%8F%E8%AE%AE%E6%95%B4%E7%90%86/1573540369293.png" alt="1573540369293"></p>
<p>HTTP 默认的端口号为 80，HTTPS 的端口号为 443。</p>
<p>浏览网页是 HTTP 的主要应用，但是这并不代表 HTTP 就只能应用于网页的浏览。HTTP 是一种协议，只要通信的双方都遵守这个协议，HTTP 就能有用武之地。 比如咱们常用的 QQ，迅雷这些软件，都会使用 HTTP 协议 (还包括其他的协议)。</p>
<h3 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h3><p>HTTP 协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用 HTTP 协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。(在 html5 种可以通过 websocket 来实现)</p>
<p>HTTP 协议的主要特点可概括如下：</p>
<p>1、支持客户 / 服务器模式。支持基本认证和安全认证。</p>
<p>2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</p>
<p>3、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</p>
<p>4、HTTP 0.9 和 1.0 使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。 HTTP 1.1 使用持续连接：不必为每个 web 对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</p>
<p>5、无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p>
<p>无状态协议：</p>
<p>协议的状态是指下一次传输可以 “记住” 这次传输信息的能力。</p>
<p>http 是不会为了下一次连接而维护这次连接所传输的信息，为了保证服务器内存。</p>
<p>比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。</p>
<p>由于 Web 服务器要面对很多浏览器的并发访问，为了提高 Web 服务器对并发访问的处理能力，在设计 HTTP 协议时规定 Web 服务器发送 HTTP 应答报文和文档时，不保存发出请求的 Web 浏览器进程的任何状态信息。 这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于 Web 服务器不保存发送请求的 Web 浏览器进程的任何信息， 因此 HTTP 协议属于无状态协议（Stateless Protocol）。</p>
<p>HTTP 协议是无状态的和 Connection: keep-alive 的区别：</p>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
<p>HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。</p>
<p>从 HTTP/1.1 起，默认都开启了 Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭， 如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>
<p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。</p>
<h3 id="三、工作流程"><a href="#三、工作流程" class="headerlink" title="三、工作流程"></a>三、工作流程</h3><p>一次 HTTP 操作称为一个事务，其工作过程可分为四步：</p>
<p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP 的工作开始。(其它类似)</p>
<p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可能的内容。</p>
<p>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>
<p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由 HTTP 自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<p>HTTP 是基于传输层的 TCP 协议，而 TCP 是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以 HTTP 在开始传输之前，首先需要建立 TCP 连接，而 TCP 连接的过程需要所谓的 “三次握手”。 下图所示 TCP 连接的三次握手。<img src="/images/http%E5%8D%8F%E8%AE%AE%E6%95%B4%E7%90%86/1573540392956.png" alt="1573540392956"></p>
<p>在 TCP 三次握手之后，建立了 TCP 连接，此时 HTTP 就可以进行传输了。一个重要的概念是面向连接，既 HTTP 在传输完成之间并不断开 TCP 连接。在 HTTP1.1 中 (通过 Connection 头设置) 这是默认行为。</p>
<p>加上 TCP 的三次握手，http 的工作流程如下：</p>
<p>1）：浏览器向服务器发出连接请求。此为 TCP 三次握手第一步，此时为 SYN，seq:X （x=0）；</p>
<p>2）：服务器回应了浏览器的请求，并要求确认，此时为：SYN，ACK，此时 seq：y（y 为 0），ACK：x+1（为 1）。此为三次握手的第二步；</p>
<p>3）：浏览器回应了服务器的确认，连接成功。为：ACK，此时 seq：x+1（为 1），ACK：y+1（为 1）。此为三次握手的第三步；</p>
<p>4）：浏览器发出一个页面 HTTP 请求；</p>
<p>5）：服务器确认；</p>
<p>6）：服务器发送数据；</p>
<p>7）：客户端浏览器确认；</p>
<p>8）：客户端发出一个图片 HTTP 请求；</p>
<p>9）：服务器发送状态响应码 200 OK。</p>
<h3 id="四、头域"><a href="#四、头域" class="headerlink" title="四、头域"></a>四、头域</h3><p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<p>4.1、请求信息：</p>
<p>发出的请求信息格式如下：</p>
<p>●请求行，例如 GET /images/logo.gif HTTP/1.1，表示从 /images 目录下请求 logo.gif 这个文件。</p>
<p>●（请求）头，例如 Accept-Language: en</p>
<p>●空行</p>
<p>●可选的消息体　请求行和标题必须以 <CR><LF > 作为结尾（也就是，回车然后换行）。空行内必须只有 &lt; CR&gt;<LF > 而无其他空格。 在 HTTP/1.1 协议中，所有的请求头，除 post 外，都是可选的。</p>
<p><img src="/images/http%E5%8D%8F%E8%AE%AE%E6%95%B4%E7%90%86/1573540411856.png" alt="1573540411856"></p>
<p>三个部分分别是：请求行、消息报头、请求正文。</p>
<p>4.2、请求方法</p>
<p>HTTP/1.1 协议中共定义了八种方法（有时也叫 “动作”）来表明 Request-URI 指定的资源的不同操作方式：</p>
<p>OPTIONS - 返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送 ‘*’ 的请求来测试服务器的功能性。</p>
<p>HEAD- 向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<p>GET - 向特定的资源发出请求。注意：GET 方法不应当被用于产生 “副作用” 的操作中，例如在 web app. 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</p>
<p>POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和 / 或已有资源的修改。</p>
<p>PUT - 向指定资源位置上传其最新内容。</p>
<p>DELETE - 请求服务器删除 Request-URI 所标识的资源。</p>
<p>TRACE- 回显服务器收到的请求，主要用于测试或诊断。</p>
<p>CONNECT - HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>PATCH - 用来将局部修改应用于某一资源，添加于规范 RFC5789。</p>
<p>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Method Not Allowed）； 当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码 501（Not Implemented）。</p>
<p>HTTP 服务器至少应该实现 GET 和 HEAD 方法，其他方法都是可选的。此外，除了上述方法，特定的 HTTP 服务器还能够扩展自定义的方法。</p>
<p>GET 和 POST 的区别：</p>
<p>1、GET 提交的数据会放在 URL 之后，以？分割 URL 和传输数据，参数之间以 &amp; 相连，如 EditPosts.aspx?name=test1&amp;id=123456. POST 方法是把提交的数据放在 HTTP 包的 Body 中。</p>
<p>2、GET 提交的数据大小有限制，最多只能有 1024 字节（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制 (理论上)。</p>
<p>3、GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值。</p>
<p>4、GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p>
<p>4.3、响应消息</p>
<p>客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误编码、服务器信息、实体元信息以及必要的实体内容。根据响应类别的类别， 服务器响应里可以含实体内容，但不是所有的响应都有实体内容。</p>
<p>响应头第一行也称为状态行，格式如下（下图中红线标出的那行）：</p>
<p>HTTP-Version 空格 Status-Code 空格 Reason-Phrase CRLF</p>
<p>HTTP- Version 表示 HTTP 版本，例如为 HTTP/1.1。Status- Code 是结果代码，用三个数字表示。Reason-Phrase 是个简单的文本描述，解释 Status-Code 的具体原因。 Status-Code 用于机器自动识别，Reason-Phrase 用于人工理解。Status-Code 的第一个数字代表响应类别，可能取 5 个不同的值。后两个数字没有分类作用。 Status-Code 的第一个数字代表响应的类别，后续两位描述在该类响应下发生的具体状况，具体请参见：HTTP 状态码 。</p>
<p>响应消息的结构：</p>
<p><img src="/images/http%E5%8D%8F%E8%AE%AE%E6%95%B4%E7%90%86/1573540430587.png" alt="1573540430587"></p>
<p>三个部分分别是：状态行、消息报头、响应正文。</p>
<p>无论你何时浏览一个网页，你的电脑都会通过一个使用 HTTP 协议的服务器来获取所请求的数据。在你请求的网页显示在浏览器之前，支配网页的网站服务器会返回一个包含有状态码的 HTTP 头文件。 这个状态码提供了有关所请求网页的相关条件信息。如果一切正常，一个标准网页会收到一条诸如 200 的状态码。当然我们的目的不是去研究 200 响应码，而是去探讨那些代表出现错误信息的服务器头文件响应码， 例如表示 “未找到指定网页” 的 404 码。</p>
<p>4.4、响应头域</p>
<p>服务器需要传递许多附加信息，这些信息不能全放在状态行里。因此，需要另行定义响应头域，用来描述这些附加信息。响应头域主要描述服务器的信息和 Request-URI 的信息。</p>
<p>4.5、HTTP 常见的请求头（在 HTTP/1.1 协议中，所有的请求头，除 Host 外，都是可选的）</p>
<p>If-Modified-Since：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回 304， 客户端就直接使用本地缓存文件。如果时间不一致，就会返回 200 和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</p>
<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p>
<p>If-None-Match：If-None-Match 和 ETag 一起工作，工作原理是在 HTTP Response 中添加 ETag 信息。</p>
<p>当用户再次请求该资源时，将在 HTTP Request 中加入 If-None-Match 信息 (ETag 的值)。 如果服务器验证资源的 ETag 没有改变（该资源没有更新），将返回一个 304 状态告诉客户端使用本地缓存文件。 否则将返回 200 状态和新的资源和 Etag.  使用这样的机制将提高网站的性能。例如: If-None-Match: “03f2b33c0bfcc1:0”。</p>
<p>Pragma：指定 “no-cache” 值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在 HTTP/1.1 版本中，它和 Cache-Control:no-cache 作用一模一样。 Pargma 只有一个用法， 例如： Pragma: no-cache</p>
<p>注意：在 HTTP/1.0 版本中，只实现了 Pragema:no-cache, 没有实现 Cache-Control</p>
<p>Cache-Control：指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求消息或响应消息中设置 Cache-Control 并不会修改另一个消息处理过程中的缓存处理过程）。 请求时的缓存指令包括 no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached， 响应消息中的指令包括 public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。</p>
<p>Cache-Control:Public 可以被任何缓存所缓存</p>
<p>Cache-Control:Private 内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache 所有内容都不会被缓存</p>
<p>Cache-Control:no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</p>
<p>Cache-Control:max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</p>
<p>Cache-Control:min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</p>
<p>Cache-Control:max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定 max-stale 消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>
<p>Accept：浏览器端可以接受的 MIME 类型。例如：Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的 html 文档， 如果服务器无法返回 text/html 类型的数据，服务器应该返回一个 406 错误 (non acceptable)。通配符 * 代表任意类型，例如 Accept: <em>/</em> 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。</p>
<p>Accept-Encoding：浏览器申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）; Servlet 能够向支持 gzip 的浏览器返回经 gzip 编码的 HTML 页面。许多情形下这可以减少 5 到 10 倍的下载时间。例如： Accept-Encoding: gzip, deflate。 如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。</p>
<p>Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如 big5，gb2312，gbk 等等； 例如：Accept-Language: en-us。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>
<p>Accept-Charset：浏览器可接受的字符集。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受。</p>
<p>User-Agent：告诉 HTTP 服务器，客户端使用的操作系统和浏览器的名称和版本。</p>
<p>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)。</p>
<p>Content-Type：例如：Content-Type: application/x-www-form-urlencoded。</p>
<p>Referer：包含一个 URL，用户从该 URL 代表的页面出发访问当前请求的页面。提供了 Request 的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里， 他的服务器就能够从 HTTP Referer 中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>
<p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
<p>Connection：</p>
<p>例如：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 HTTP 1.1 默认进行持久连接。利用持久连接的优点，当页面包含多个元素时（例如 Applet，图片），显著地减少下载所需要的时间。 要实现这一点，Servlet 需要在应答中发送一个 Content-Length 头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。</p>
<p>Connection: close 代表一个 Request 完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接会关闭，当客户端再次发送 Request，需要重新建立 TCP 连接。</p>
<p>Host：（发送请求时，该头域是必需的）主要用于指定被请求资源的 Internet 主机和端口号，它通常从 HTTP URL 中提取出来的。HTTP/1.1 请求必须包含主机头域，否则系统会以 400 状态码返回。</p>
<p>例如：我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E4%B8%AD%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%8C%85%E5%90%AB">http://www.guet.edu.cn/index.html，浏览器发送的请求消息中，就会包含</a> Host 请求头域：Host：<a href="http://www.guet.edu.cn,此处使用缺省端口号/">http://www.guet.edu.cn，此处使用缺省端口号</a> 80，若指定了端口号， 则变成：Host：指定端口号。</p>
<p>Cookie：最重要的请求头之一，将 cookie 的值发送给 HTTP 服务器。</p>
<p>Content-Length：表示请求消息正文的长度。例如：Content-Length: 38。</p>
<p>Authorization：授权信息，通常出现在对服务器发送的 WWW-Authenticate 头的应答中。主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为 401（未授权）， 可以发送一个包含 Authorization 请求报头域的请求，要求服务器对其进行验证。</p>
<p>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的 IE 浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和 CPU 类型。</p>
<p>From：请求发送者的 email 地址，由一些特殊的 Web 客户程序使用，浏览器不会用到它。</p>
<p>Range：可以请求实体的一个或者多个子范围。例如，</p>
<p>表示头 500 个字节：bytes=0-499</p>
<p>表示第二个 500 字节：bytes=500-999</p>
<p>表示最后 500 个字节：bytes=-500</p>
<p>表示 500 字节以后的范围：bytes=500-</p>
<p>第一个和最后一个字节：bytes=0-0,-1</p>
<p>同时指定几个范围：bytes=500-600,601-999</p>
<p>但是服务器可以忽略此请求头，如果无条件 GET 包含 Range 请求头，响应会以状态码 206（PartialContent）返回而不是以 200（OK）。</p>
<p>4.6、HTTP 常见的响应头</p>
<p>Allow：服务器支持哪些请求方法（如 GET、POST 等）。</p>
<p>Date：表示消息发送的时间，时间的描述格式由 rfc822 定义。例如，Date:Mon,31Dec200104:25:57GMT。Date 描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。 你可以用 setDateHeader 来设置这个头以避免转换时间格式的麻烦</p>
<p>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。HTTP1.1 的客户端和缓存会将非法的日期格式（包括 0）看作已经过期。 eg：为了让浏览器不要缓存页面，我们也可以将 Expires 实体报头域，设置为 0。</p>
<p>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p>
<p>P3P：用于跨域设置 Cookie, 这样可以解决 iframe 跨域访问 cookie 的问题</p>
<p>例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p>
<p>Set-Cookie：非常重要的 header, 用于把 cookie 发送到客户端浏览器，每一个写入 cookie 都会生成一个 Set-Cookie。</p>
<p>例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com</p>
<p>ETag：和 If-None-Match 配合使用。</p>
<p>Last-Modified：用于指示资源的最后修改日期和时间。Last-Modified 也可用 setDateHeader 方法来设置。</p>
<p>Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型和字符集。Servlet 默认为 text/plain，但通常需要显式地指定为 text/html。由于经常要设置 Content-Type， 因此 HttpServletResponse 提供了一个专用的方法 setContentType。可在 web.xml 文件中配置扩展名和 MIME 类型的对应关系。</p>
<p>例如：Content-Type: text/html;charset=utf-8</p>
<p>　　</p>
<p>Content-Type:text/html;charset=GB2312</p>
<p>　　</p>
<p>Content-Type: image/jpeg</p>
<p>媒体类型的格式为：大类 / 小类，比如 text/html。</p>
<p>IANA (The Internet Assigned Numbers Authority，互联网数字分配机构) 定义了 8 个大类的媒体类型，分别是:</p>
<p>application— (比如: application/vnd.ms-excel.)</p>
<p>audio (比如: audio/mpeg.)</p>
<p>image (比如: image/png.)</p>
<p>message (比如，:message/http.)</p>
<p>model (比如:model/vrml.)</p>
<p>multipart (比如:multipart/form-data.)</p>
<p>text (比如:text/html.)</p>
<p>video (比如:video/quicktime.)</p>
<p>Content-Range：用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。 一般格式：Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-length。</p>
<p>例如，传送头 500 个字节次字段的形式：Content-Range:bytes0-499/1234 如果一个 http 消息包含此节（例如，对范围请求的响 应或对一系列范围的重叠请求），Content-Range 表示传送的范围。</p>
<p>Content-Length：指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length 的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。 只有当浏览器使用持久 HTTP 连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小， 然后把该值放入 Content-Length 头，最后通过 byteArrayStream.writeTo (response.getOutputStream () 发送内容。</p>
<p>例如: Content-Length: 19847</p>
<p>Content-Encoding：WEB 服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解码之后才可以得到 Content-Type 头指定的内容类型。 利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间。Java 的 GZIPOutputStream 可以很方便地进行 gzip 压缩，但只有 Unix 上的 Netscape 和 Windows 上的 IE 4、IE 5 才支持它。 因此，Servlet 应该通过查看 Accept-Encoding 头（即 request.getHeader (“Accept-Encoding”)）检查浏览器是否支持 gzip，为支持 gzip 的浏览器返回经 gzip 压缩的 HTML 页面，为其他浏览器返回普通页面。</p>
<p>例如：Content-Encoding：gzip</p>
<p>Content-Language：WEB 服务器告诉浏览器自己响应的对象所用的自然语言。例如： Content-Language:da。没有设置该域则认为实体内容将提供给所有的语言阅读。</p>
<p>Server：指明 HTTP 服务器用来处理请求的软件信息。例如：Server: Microsoft-IIS/7.5、Server：Apache-Coyote/1.1。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。</p>
<p>X-AspNet-Version：如果网站是用 ASP.NET 开发的，这个 header 用来表示 ASP.NET 的版本。</p>
<p>例如: X-AspNet-Version: 4.0.30319</p>
<p>X-Powered-By：表示网站是用什么技术开发的。</p>
<p>例如： X-Powered-By: ASP.NET</p>
<p>Connection：</p>
<p>例如：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>
<p>Connection: close 代表一个 Request 完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接会关闭，当客户端再次发送 Request，需要重新建立 TCP 连接。</p>
<p>Location：用于重定向一个新的位置，包含新的 URL 地址。表示客户应当到哪里去提取文档。Location 通常不是直接设置的，而是通过 HttpServletResponse 的 sendRedirect 方法， 该方法同时设置状态代码为 302。Location 响应报头域常用在更换域名的时候。</p>
<p>Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过 setHeader (“Refresh”, “5; URL=<a href="http://host/path&quot;">http://host/path&quot;</a>) 让浏览器读取指定的页面。 注意这种功能通常是通过设置 HTML 页面 HEAD 区的 &lt; META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;&gt;">http://host/path&quot;&gt;</a> 实现， 这是因为，自动刷新或重定向对于那些不能使用 CGI 或 Servlet 的 HTML 编写者十分重要。但是，对于 Servlet 来说，直接设置 Refresh 头更加方便。 注意 Refresh 的意义是 “N 秒之后刷新本页面或访问指定页面”，而不是 “每隔 N 秒刷新本页面或访问指定页面”。 因此，连续刷新要求每次都发送一个 Refresh 头，而发送 204 状态代码则可以阻止浏览器继续刷新，不管是使用 Refresh 头还是 &lt; META HTTP-EQUIV=”Refresh” …&gt;。 注意 Refresh 头不属于 HTTP 1.1 正式规范的一部分，而是一个扩展，但 Netscape 和 IE 都支持它。</p>
<p>WWW-Authenticate：该响应报头域必须被包含在 401（未授权的）响应消息中，客户端收到 401 响应消息时候，并发送 Authorization 报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。</p>
<p>eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” // 可以看出服务器对请求资源采用的是基本验证机制。</p>
<h3 id="五、解决-HTTP-无状态的问题"><a href="#五、解决-HTTP-无状态的问题" class="headerlink" title="五、解决 HTTP 无状态的问题"></a>五、解决 HTTP 无状态的问题</h3><p>5.1、通过 Cookies 保存状态信息</p>
<p>通过 Cookies，服务器就可以清楚的知道两个请求是否来自同一个客户端。</p>
<p>5.2、通过 Session 保存状态信息</p>
<p>Session 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 session 标识 - 称为 session id，如果已包含一个 session id 则说明以前已经为此客户端创建过 session， 服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含 session id， 则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id，session id 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id 将被在本次响应中返回给客户端保存。</p>
<p>Session 的实现方式：</p>
<p>1、使用 Cookie 来实现</p>
<p>服务器给每个 Session 分配一个唯一的 JSESSIONID，并通过 Cookie 发送给客户端。</p>
<p>当客户端发起新的请求的时候，将在 Cookie 头中携带这个 JSESSIONID。这样服务器能够找到这个客户端对应的 Session。</p>
<p>2、使用 URL 回写来实现</p>
<p>URL 回写是指服务器在发送给浏览器页面的所有链接中都携带 JSESSIONID 的参数，这样客户端点击任何一个链接都会把 JSESSIONID 带会服务器。如果直接在浏览器输入服务端资源的 url 来请求该资源，那么 Session 是匹配不到的。</p>
<p>Tomcat 对 Session 的实现，是一开始同时使用 Cookie 和 URL 回写机制，如果发现客户端支持 Cookie，就继续使用 Cookie，停止使用 URL 回写。如果发现 Cookie 被禁用，就一直使用 URL 回写。 jsp 开发处理到 Session 的时候，对页面中的链接记得使用 response.encodeURL () 。</p>
<p>Cookie 和 Session 有以下明显的不同点：</p>
<p>1）Cookie 将状态保存在客户端，Session 将状态保存在服务器端；</p>
<p>2）Cookie 是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie 最早在 RFC2109 中实现，后续 RFC2965 做了增强。 网络服务器用 HTTP 头向客户端发送 cookies，在客户终端，浏览器解析这些 cookie 并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些 cookies。Session 并没有在 HTTP 的协议中定义；</p>
<p>3）Session 是针对每一个用户的，变量的值保存在服务器上，用一个 sessionID 来区分是哪个用户 session 变量，这个值是通过用户的浏览器在访问的时候返回给服务器， 当客户禁用 cookie 时，这个值也可能设置为由 get 来返回给服务器；</p>
<p>4）就安全性来说：当你访问一个使用 session 的站点，同时在自己机子上建立一个 cookie，建议在服务器端的 SESSION 机制更安全些。因为它不会任意读取客户存储的信息。</p>
<p>5.3、通过表单变量保持状态</p>
<p>除了 Cookies 之外，还可以使用表单变量来保持状态，比如 Asp.net 就通过一个叫 ViewState 的 Input=“hidden” 的框来保持状态，比如:</p>
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUKMjA0OTM4MTAwNGRkXUfhlDv1Cs7/qhBlyZROCzlvf5U=" />

<p>这个原理和 Cookies 大同小异，只是每次请求和响应所附带的信息变成了表单变量。</p>
<p>5.4、通过 QueryString 保持状态</p>
<p>QueryString 通过将信息保存在所请求地址的末尾来向服务器传送信息，通常和表单结合使用，一个典型的 QueryString 比如:<a href="http://www.xxx.com/xxx.aspx?var1=value&amp;var2=value2">www.xxx.com/xxx.aspx?var1=value&amp;var2=value2</a></p>
<p>六、缓存的实现原理</p>
<p>WEB 缓存 (cache) 位于 Web 服务器和客户端之间。</p>
<p>缓存会根据请求保存输出内容的副本，例如 html 页面，图片，文件，当下一个请求来到的时候：如果是相同的 URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p>
<p>HTTP 协议定义了相关的消息头来使 WEB 缓存尽可能好的工作。</p>
<p>6.1、缓存的优点</p>
<p>减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让 web 服务器看上去相应更快。</p>
<p>减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。</p>
<p>6.2、客户端缓存生效的常见流程</p>
<p>服务器收到请求时，会在 200OK 中回送该资源的 Last-Modified 和 ETag 头，客户端将该资源保存在 cache 中，并记录这两个属性。当客户端需要发送相同的请求时， 会在请求中携带 If-Modified-Since 和 If-None-Match 两个头。两个头的值分别是响应中 Last-Modified 和 ETag 头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回 304 响应。</p>
<p>6.3、Web 缓存机制</p>
<p>HTTP/1.1 中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP 利用一个 “过期（expiration）” 机制来为此目的。 后者减少了网络应用的带宽；HTTP 用 “验证（validation）” 机制来为此目的。</p>
<p>HTTP 定义了 3 种缓存机制：</p>
<p>1）Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires 回应头给了一个文档不可用的时间。Cache-Control 中的 max-age 标识指明了缓存的最长时间；</p>
<p>2）Validation：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个 Last-Modified 回应头，缓存能够使用 If-Modified-Since 来判断是否已改变，以便判断根据情况发送请求；</p>
<p>3）Invalidation：在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个 URL 关联到一个缓存回应，但是其后跟着 POST、PUT 和 DELETE 的请求的话，缓存就会过期。</p>
<h3 id="七、HTTP-应用"><a href="#七、HTTP-应用" class="headerlink" title="七、HTTP 应用"></a>七、HTTP 应用</h3><p>7.1、断点续传的实现原理</p>
<p>HTTP 协议的 GET 方法，支持只请求某个资源的某一部分；</p>
<p>206 Partial Content 部分内容响应；</p>
<p>Range 请求的资源范围；</p>
<p>Content-Range 响应的资源范围；</p>
<p>在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。</p>
<p>分块请求资源实例：</p>
<p>Eg1：Range: bytes=306302- ：请求这个资源从 306302 个字节到末尾的部分；</p>
<p>Eg2：Content-Range: bytes 306302-604047/604048：响应中指示携带的是该资源的第 306302-604047 的字节，该资源共 604048 个字节；</p>
<p>客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的 FlashGet 和迅雷基本都是这个原理。</p>
<p>7.2、多线程下载的原理</p>
<p>下载工具开启多个发出 HTTP 请求的线程；</p>
<p>每个 http 请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；</p>
<p>合并每个线程下载的文件。</p>
<p>7.3、http 代理</p>
<p>http 代理服务器</p>
<p>代理服务器英文全称是 Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。</p>
<p>代理服务器是介于浏览器和 Web 服务器之间的一台服务器，有了它之后，浏览器不是直接到 Web 服务器去取回网页而是向代理服务器发出请求，Request 信号会先送到代理服务器， 由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的 Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的， 那么它就不重新从 Web 服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。更重要的是：Proxy Server (代理服务器) 是 Internet 链路级网关所提供的一种重要的安全功能， 它的工作主要在开放系统互联 (OSI) 模型的对话层。</p>
<p>http 代理服务器的主要功能：</p>
<p>1）突破自身 IP 访问限制，访问国外站点。如：教育网、169 网等网络用户可以通过代理访问国外网站；</p>
<p>2）访问一些单位或团体内部资源，如某大学 FTP (前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类 FTP 下载上传，以及各类资料查询共享等服务；</p>
<p>3）突破中国电信的 IP 封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同 Serve 对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试；</p>
<p>4）提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度；</p>
<p>5）隐藏真实 IP：上网者也可以通过这种方法隐藏自己的 IP，免受攻击。</p>
<p>对于客户端浏览器而言，http 代理服务器相当于服务器。</p>
<p>而对于 Web 服务器而言，http 代理服务器又担当了客户端的角色。</p>
<p>7.4、虚拟主机</p>
<p>虚拟主机：是在网络服务器上划分出一定的磁盘空间供用户放置站点、应用组件等，提供必要的站点功能与数据存放、传输功能。</p>
<p>所谓虚拟主机，也叫 “网站空间” 就是把一台运行在互联网上的服务器划分成多个 “虚拟” 的服务器，每一个虚拟主机都具有独立的域名和完整的 Internet 服务器（支持 WWW、FTP、E-mail 等）功能。 一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。</p>
<p>虚拟主机的实现原理</p>
<p>虚拟主机是用同一个 WEB 服务器，为不同域名网站提供服务的技术。Apache、Tomcat 等均可通过配置实现这个功能。</p>
<p>相关的 HTTP 消息头：Host。</p>
<p>例如：Host: <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>客户端发送 HTTP 请求的时候，会携带 Host 头，Host 头记录的是客户端输入的域名。这样服务器可以根据 Host 头确认客户要访问的是哪一个域名。</p>
<h3 id="八、HTTP-认证方式"><a href="#八、HTTP-认证方式" class="headerlink" title="八、HTTP 认证方式"></a>八、HTTP 认证方式</h3><p>HTTP 请求报头： Authorization</p>
<p>HTTP 响应报头： WWW-Authenticate</p>
<p>HTTP 认证是基于质询 / 回应 (challenge/response) 的认证模式。</p>
<p>8.1 基本认证 basic authentication（HTTP1.0 提出的认证方法）</p>
<p>基本认证是一种用来允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。</p>
<p>把 “用户名 + 冒号 + 密码” 用 BASE64 算法加密后的字符串放在 http request 中的 header Authorization 中发送给服务端。</p>
<p>客户端对于每一个 realm，通过提供用户名和密码来进行认证的方式。</p>
<p>包含密码的明文传递。</p>
<p>当浏览器访问使用基本认证的网站的时候， 浏览器会提示你输入用户名和密码。</p>
<p>基本认证步骤：</p>
<p>1、客户端访问一个受 http 基本认证保护的资源。</p>
<p>2、服务器返回 401 状态，要求客户端提供用户名和密码进行认证。（验证失败的时候，响应头会加上 WWW-Authenticate: Basic realm=”请求域”。）</p>
<p>401 Unauthorized</p>
<p>WWW-Authenticate： Basic realm=”WallyWorld”</p>
<p>3、客户端将输入的用户名密码用 Base64 进行编码后，采用非加密的明文方式传送给服务器。</p>
<p>Authorization: Basic xxxxxxxxxx.</p>
<p>4、服务器将 Authorization 头中的用户名密码解码并取出，进行验证，如果认证成功，则返回相应的资源。如果认证失败，则仍返回 401 状态，要求重新进行认证。</p>
<p>特记事项：</p>
<p>1、Http 是无状态的，同一个客户端对同一个 realm 内资源的每一个访问会被要求进行认证。</p>
<p>2、客户端通常会缓存用户名和密码，并和 authentication realm 一起保存，所以，一般不需要你重新输入用户名和密码。</p>
<p>3、以非加密的明文方式传输，虽然转换成了不易被人直接识别的字符串，但是无法防止用户名密码被恶意盗用。虽然用肉眼看不出来，但用程序很容易解密。</p>
<p>优点：</p>
<p>基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。基本认证很少在可公开访问的互联网网站上使用，有时候会在小的私有系统中使用（如路由器 网页管理接口）。后来的机制 HTTP 摘要认证是为替代基本认证而开发的，允许密钥以相对安全的方式在不安全的通道上传输。</p>
<p>程序员和系统管理员有时会在可信网络环境中使用基本认证，使用 Telnet 或其他明文网络协议工具手动地测试 Web 服务器。这是一个麻烦的过程，但是网络上传输的 内容是人可读的，以便进行诊断。</p>
<p>缺点：</p>
<p>虽然基本认证非常容易实现，但该方案建立在以下的假设的基础上，即：客户端和服务器主机之间的连接是安全可信的。特别是，如果没有使用 SSL/TLS 这样的传输 层安全的协议，那么以明文传输的密钥和口令很容易被拦截。该方案也同样没有对服务器返回的信息提供保护。</p>
<p>现存的浏览器保存认证信息直到标签页或浏览器被关闭，或者用户清除历史记录。HTTP 没有为服务器提供一种方法指示客户端丢弃这些被缓存的密钥。这意味着服务 器端在用户不关闭浏览器的情况下，并没有一种有效的方法来让用户登出。</p>
<p>一个例子：</p>
<p>这一个典型的 HTTP 客户端和 HTTP 服务器的对话，服务器安装在同一台计算机上（localhost），包含以下步骤：</p>
<p>客户端请求一个需要身份认证的页面，但是没有提供用户名和口令。这通常是用户在地址栏输入一个 URL，或是打开了一个指向该页面的链接。服务端响应一个 401 应 答码，并提供一个认证域。接到应答后，客户端显示该认证域（通常是所访问的计算机或系统的描述）给用户并提示输入用户名和口令。此时用户可以选择确定或取 消。用户输入了用户名和口令后，客户端软件会在原先的请求上增加认证消息头（值是 base64encode (username+”:”+password)），然后重新发送再次尝试。 在本例中，服务器接受了该认证屏幕并返回了页面。如果用户凭据非法或无效，服务器可能再次返回 401 应答码，客户端可以再次提示用户输入口令。</p>
<p>注意：客户端有可能不需要用户交互，在第一次请求中就发送认证消息头。</p>
<blockquote>
<p>客户端请求（没有认证信息）：</p>
<p>GET /private/index.html HTTP/1.0</p>
<p>Host: localhost</p>
<p>（跟随一个换行，以回车（CR）加换行（LF）的形式）</p>
</blockquote>
<blockquote>
<p>服务端应答：</p>
<p>HTTP/1.0 401 Authorization Required</p>
<p>Server: HTTPd/1.0</p>
<p>Date: Sat, 27 Nov 2004 10:18:15 GMT</p>
<p>WWW-Authenticate: Basic realm=”Secure Area”</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 311</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><br><span class="line"> &quot;http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd&quot;&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">  &lt;HEAD&gt;</span><br><span class="line">    &lt;TITLE&gt;Error&lt;/TITLE&gt;</span><br><span class="line">    &lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=ISO-8859-1&quot;&gt;</span><br><span class="line">  &lt;/HEAD&gt;</span><br><span class="line">  &lt;BODY&gt;&lt;H1&gt;401 Unauthorized.&lt;/H1&gt;&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br><span class="line">						</span><br><span class="line">					</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>客户端的请求（用户名 “”Aladdin”，口令，password “open sesame”）：</p>
<p>GET /private/index.html HTTP/1.0</p>
<p>Host: localhost</p>
<p>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p>
<p>（跟随一个空行，如上所述）</p>
</blockquote>
<blockquote>
<p>服务端的应答：</p>
<p>HTTP/1.0 200 OK</p>
<p>Server: HTTPd/1.0</p>
<p>Date: Sat, 27 Nov 2004 10:19:07 GMT</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 10476</p>
<p>（跟随一个空行，随后是需凭据页的 HTML 文本）。</p>
</blockquote>
<p>HTTP OAuth 认证</p>
<p>OAuth 对于 Http 来说，就是放在 Authorization header 中的不是用户名密码， 而是一个 token。微软的 Skydrive 就是使用这样的方式。</p>
<p>8.2、摘要认证 digest authentication（HTTP1.1 提出的基本认证的替代方法）</p>
<p>这个认证可以看做是基本认证的增强版本，不包含密码的明文传递。</p>
<p>引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数。</p>
<p>在 HTTP 摘要认证中使用 MD5 加密是为了达成 “不可逆的”，也就是说，当输出已知的时候，确定原始的输入应该是相当困难的。如果密码本身太过简单，也许可以</p>
<p>通过尝试所有可能的输入来找到对应的输出（穷举攻击），甚至可以通过字典或者适当的查找表加快查找速度。</p>
<p>示例及说明</p>
<p>下面的例子仅仅涵盖了 “auth” 保护质量的代码，因为在撰写期间，所知道的只有 Opera 和 Konqueror 网页浏览器支持 “auth-int”（带完整性保护的认证）。</p>
<p>典型的认证过程包括如下步骤：</p>
<p>客户端请求一个需要认证的页面，但是不提供用户名和密码。通常这是由于用户简单的输入了一个地址或者在页面中点击了某个超链接。</p>
<p>服务器返回 401 “Unauthorized” 响应代码，并提供认证域 (realm)，以及一个随机生成的、只使用一次的数值，称为密码随机数 nonce。</p>
<p>此时，浏览器会向用户提示认证域 (realm)（通常是所访问的计算机或系统的描述），并且提示用户名和密码。用户此时可以选择取消。</p>
<p>一旦提供了用户名和密码，客户端会重新发送同样的请求，但是添加了一个认证头包括了响应代码。</p>
<p>注意：客户端可能已经拥有了用户名和密码，因此不需要提示用户，比如以前存储在浏览器里的。</p>
<blockquote>
<p>客户端请求 (无认证)：</p>
<p>GET /dir/index.html HTTP/1.0</p>
<p>Host: localhost</p>
<p>(跟随一个新行，形式为一个回车再跟一个换行）</p>
</blockquote>
<blockquote>
<p>服务器响应：</p>
<p>HTTP/1.0 401 Unauthorized</p>
<p>Server: HTTPd/0.9</p>
<p>Date: Sun, 10 Apr 2005 20:26:47 GMT</p>
<p>WWW-Authenticate: Digest realm=”<a href="mailto:&#x74;&#101;&#x73;&#x74;&#114;&#101;&#x61;&#x6c;&#109;&#x40;&#x68;&#111;&#x73;&#x74;&#x2e;&#99;&#111;&#x6d;">&#x74;&#101;&#x73;&#x74;&#114;&#101;&#x61;&#x6c;&#109;&#x40;&#x68;&#111;&#x73;&#x74;&#x2e;&#99;&#111;&#x6d;</a>“, // 认证域 qop=”auth,auth-int”, // 保护质量 nonce=”dcd98b7102dd2f0e8b11d0f600bfb0c093”, // 服务器密码随机数 opaque=”5ccc069c403ebaf9f0171e9517f40e41”</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 311</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><br><span class="line"> &quot;http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd&quot;&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">  &lt;HEAD&gt;</span><br><span class="line">    &lt;TITLE&gt;Error&lt;/TITLE&gt;</span><br><span class="line">    &lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=ISO-8859-1&quot;&gt;</span><br><span class="line">  &lt;/HEAD&gt;</span><br><span class="line">  &lt;BODY&gt;&lt;H1&gt;401 Unauthorized.&lt;/H1&gt;&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br><span class="line">						</span><br><span class="line">					</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>客户端请求 (用户名 “Mufasa”, 密码 “Circle Of Life”)：</p>
<p>GET /dir/index.html HTTP/1.0</p>
<p>Host: localhost</p>
<p>Authorization: Digest username=”Mufasa”, realm=”<a href="mailto:&#x74;&#101;&#x73;&#x74;&#114;&#101;&#x61;&#108;&#x6d;&#x40;&#x68;&#x6f;&#115;&#116;&#x2e;&#x63;&#111;&#x6d;">&#x74;&#101;&#x73;&#x74;&#114;&#101;&#x61;&#108;&#x6d;&#x40;&#x68;&#x6f;&#115;&#116;&#x2e;&#x63;&#111;&#x6d;</a>“, nonce=”dcd98b7102dd2f0e8b11d0f600bfb0c093”, uri=”/dir/index.html”, qop=auth, nc=00000001, // 请求计数 cnonce=”0a4f113b”, // 客户端密码随机数 response=”6629fae49393a05397450978507c4ef1”, opaque=”5ccc069c403ebaf9f0171e9517f40e41”</p>
<p>(跟随一个新行，形式如前所述)。</p>
</blockquote>
<blockquote>
<p>服务器响应：</p>
<p>HTTP/1.0 200 OK</p>
<p>Server: HTTPd/0.9</p>
<p>Date: Sun, 10 Apr 2005 20:27:03 GMT</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 7984</p>
<p>(随后是一个空行，然后是所请求受限制的 HTML 页面)</p>
</blockquote>
<p>response 值由三步计算而成。当多个数值合并的时候，使用冒号作为分割符：</p>
<p>1、对用户名、认证域 (realm) 以及密码的合并值计算 MD5 哈希值，结果称为 HA1。</p>
<p>2、对 HTTP 方法以及 URI 的摘要的合并值计算 MD5 哈希值，例如，”GET” 和 “/dir/index.html”，结果称为 HA2。</p>
<p>3、对 HA1、服务器密码随机数 (nonce)、请求计数 (nc)、客户端密码随机数 (cnonce)、保护质量 (qop) 以及 HA2 的合并值计算 MD5 哈希值。结果即为客户端提供的 response 值。</p>
<p>因为服务器拥有与客户端同样的信息，因此服务器可以进行同样的计算，以验证客户端提交的 response 值的正确性。在上面给出的例子中，结果是如下计算的。</p>
<p>（MD5 () 表示用于计算 MD5 哈希值的函数；“\” 表示接下一行；引号并不参与计算）</p>
<p>HA1 = MD5( “Mufasa:<a href="mailto:&#116;&#x65;&#115;&#116;&#114;&#x65;&#x61;&#108;&#109;&#64;&#x68;&#x6f;&#115;&#116;&#x2e;&#x63;&#x6f;&#109;">&#116;&#x65;&#115;&#116;&#114;&#x65;&#x61;&#108;&#109;&#64;&#x68;&#x6f;&#115;&#116;&#x2e;&#x63;&#x6f;&#109;</a>:Circle Of Life” ) = 939e7578ed9e3c518a452acee763bce9</p>
<p>HA2 = MD5( “GET:/dir/index.html” ) = 39aff3a2bab6126f332b942af96d3366</p>
<p>Response = MD5( “939e7578ed9e3c518a452acee763bce9:\ dcd98b7102dd2f0e8b11d0f600bfb0c093:\ 00000001:0a4f113b:auth:\ 39aff3a2bab6126f332b942af96d3366” ) = 6629fae49393a05397450978507c4ef1</p>
<p>此时客户端可以提交一个新的请求，重复使用服务器密码随机数 (nonce)（服务器仅在每次 “401” 响应后发行新的 nonce），但是提供新的客户端密码随机数 (cnonce)。 在后续的请求中，十六进制请求计数器 (nc) 必须比前一次使用的时候要大，否则攻击者可以简单的使用同样的认证信息重放老的请求。由服务器来确保在每个发出的密码随机数 nonce 时， 计数器是在增加的，并拒绝掉任何错误的请求。显然，改变 HTTP 方法和 / 或计数器数值都会导致不同的 response 值。</p>
<p>服务器应当记住最近所生成的服务器密码随机数 nonce 的值。也可以在发行每一个密码随机数 nonce 后，记住过一段时间让它们过期。如果客户端使用了一个过期的值，服务器应该响应 “401” 状态号， 并且在认证头中添加 stale=TRUE，表明客户端应当使用新提供的服务器密码随机数 nonce 重发请求，而不必提示用户其它用户名和口令。</p>
<p>服务器不需要保存任何过期的密码随机数，它可以简单的认为所有不认识的数值都是过期的。服务器也可以只允许每一个服务器密码随机数 nonce 使用一次，当然， 这样就会迫使客户端在发送每个请求的时候重复认证过程。需要注意的是，在生成后立刻过期服务器密码随机数 nonce 是不行的，因为客户端将没有任何机会来使用这个 nonce。</p>
<p>PS：以上只介绍了两种比较基础的，还有其他的一些认证方式就不在这里一一说明了。</p>
<h3 id="九、HTTPS-传输协议原理"><a href="#九、HTTPS-传输协议原理" class="headerlink" title="九、HTTPS 传输协议原理"></a>九、HTTPS 传输协议原理</h3><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容请看 SSL。</p>
<p>9.1、两种基本的加解密算法类型</p>
<p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等。</p>
<p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</p>
<p>9.2、HTTPS 通信过程</p>
<p><img src="/images/http%E5%8D%8F%E8%AE%AE%E6%95%B4%E7%90%86/https.png" alt="HTTPS通信过程"></p>
<p>9.3、HTTPS 通信的优点</p>
<p>客户端产生的密钥只有客户端和服务器端能得到；</p>
<p>加密的数据只有客户端和服务器端才能得到明文；</p>
<p>客户端到服务端的通信是安全的。</p>
<h3 id="十、http-的状态响应码"><a href="#十、http-的状态响应码" class="headerlink" title="十、http 的状态响应码"></a>十、http 的状态响应码</h3><p>1**(信息类)：表示接收到请求并且继续处理</p>
<p>100—— 客户必须继续发出请求</p>
<p>101—— 客户要求服务器根据请求转换 HTTP 协议版本</p>
<p>2**(响应成功)：表示动作被成功接收、理解和接受</p>
<p>200—— 表明该请求被成功地完成，所请求的资源发送回客户端</p>
<p>201—— 提示知道新文件的 URL</p>
<p>202—— 接受和处理、但处理未完成</p>
<p>203—— 返回信息不确定或不完整</p>
<p>204—— 请求收到，但返回信息为空</p>
<p>205—— 服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p>
<p>206—— 服务器已经完成了部分用户的 GET 请求</p>
<p>3**(重定向类)：为了完成指定的动作，必须接受进一步处理</p>
<p>300—— 请求的资源可在多处得到</p>
<p>301—— 本网页被永久性转移到另一个 URL</p>
<p>302—— 请求的网页被转移到一个新的地址，但客户访问仍继续通过原始 URL 地址，重定向，新的 URL 会在 response 中的 Location 中返回，浏览器将会使用新的 URL 发出新的 Request。</p>
<p>303—— 建议客户访问其他 URL 或访问方式</p>
<p>304—— 自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</p>
<p>305—— 请求的资源必须从服务器指定的地址得到</p>
<p>306—— 前一版本 HTTP 中使用的代码，现行版本中不再使用</p>
<p>307—— 申明请求的资源临时性删除</p>
<p>4**(客户端错误类)：请求包含错误语法或不能正确执行</p>
<p>400—— 客户端请求有语法错误，不能被服务器所理解</p>
<p>401—— 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用</p>
<p>HTTP 401.1 - 未授权：登录失败</p>
<p>　　</p>
<p>HTTP 401.2 - 未授权：服务器配置问题导致登录失败</p>
<p>　　</p>
<p>HTTP 401.3 - ACL 禁止访问资源</p>
<p>　　</p>
<p>HTTP 401.4 - 未授权：授权被筛选器拒绝</p>
<p>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</p>
<p>402—— 保留有效 ChargeTo 头响应</p>
<p>403—— 禁止访问，服务器收到请求，但是拒绝提供服务</p>
<p>HTTP 403.1 禁止访问：禁止可执行访问</p>
<p>　　</p>
<p>HTTP 403.2 - 禁止访问：禁止读访问</p>
<p>　　</p>
<p>HTTP 403.3 - 禁止访问：禁止写访问</p>
<p>　　</p>
<p>HTTP 403.4 - 禁止访问：要求 SSL</p>
<p>　　</p>
<p>HTTP 403.5 - 禁止访问：要求 SSL 128</p>
<p>　　</p>
<p>HTTP 403.6 - 禁止访问：IP 地址被拒绝</p>
<p>　　</p>
<p>HTTP 403.7 - 禁止访问：要求客户证书</p>
<p>　　</p>
<p>HTTP 403.8 - 禁止访问：禁止站点访问</p>
<p>　　</p>
<p>HTTP 403.9 - 禁止访问：连接的用户过多</p>
<p>　　</p>
<p>HTTP 403.10 - 禁止访问：配置无效</p>
<p>　　</p>
<p>HTTP 403.11 - 禁止访问：密码更改</p>
<p>　　</p>
<p>HTTP 403.12 - 禁止访问：映射器拒绝访问</p>
<p>　　</p>
<p>HTTP 403.13 - 禁止访问：客户证书已被吊销</p>
<p>　　</p>
<p>HTTP 403.15 - 禁止访问：客户访问许可过多</p>
<p>　　</p>
<p>HTTP 403.16 - 禁止访问：客户证书不可信或者无效</p>
<p>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</p>
<p>404—— 一个 404 错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的 URL</p>
<p>405—— 用户在 Request-Line 字段定义的方法不允许</p>
<p>406—— 根据用户发送的 Accept 拖，请求资源不可访问</p>
<p>407—— 类似 401，用户必须首先在代理服务器上得到授权</p>
<p>408—— 客户端没有在用户指定的饿时间内完成请求</p>
<p>409—— 对当前资源状态，请求不能完成</p>
<p>410—— 服务器上不再有此资源且无进一步的参考地址</p>
<p>411—— 服务器拒绝用户定义的 Content-Length 属性请求</p>
<p>412—— 一个或多个请求头字段在当前请求中错误</p>
<p>413—— 请求的资源大于服务器允许的大小</p>
<p>414—— 请求的资源 URL 长于服务器允许的长度</p>
<p>415—— 请求资源不支持请求项目格式</p>
<p>416—— 请求中包含 Range 请求头字段，在当前请求资源范围内没有 range 指示值，请求也不包含 If-Range 请求头字段</p>
<p>417—— 服务器不满足请求 Expect 头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p>
<p>5**(服务端错误类)：服务器不能正确执行一个正确的请求</p>
<p>HTTP 500 - 服务器遇到错误，无法完成请求</p>
<p>　　</p>
<p>HTTP 500.100 - 内部服务器错误 - ASP 错误</p>
<p>　　</p>
<p>HTTP 500-11 服务器关闭</p>
<p>　　</p>
<p>HTTP 500-12 应用程序重新启动</p>
<p>　　</p>
<p>HTTP 500-13 - 服务器太忙</p>
<p>　　</p>
<p>HTTP 500-14 - 应用程序无效</p>
<p>　　</p>
<p>HTTP 500-15 - 不允许请求 global.asa</p>
<p>　　</p>
<p>Error 501 - 未实现</p>
<p>HTTP 502 - 网关错误</p>
<p>HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</p>
<p><a href="https://futuresuperstar.github.io/html/http">参考</a></p>
<h2 id="http、html-和浏览器篇"><a href="#http、html-和浏览器篇" class="headerlink" title="http、html 和浏览器篇 ***"></a><a href="https://mp.weixin.qq.com/s/jYlcp4kyrD5XBXeMM7YX7Q">http、html 和浏览器篇</a> ***</h2>]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常见命令</title>
    <url>/2019/11/07/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>liunx常见命令<br>1.liunx 中用于显示配置网络设备的命令是什么？</p>
<p>ifconfig -a  </p>
<span id="more"></span>

<p>2.liunx 系统日志存放在哪个目录</p>
<p> var/log</p>
<p>3.3. 是否使用过 liunx 防火墙、链、表 策略与关系是什么</p>
<ol start="4">
<li>是否使用过 tcpdump 抓包工具，抓到包默认是多大，如果想抓全包怎么做</li>
</ol>
<p>目前我也没有用过 tcpdump 抓包，看了下说明，tcpdump 是在 liunx 的命令抓包工具，默认是抓取 eth0 的网关工具，默认的抓取长度为 68 个字节，加上 - S 0 可以抓全包，这里要注意，抓取的包是要存放在文件里面，可以使用 wireshark 进行分析，拷贝一个其他博主对 tcpdump 命令的全解</p>
<p>tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap<br>(1) tcp: ip icmp arp rarp 和 tcp、udp、icmp 这些选项等都要放到第一个参数的位置，用来过滤数据报的类型<br>(2)-i eth1 : 只抓经过接口 eth1 的包<br>(3)-t : 不显示时间戳<br>(4)-s 0 : 抓取数据包时默认抓取长度为 68 字节。加上 - S 0 后可以抓到完整的数据包<br>(5)-c 100 : 只抓取 100 个数据包<br>(6) dst port ! 22 : 不抓取目标端口是 22 的数据包<br>(7) src net 192.168.1.0/24 : 数据包的源网络地址为 192.168.1.0/24<br>(8)-w ./target.cap : 保存成 cap 文件，方便用 ethereal (即 wireshark) 分析</p>
<ol start="5">
<li>对于抓到的 https 数据包，能否查看数据包的内容？如果不能，有没有办法看到内容？</li>
</ol>
<p>6.liunx 下查看本机网络连接使用什么命令</p>
<p>netstat -a (显示所有 socket)   -c -i (显示所有网络接口信息)</p>
<p>7.liunx 下列出模块，加载模块，移除模块的命令是什么</p>
<p>modprobe : 自动加载    删除模块的命令是：modprobe -r filename。</p>
<ol start="8">
<li>修改文件属性的命令是什么？修改文件的属主命是什么？</li>
</ol>
<p> 文件属性 chmod, 属主命：chown</p>
<p>9.liunx 的运行级别有哪些</p>
<p><a href="http://www.360doc.com/content/14/0107/15/13084517_343330992.shtml">http://www.360doc.com/content/14/0107/15/13084517_343330992.shtml</a></p>
<p> 填空题的 linux</p>
<ol start="10">
<li><p>将当前目录下的名为 img 的文件夹拷贝到当前路径下 static 文件夹中  cp  -r  img /. staic    删除当前路径下的 static 文件夹： rm -rf static</p>
</li>
<li><p>动态监控 ngix.log 的新增内容，输出其中含有【“error”】字符串的行   ：tail -f nginx.log   grep -rn [‘error’]</p>
</li>
<li><p>用 vim 打开文本文件 config.php 后，如何将所有字符串 “true” 替换为 “false” :% s/true/false/g  , 如何加行号 在 vi 命令模式下：set nu。</p>
</li>
</ol>
<p>   如何对撤销上一步操作：按 ESC 后 U 撤销操作，或者 crrl+z  </p>
<ol start="13">
<li>不是有搜索引擎，在 liunx 命令行下，如何查看某个如何使用   如：find  —help</li>
</ol>
<p>14,shell 编程题，用 bash 实现如下功能： 每隔一分钟，在当前文件夹生成一个以当前日期加顺序号为名字的文件夹，如使用相关 liunx 命令获得了今天日期，20191014-1，20191014-2，等</p>
<p>现在我没有环境不知道正确性，贴一个类似创建的帖子 <a href="https://blog.csdn.net/shoajun_5243/article/details/83539069%EF%BC%8C%E9%87%8C%E9%9D%A2%E9%9C%80%E8%A6%81%E5%8A%A0%E4%B8%AA%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD">https://blog.csdn.net/shoajun_5243/article/details/83539069，里面需要加个循环判断</a></p>
<ol start="15">
<li>查看当前所在目录。如若当前在，/home/usr1 目录下，查看此目录大小。列出此目录下的所有文件（包括隐藏文件）。</li>
</ol>
<p>du   -h –max-depth=1 /home/usr1</p>
<ol start="16">
<li>查看网络状态，查看网络适配器配置。查看系统进程，查看系统执行中的进程及其所占资源的命令。</li>
</ol>
<p>查看网络适配器：ifconfig   查看系统进程： ps aux |grep “tomcat” , 这个就是查看 tomcat 的系统进程，使用 ps -elf 信息更详细    查看资源占用，使用 top ，</p>
<ol start="17">
<li>新建一个文件 apptest.c</li>
</ol>
<p>mkdir  apptest.c</p>
<ol start="18">
<li>列出所有你知道的可以用来查找文件和文件内容的命令。</li>
</ol>
<p>查找目录 ：find  / 查找范围  -name ‘查找关键字’ -type d</p>
<p>查找文件： find / 查找范围  -name 查找关键字 </p>
<p>19。有 300 个源代码文件（.cpp ,  .h ,  .inl）放在同一个文件夹里面，由于版本升级，需要修改该文件夹中所有.cpp 的文件中的版本号（由 version=’1.2’更新为 version=’3.0’）</p>
<p>要求：1. 只修改.cpp 文件中的版本号，不能影响.h 和.inl 文件 2. 对原有的文件需要做备份，以.bak 结尾</p>
<p> 需要找个环境试下，在把命令贴出来</p>
<p>网络</p>
<ol>
<li><p>查看 cpu  ide 的命令 top  查看 liunx 服务器磁盘空间占用情况的命令是  df -h</p>
</li>
<li><p>自下而上的网络五层结构分别是 物理层、 数据链路层、路由层、网络层、应用层；</p>
<p>FTP、POP3、SMTP 是应用层的协议，端口是传输层的概念，mac 地址是数据链路层的概念</p>
</li>
</ol>
<p>3.netstat ap|grep  *tcp|awk ‘{print $NF}’ |sort -nr |uniq  -c ，该 liunx 命令的作用是什么</p>
<p>.netstat ap|grep  *tcp：找出 tcp 端口的程序名  sort -nr |uniq  -c：统计数据频率    </p>
<ol start="4">
<li>列出你所知道的常见的 http 状态码及所代表的含义</li>
</ol>
<p>1xx: 消息</p>
<p>  100：相互传输数据中   201：消息将被继续执行下去</p>
<p>2xx：成功  </p>
<p>   200：请求成功   201：请求已实现，但是有一个新的资源请求在创建   202：服务器已接受请求，但是商未处理</p>
<p>3XX: 重定向</p>
<p>  301：资源文件永久移到新位置，</p>
<p>  302：临时移动资源，进行重定向</p>
<p>  304：自上次请求后，请求的网页没有被修改过</p>
<p>4XX: 请求错误</p>
<p>  402：客户端错误</p>
<p>5xx: 服务器错误</p>
<p> 500：服务器连接失败</p>
<p>有很多，我记住的有些少，大伙可以百度</p>
<p>5.http 请求头包含哪些信息？</p>
<p>对 fiddler 比较熟悉的都知道，</p>
<p>复制代码<br>POST /o_vod_h5sdk_cycle HTTP/1.1<br>Host: sdk1xyajs-data.xycdn.com   #host<br>Connection: keep-alive   #连接方式<br>Content-Length: 439  连接资源的大小<br>Origin: <a href="https://music.163.com/">https://music.163.com</a>      #指明是谁发起的请求，在post中启用<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36 #浏览器信息<br>Content-Type: application/x-www-form-urlencoded #请求的类型信息<br>Accept: <em>/</em><br>Referer: <a href="https://music.163.com/">https://music.163.com/</a>     #告诉服务器是从哪个网页中来的<br>Accept-Encoding: gzip, deflate, br  #资源文件是压缩<br>Accept-Language: zh-CN,zh;q=0.9    #资源文件使用的语言<br>复制代码<br>6. 什么是 URL？请以下方这个 URL 为例说明 URL 每个组成部分的含义。</p>
<p>url：书面语，统一资源定位符，是不会重复的，是一个地址，</p>
<p><a href="http://bbs.360.cn/3229787.html">http://bbs.360.cn/3229787.html</a></p>
<p>协议方式 ：// 域名 / 虚拟目录</p>
<p><a href="https://www.cnblogs.com/chongyou/p/11642932.html">参考</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis知识整理</title>
    <url>/2019/11/13/mybatis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="mybatis-基础系列（一）——mybatis-入门"><a href="#mybatis-基础系列（一）——mybatis-入门" class="headerlink" title="mybatis 基础系列（一）——mybatis 入门"></a><a href="https://www.cnblogs.com/hjwublog/p/9957312.html">mybatis 基础系列（一）——mybatis 入门</a></h3><span id="more"></span>

<p><img src="/images/mybatis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573627414953.png" alt="1573627414953"></p>
<h3 id="mybatis-基础系列（二）——-基础语法、别名、输入映射、输出映射"><a href="#mybatis-基础系列（二）——-基础语法、别名、输入映射、输出映射" class="headerlink" title="mybatis 基础系列（二）—— 基础语法、别名、输入映射、输出映射"></a><a href="https://www.cnblogs.com/hjwublog/p/9965373.html">mybatis 基础系列（二）—— 基础语法、别名、输入映射、输出映射</a></h3><img src="/images/mybatis知识整理/1573627461003.png" alt="1573627461003" style="zoom:80%;" />

<h3 id="mybatis-基础系列（三）——-动态-sql"><a href="#mybatis-基础系列（三）——-动态-sql" class="headerlink" title="mybatis 基础系列（三）—— 动态 sql"></a><a href="https://www.cnblogs.com/hjwublog/p/9968420.html">mybatis 基础系列（三）—— 动态 sql</a></h3><p><img src="/images/mybatis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573627397967.png" alt="1573627397967"></p>
<h3 id="mybatis-基础系列（四）——-关联查询、延迟加载、一级缓存与二级缓存"><a href="#mybatis-基础系列（四）——-关联查询、延迟加载、一级缓存与二级缓存" class="headerlink" title="mybatis 基础系列（四）—— 关联查询、延迟加载、一级缓存与二级缓存"></a><a href="https://www.cnblogs.com/hjwublog/p/9974878.html">mybatis 基础系列（四）—— 关联查询、延迟加载、一级缓存与二级缓存</a></h3><p><img src="/images/mybatis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573627448800.png" alt="1573627448800"></p>
<h3 id="Mybatis-中实体类属性和数据列之间映射的四种办法"><a href="#Mybatis-中实体类属性和数据列之间映射的四种办法" class="headerlink" title="Mybatis 中实体类属性和数据列之间映射的四种办法"></a>Mybatis 中实体类属性和数据列之间映射的四种办法</h3><p>Mybatis 不像 Hibernate 中那么自动化，通过 <code>@Column</code> 注解或者直接使用实体类的属性名作为数据列名，而是需要自己指定实体类属性和<br>数据表中列名之间的映射关系，这一点让用惯了 Hibernate 的人很不习惯，所幸经过探索找到了建立映射关系的三种办法，其中总也有比较<br>简单的。</p>
<p>首先先定义一个实体类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-XML-映射文件中的-resultMap"><a href="#通过-XML-映射文件中的-resultMap" class="headerlink" title="通过 XML 映射文件中的 resultMap"></a>通过 XML 映射文件中的 <code>resultMap</code></h4><p>这种方式是最常见的，类似如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;data.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;resultMap type=<span class="string">&quot;data.User&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 用id属性来映射主键字段 --&gt;</span><br><span class="line">        &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;user_id&quot;</span>/&gt;</span><br><span class="line">        &lt;!-- 用result属性来映射非主键字段 --&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;userName&quot;</span> column=<span class="string">&quot;user_name&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>通过里面的 <code>id</code> 标签和 <code>result</code> 标签来建立映射关系，由 <code>property</code> 和 <code>column</code> 分别指定实体类属性和数据表的列名。</p>
<h4 id="通过注解-Results-和-Result"><a href="#通过注解-Results-和-Result" class="headerlink" title="通过注解 @Results 和 @Result"></a>通过注解 <code>@Results</code> 和 <code>@Result</code></h4><p>这两个注解是与 XML 文件中的标签相对应的：</p>
<ul>
<li><code>@Results</code> 对应 <code>resultMap</code></li>
<li><code>@Result</code> 对应 <code>result</code></li>
</ul>
<p>这两个注解是<strong>应用在方法的级别</strong>上的，也就是在 mapper 方法上，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from t_user where user_name = #&#123;userName&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;userId&quot;, column = &quot;user_id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;userName&quot;, column = &quot;user_name&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function">User <span class="title">getUserByName</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String userName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>由于注解是针对方法的，对于 Mapper 中的每个操作数据库的方法都必须有相同的注解完成映射关系的建立，导致很多的配置是重复的；</li>
<li>如果要避免配置重复的问题，可以采用在 XML 配置文件中配置这个 <code>resultMap</code>，然后再 <code>@Result</code> 中通过 id 属性引用这个 <code>resultMap</code>，<br>但是这样感觉很麻烦（由于使用了两种配置方式），不如直接使用基于 XML 的 <code>resultMap</code> 配置方式；</li>
</ul>
<h4 id="通过属性配置完成映射"><a href="#通过属性配置完成映射" class="headerlink" title="通过属性配置完成映射"></a>通过属性配置完成映射</h4><p>使用者最陌生的是通过配置属性来完成映射，Mybatis 给我们提供了一种映射方式，如果属性的命名是遵从驼峰命名法的，数据列名遵从下划线命名，<br>那么可以使用这种方式，类似如下：</p>
<ul>
<li>userName 对应 user_name;</li>
<li>userId 对应 user_id;</li>
</ul>
<p>（也可以配置@cloum进行映射）</p>
<p>配置代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">sqlSessionFactoryBean.setConfiguration(configuration);</span><br></pre></td></tr></table></figure>

<h4 id="通过使用在-SQL-语句中定义别名完成映射"><a href="#通过使用在-SQL-语句中定义别名完成映射" class="headerlink" title="通过使用在 SQL 语句中定义别名完成映射"></a>通过使用在 SQL 语句中定义别名完成映射</h4><p>这种方式最直接，直接在 SQL 语句中建立别名来完成映射，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select user_name as userName, user_id as userId from t_user where user_name = #&#123;userName&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserByName</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String userName)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis总结</title>
    <url>/2019/10/09/mybatis%E6%80%BB%E7%BB%93%E2%80%98/</url>
    <content><![CDATA[<p><strong>参考学习：<a href="https://blog.csdn.net/qq_35246620/article/details/54802944">CG国斌</a></strong></p>
<h3 id="1-所需jar包"><a href="#1-所需jar包" class="headerlink" title="1.所需jar包"></a>1.所需jar包</h3><span id="more"></span>

<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570609934294.png" alt="1570609934294"></h3><h2 id="2-mybatis核心配置"><a href="#2-mybatis核心配置" class="headerlink" title="2.mybatis核心配置"></a>2.mybatis核心配置</h2><p>sqlMapConfig.xml</p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570610644687.png" alt="1570610644687"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570610672625.png" alt="1570610672625"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613212440.png" alt="1570613212440"></p>
<h2 id="3-增删查改"><a href="#3-增删查改" class="headerlink" title="3.增删查改"></a>3.增删查改</h2><p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613258325.png" alt="1570613258325"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613274721.png" alt="1570613274721"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613282915.png" alt="1570613282915"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613296385.png" alt="1570613296385"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;yeepay.payplus/mapper.UserMapper&quot;</span>&gt;</span>   <span class="comment">&lt;!-- 命名空间，名字可以随意起，只要不冲突即可 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对象映射，可以不写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;yeepay.payplus.Person&quot;</span> <span class="attr">id</span>=<span class="string">&quot;personRM&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property=&quot;id&quot;，表示实体对象的属性；column=&quot;ID&quot;，表示结果集字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;AGE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 查询功能，resultType 设置返回值类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;yeepay.payplus.Person&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 书写 SQL 语句 --&gt;</span></span><br><span class="line">        SELECT * FROM person</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过 ID 查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;get&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;personRM&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 书写 SQL 语句 --&gt;</span></span><br><span class="line">        SELECT * FROM person</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 新增功能，在SQL语句中有参数，并以实体来封装参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;yeepay.payplus.Person&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO person (id,name,age) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 修改功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;yeepay.payplus.Person&quot;</span>&gt;</span></span><br><span class="line">        UPDATE person set name=#&#123;name&#125;,age=#&#123;age&#125;</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;integer&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM person</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 维C果糖 on 2017/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeshiMyBatis</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ceshi</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  1、获得 SqlSessionFactory</span></span><br><span class="line"><span class="comment">         *  2、获得 SqlSession</span></span><br><span class="line"><span class="comment">         *  3、调用在 mapper 文件中配置的 SQL 语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;           <span class="comment">// 定位核心配置文件</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();    <span class="comment">// 获取到 SqlSession</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mapper 中的方法：命名空间 + id</span></span><br><span class="line">        List&lt;Person&gt; personList = sqlSession.selectList(<span class="string">&quot;yeepay.payplus/mapper.UserMapper.findAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p : personList)&#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;           <span class="comment">//定位核心配置文件</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">this</span>.getClass().getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();            <span class="comment">//获取到 SqlSession</span></span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setId(<span class="number">5</span>);</span><br><span class="line">        p.setName(<span class="string">&quot;gavin&quot;</span>);</span><br><span class="line">        p.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        sqlSession.insert(<span class="string">&quot;yeepay.payplus.mapper.UserMapper.insert&quot;</span>, p);</span><br><span class="line">        sqlSession.commit();            <span class="comment">//默认是不自动提交，必须手工提交</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;           <span class="comment">//定位核心配置文件</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">this</span>.getClass().getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();            <span class="comment">// 获取到 SqlSession</span></span><br><span class="line"></span><br><span class="line">        Person p = sqlSession.selectOne(<span class="string">&quot;yeepay.payplus.mapper.UserMapper.get&quot;</span>, <span class="number">2</span>);   <span class="comment">// 获得 id=2 的记录</span></span><br><span class="line">        p.setName(<span class="string">&quot;jane&quot;</span>);</span><br><span class="line">        p.setAge(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        sqlSession.insert(<span class="string">&quot;yeepay.payplus.mapper.UserMapper.update&quot;</span>, p);</span><br><span class="line">        sqlSession.commit();            <span class="comment">//默认是不自动提交，必须手工提交</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;           <span class="comment">//定位核心配置文件</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">this</span>.getClass().getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();            <span class="comment">// 获取到 SqlSession</span></span><br><span class="line"></span><br><span class="line">        sqlSession.delete(<span class="string">&quot;yeepay.payplus.mapper.UserMapper.deleteById&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        sqlSession.commit();            <span class="comment">//默认是不自动提交，必须手工提交</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-基本参数使用"><a href="#4-基本参数使用" class="headerlink" title="4. 基本参数使用"></a>4. 基本参数使用</h2><p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613502563.png" alt="1570613502563"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613513253.png" alt="1570613513253"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613525935.png" alt="1570613525935"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613534820.png" alt="1570613534820"></p>
<h2 id="5-复杂sql查询"><a href="#5-复杂sql查询" class="headerlink" title="5.复杂sql查询"></a>5.复杂sql查询</h2><p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613591334.png" alt="1570613591334"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613606264.png" alt="1570613606264"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613964034.png" alt="1570613964034"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613973246.png" alt="1570613973246"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570613989332.png" alt="1570613989332"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614006737.png" alt="1570614006737"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614015434.png" alt="1570614015434"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614032639.png" alt="1570614032639"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614042639.png" alt="1570614042639"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614057734.png" alt="1570614057734"></p>
<h2 id="6-关系映射"><a href="#6-关系映射" class="headerlink" title="6.关系映射"></a>6.关系映射</h2><p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614123421.png" alt="1570614123421"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614135194.png" alt="1570614135194"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614149458.png" alt="1570614149458"></p>
<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614156962.png" alt="1570614156962"></p>
<p>创建 CustomerMapper.xml 映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;yeepay.payplus.mapper.CustomerMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;yeepay.payplus.domain.Customer&quot;</span> <span class="attr">id</span>=<span class="string">&quot;customerRM&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置关联关系 1:N --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;yeepay.payplus.domain.Customer&quot;</span> <span class="attr">id</span>=<span class="string">&quot;customerOrdersRM&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;customerRM&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置多的（N），property 属性就是实体中的 List 对象属性名称，ofType 属性就是集合元素的类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;yeepay.payplus.domain.Orders&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sn&quot;</span> <span class="attr">column</span>=<span class="string">&quot;SN&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">column</span>=<span class="string">&quot;REMARK&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 查询，关联关系 Map 作为查询条件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;find&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;customerOrdersRM&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            c.name,o.sn,o.remark</span><br><span class="line">        FROM</span><br><span class="line">            (SELECT id,name FROM customer) c</span><br><span class="line">        LEFT JOIN</span><br><span class="line">            (SELECT id,sn,remark,customer_id FROM orders) o</span><br><span class="line">        ON c.id = o.customer_id</span><br><span class="line">        WHERE c.name = #&#123;customerName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614192503.png" alt="1570614192503"></p>
<p>修改 sqlMapConfig.xml 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 赋别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;yeepay.payplus.domain.Person&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;Person&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置开发环境，可以配置多个，在具体用时再做切换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span>    <span class="comment">&lt;!-- 事务管理类型：JDBC、MANAGED --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 数据源类型：POOLED、UNPOOLED、JNDI --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载映射文件 mapper --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路径用 斜线（/） 分割，而不是用 点(.) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;yeepay/payplus/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;yeepay/payplus/mapper/CustomerMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614246906.png" alt="1570614246906"></p>
<p>创建 CeshiCustomer 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yeepay.payplus.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> yeepay.payplus.domain.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 维C果糖 on 2017/3/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeshiCustomer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  1、获得 SqlSessionFactory</span></span><br><span class="line"><span class="comment">         *  2、获得 SqlSession</span></span><br><span class="line"><span class="comment">         *  3、调用在 mapper 文件中配置的 SQL 语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String resource = <span class="string">&quot;sqlMapConfig.xml&quot;</span>;           <span class="comment">// 定位核心配置文件</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();    <span class="comment">// 获取到 SqlSession</span></span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;customerName&quot;</span>, <span class="string">&quot;charies&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mapper 中的方法：命名空间 + id</span></span><br><span class="line">        List&lt;Customer&gt; customerList = sqlSession.selectList(<span class="string">&quot;yeepay.payplus.mapper.CustomerMapper.find&quot;</span>, map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Customer c : customerList) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mybatis%E6%80%BB%E7%BB%93%E2%80%98/1570614270734.png" alt="1570614270734"></p>
<h2 id="7-学习"><a href="#7-学习" class="headerlink" title="7.学习"></a>7.学习</h2><ol>
<li>本文基本上整体复制过来了，学习新知识的方法和对问题的尝试方法很值得学习；</li>
<li>后续需要把spring boot+mybatis教程，整理一下；</li>
<li>mybatis plus相关知识整理出来。</li>
</ol>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 和 oracle 的不同</title>
    <url>/2019/11/07/mysql%20%E5%92%8C%20oracle%20%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>一、日期处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oracle查询当前日期：select to_char(sysdate,&#x27;yyyy-mm-dd&#x27;) from dual;</span><br><span class="line"></span><br><span class="line">mysql查询当前日期：select date_format(now(),&#x27;%Y-%m-%d&#x27;); </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>二、连接字符串在 Oracle 中用 || ,SqlServer 中用 +,MySQL 中用 concat (‘a’,’b’,’c’)</p>
<p>三、mysql 与 oracle 数据库实现自增列的区别：</p>
<p>​        mysql 可以实现自增列，只要在建表时设置 auto_increment 即可，而 oracle 在建表时不能设置自增列功能，必须通过 sequence 序列来实现自增列功能。</p>
<p>四、mysql 与 oracle 数据库索引的区别：</p>
<p>​        在整个数据库内，mysql 的索引可以同名，也就是说 mysql 的索引是表级别的；但是 Oracle 索引不可以同名，也就是说 Oracle 的索引是数据库级别的；</p>
<p>​        mysql 的索引是从 0 开始，oracle 的索引是从 1 开始。</p>
<p>五、翻页的 SQL 语句的处理</p>
<p>​        MYSQL 处理翻页的 SQL 语句比较简单，用 LIMIT 开始位置，记录个数； ORACLE 处理翻页的 SQL 语句就比较繁琐了。每个结果集只有一个 ROWNUM 字段标明它的位置，并且只能用 ROWNUM&lt;100，不能用 ROWNUM&gt;80。</p>
<p>六、组函数用法规则</p>
<p>​        mysql 中组函数在 select 语句中可以随意使用，但在 oracle 中如果查询语句中有组函数，那其他列名必须是组函数处理过的，或者是 group by 子句中的列否则报错</p>
<p>eg：select name,count (money) from user；这个放在 mysql 中没有问题在 oracle 中就有问题了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的慢查询实战+sql优化</title>
    <url>/2019/11/07/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="添加联合索引"><a href="#添加联合索引" class="headerlink" title="添加联合索引"></a>添加联合索引</h3><span id="more"></span>

<p>步骤 1：设置慢查询日志的超时时间，先查看日志存放路径查询慢日志的地址，因为有慢查询的内容，就会到这个日志中：**</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%slow%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911091505125-1251268363.png" alt="img"></p>
<p><strong>2. 开启慢查询日志</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="keyword">on</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3. 查看慢查询日志的设置时间，是否是自己需要的</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%long%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911091628719-2024259645.png" alt="img"></p>
<p><strong>4. 如果不是自己想的时间，修改慢查询时间，只要超过了以下的设置时间，查询的日志就会到刚刚的日志中，我设置查询时间超过 1S 就进入到慢查询日志中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global long_query_time=1;</span><br></pre></td></tr></table></figure>

<p><strong>5. 大数据已准备，进行数据的查询，xshell 最好开两个窗口，一个查看日志，一个执行内容</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sql</span>查询语句：<span class="keyword">select</span> sql_no_cache <span class="operator">*</span> <span class="keyword">from</span> employees_tmp  <span class="keyword">where</span> first_name<span class="operator">=</span><span class="string">&#x27;Duangkaew&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911091808063-2118828478.png" alt="img"></p>
<p>发现查数据的总时间去掉了 17.74S</p>
<p>查看日志：打开日志</p>
<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911091818469-1674592350.png" alt="img"></p>
<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911091825313-1258998271.png" alt="img"></p>
<p>标记 1：执行的 sql 语句</p>
<p>标记 2：执行 sql 的时间，我的是 10 点 52 执行的</p>
<p>标记 3：使用那台机器</p>
<p>标记 4：执行时间，query_tims, 查询数据的时间</p>
<p>标记 5：不知道是干嘛的</p>
<p>标记 6：执行耗时的 sql 语句，我在想我 1 的应该是截取错了！但是记住最后一定是显示耗时是因为执行什么 sql 造成的</p>
<p><strong>6. 执行打印计划，主要是查看是否使用了索引等其他内容，主要就是在 sql 前面加上 explain 关键字</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> sql_no_cache <span class="operator">*</span> <span class="keyword">from</span> employees_tmp   <span class="keyword">where</span> first_name<span class="operator">=</span><span class="string">&#x27;Duangkaew&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911091922344-782506845.png" alt="img"></p>
<p>描述 extra 中，表示只使用了 where 条件，没有其他什么索引之类的</p>
<p><strong>7. 进行 sql 优化，建一个 fist_name 的索引，索引就是将你需要的数据先给筛选出来，这样就可以节省很多扫描时间</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index firstname <span class="keyword">on</span> employees_tmp(first_name);</span><br></pre></td></tr></table></figure>

<p> <img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911092029328-1258737592.png" alt="img"></p>
<p>注：创建索引时会很慢，是对整个表做了一个复制功能，并进行数据的一些分类（我猜是这样，所以会很慢）</p>
<p><strong>8. 查看建立的索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> employees_tmp;</span><br></pre></td></tr></table></figure>

<p> <img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911092321375-43120820.png" alt="img"></p>
<p><strong>9. 在执行查询语句，查看语句的执行时间</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache <span class="operator">*</span> <span class="keyword">from</span> employees_tmp  <span class="keyword">where</span> first_name<span class="operator">=</span><span class="string">&#x27;Duangkaew&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911092332735-173299286.png" alt="img"></p>
<p>  发现时间已经有所提升了，其实选择索引也不一开始就知道，我们在试试使用性别，gender 进行索引</p>
<p><strong>10. 删除已经有的索引，删除索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index first_name <span class="keyword">on</span> employees_tmp;</span><br></pre></td></tr></table></figure>

<p><strong>11. 创建性别的索引 (性别是不怎么好的索引方式，因为有很多重复数据)</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index index_gendar <span class="keyword">on</span> employees_tmp(gender);</span><br></pre></td></tr></table></figure>

<p>在执行 sql 语句查询数据，查看查询执行时间，没有创建比较优秀的索引，导致查询时间还变长了，</p>
<p>为嘛还变长了，这个我没有弄懂</p>
<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911092543938-1365857481.png" alt="img"></p>
<p><strong>12. 我们在试试使用创建组合索引，使用性别和姓名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  employees_tmp  <span class="keyword">add</span> index idx_union (first_name,gender);</span><br></pre></td></tr></table></figure>

<p>在执行 sql 查看 sql 数据的执行时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache <span class="operator">*</span> <span class="keyword">from</span> employees_tmp  <span class="keyword">where</span> first_name<span class="operator">=</span><span class="string">&#x27;Duangkaew&#x27;</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span></span><br></pre></td></tr></table></figure>

<p>速度提升了 N 多倍啊</p>
<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911092648172-303876790.png" alt="img"></p>
<p>查看创建的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> employees_tmp;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/597371-20170911092638313-1835845893.png" alt="img"></p>
<p>索引建的好真的一个好帮手，建不好就是费时的一个操作</p>
<p> 目前还不知道为什么建立性别的索引会这么慢</p>
<p>速度慢的原因猜测：<img src="/images/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%AE%9E%E6%88%98-sql%E4%BC%98%E5%8C%96/1573109486260.png" alt="1573109486260"></p>
<p> where后面是要把过滤后剩下数据量比较少的放到右侧，查询顺序是一个从下到上的过程</p>
<p><a href="https://www.cnblogs.com/chongyou/p/7503463.html">参考</a></p>
]]></content>
      <categories>
        <category>sql优化</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>redis常用命令</title>
    <url>/2019/10/16/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="有序集合：ZSET"><a href="#有序集合：ZSET" class="headerlink" title="有序集合：ZSET"></a>有序集合：ZSET</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>：字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</p>
<span id="more"></span>

<h3 id="2、ZremrangeByRank"><a href="#2、ZremrangeByRank" class="headerlink" title="2、ZremrangeByRank"></a>2、ZremrangeByRank</h3><p>（ 按 <code>score</code> 值递减(从大到小)来排列 ，zrange为从小到大）</p>
<p><img src="/images/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1571315340246.png" alt="1571315340246"></p>
<p><img src="/images/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1571315354587.png" alt="1571315354587"></p>
<p>ZSET顺序：0,1,2.。。。（根据score从上到下）</p>
<p>例子：conn.zremrangeByRank(key，0,1)，删除最上边分值的两个</p>
<p>​            conn.zremrangeByRank(key，0,-26)，</p>
<p>​            分析：-1是最后一个，也就是分值最大的一个，-26是分值最大的后25个，如果按时间计算，就是</p>
<p>总之就是从零开始就是从上到下，负的就是从下往上进行删除。返回删除的数量。 </p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis知识整理</title>
    <url>/2019/11/13/redis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="分布式缓存技术-redis-系列（一）——redis-简介以及-linux-上的安装"><a href="#分布式缓存技术-redis-系列（一）——redis-简介以及-linux-上的安装" class="headerlink" title="分布式缓存技术 redis 系列（一）——redis 简介以及 linux 上的安装"></a><a href="https://www.cnblogs.com/hjwublog/p/5637150.html">分布式缓存技术 redis 系列（一）——redis 简介以及 linux 上的安装</a></h3><span id="more"></span>

<p><img src="/images/redis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573635894305.png" alt="1573635894305"></p>
<h3 id="分布式缓存技术-redis-系列（二）——-详细讲解-redis-数据结构（内存模型）以及常用命令"><a href="#分布式缓存技术-redis-系列（二）——-详细讲解-redis-数据结构（内存模型）以及常用命令" class="headerlink" title="分布式缓存技术 redis 系列（二）—— 详细讲解 redis 数据结构（内存模型）以及常用命令"></a><a href="https://www.cnblogs.com/hjwublog/p/5639990.html">分布式缓存技术 redis 系列（二）—— 详细讲解 redis 数据结构（内存模型）以及常用命令</a></h3><p><img src="/images/redis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573635917829.png" alt="1573635917829"></p>
<h3 id="分布式缓存技术-redis-系列（三）——redis-高级应用（主从、事务与锁、持久化）"><a href="#分布式缓存技术-redis-系列（三）——redis-高级应用（主从、事务与锁、持久化）" class="headerlink" title="分布式缓存技术 redis 系列（三）——redis 高级应用（主从、事务与锁、持久化）"></a><a href="https://www.cnblogs.com/hjwublog/p/5660578.html">分布式缓存技术 redis 系列（三）——redis 高级应用（主从、事务与锁、持久化）</a></h3><p><img src="/images/redis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573635954475.png" alt="1573635954475"></p>
<h3 id="分布式缓存技术-redis-系列（四-redis-高级应用（集群搭建、集群分区原理、集群操作）"><a href="#分布式缓存技术-redis-系列（四-redis-高级应用（集群搭建、集群分区原理、集群操作）" class="headerlink" title="分布式缓存技术 redis 系列（四 -redis 高级应用（集群搭建、集群分区原理、集群操作）"></a><a href="https://www.cnblogs.com/hjwublog/p/5681700.html">分布式缓存技术 redis 系列（四 -redis 高级应用（集群搭建、集群分区原理、集群操作）</a></h3><p><img src="/images/redis%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1573635982490.png" alt="1573635982490"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis锁</title>
    <url>/2019/12/13/redis%E9%94%81/</url>
    <content><![CDATA[<h3 id="redis锁机制"><a href="#redis锁机制" class="headerlink" title="redis锁机制"></a>redis锁机制</h3>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>request.getQueryParams()不能获取@PathVariable参数</title>
    <url>/2019/09/26/request-getQueryParams-%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%8F%96-PathVariable%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>​    应用接口无权限导致的</p>
]]></content>
      <tags>
        <tag>PathVariable</tag>
        <tag>ServerHttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title>session与cookie状态传递</title>
    <url>/2019/11/12/session%E4%B8%8Ecookie%E7%8A%B6%E6%80%81%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>浏览器请求服务器是无状态的。无状态指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。</p>
<span id="more"></span>

<p>无状态的应用层面的原因是：浏览器和服务器之间的通信都遵守 HTTP 协议。根本原因是：浏览器与服务器是使用 Socket 套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的 Socket 连接，而且服务器也会在处理页面完毕之后销毁页面对象。</p>
<p>有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等。 实现状态保持主要有两种方式：</p>
<ul>
<li>在客户端存储信息使用 Cookie。</li>
<li>在服务器端存储信息使用 Session。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><img src="/images/session与cookie状态传递/20170628181201440.png" alt="img" style="zoom:80%;" />



<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie 最早是网景公司的前雇员 Lou Montulli 在 1993 年 3 月的发明。</p>
<p>Cookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie）。</p>
<p>Cookie 名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。服务器可以利用 Cookies 包含信息的任意性来筛选并经常性维护这些信息，以判断在 HTTP 传输中的状态。</p>
<p>Cookies 最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是 Cookies 的功用。另一个重要应用场合是 “购物车” 之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入 Cookies，以便在最后付款时提取信息。</p>
<p>Cookie 是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</p>
<h3 id="Cookie-的特点"><a href="#Cookie-的特点" class="headerlink" title="Cookie 的特点"></a>Cookie 的特点</h3><ul>
<li>Cookie 以键值对的格式进行信息的存储。</li>
<li>Cookie 基于域名安全，不同域名的 Cookie 是不能互相访问的，如访问 baidu.com 时向浏览器中写了 Cookie 信息，使用同一浏览器访问 baidu.com 时，无法访问到 baidu.com 写的 Cookie 信息。</li>
<li>当浏览器请求某网站时，会将本网站下所有 Cookie 信息提交给服务器。</li>
</ul>
<h3 id="典型应用：记住用户名，网站的广告推送。"><a href="#典型应用：记住用户名，网站的广告推送。" class="headerlink" title="典型应用：记住用户名，网站的广告推送。"></a>典型应用：记住用户名，网站的广告推送。</h3><p>说明：广告推送的商品是基于你曾经在淘宝上点击的商品类别等条件筛选出来的，看上去这是在京东上访问淘宝网的 Cookie，但是事实不是这样的，一般是采用 iframe 标签嵌套一个淘宝的广告页面到京东网的页面上，所以淘宝的 Cookie 并没有被京东网读取到，而是依然交给淘宝网读取的，可以通过 “开发者工具” 查看元素。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/images/session%E4%B8%8Ecookie%E7%8A%B6%E6%80%81%E4%BC%A0%E9%80%92/20170628181250457.png" alt="img"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>对于敏感、重要的信息，建议要储在服务器端，不能存储在浏览器中，如用户名、余额、等级、验证码等信息。<br>在服务器端进行状态保持的方案就是 Session。</p>
<h3 id="启用和禁用-Session"><a href="#启用和禁用-Session" class="headerlink" title="启用和禁用 Session"></a>启用和禁用 Session</h3><ul>
<li>Django 项目默认启用 Session。</li>
<li>禁用 Session：将 Session 中间件删除。</li>
</ul>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">MIDDLEWARE_CLASSES = (</span></span><br><span class="line"><span class="xml">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure>

<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>打开项目的 settings.py 文件，设置 SESSION_ENGINE 项指定 Session 数据存储的方式，可以存储在数据库、缓存、Redis 等。</p>
<ul>
<li>\1. 存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。注意使用数据库存储，需要在项目 INSTALLED_APPS 中安装 Session 应用。然后执行迁移，才会在数据库中生成 session 表</li>
</ul>
<p>SESSION_ENGINE=’django.contrib.sessions.backends.db’</p>
<ul>
<li>\2. 存储在缓存中：存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</li>
</ul>
<p>SESSION_ENGINE=’django.contrib.sessions.backends.cache’</p>
<ul>
<li>\3. 混合存储：优先从本机内存中存取，如果没有则从数据库中存取。</li>
</ul>
<p>SESSION_ENGINE=’django.contrib.sessions.backends.cached_db’</p>
<h3 id="依赖于-Cookie"><a href="#依赖于-Cookie" class="headerlink" title="依赖于 Cookie"></a>依赖于 Cookie</h3><p>所有请求者的 Session 都会存储在服务器中，服务器如何区分请求者和 Session 数据的对应关系呢？<br>答：在使用 Session 后，会在 Cookie 中存储一个 sessionid 的数据，每次请求时浏览器都会将这个数据发给服务器，服务器在接收到 sessionid 后，会根据这个值找出这个请求者的 Session。</p>
<p>结果：如果想使用 Session，浏览器必须支持 Cookie，否则就无法使用 Session 了。</p>
<p>存储 Session 时，键与 Cookie 中的 sessionid 相同，值是开发人员设置的键值对信息，进行了 base64 编码，过期时间由开发人员设置。</p>
<h3 id="session-对象及方法操作"><a href="#session-对象及方法操作" class="headerlink" title="session 对象及方法操作"></a>session 对象及方法操作</h3><p>通过 HttpRequest 对象的 Session 属性进行会话的读写操作。</p>
<ul>
<li>1 以键值对的格式写会话。</li>
</ul>
<p>request.session [‘键’]= 值</p>
<ul>
<li>\2. 根据键读取值。</li>
</ul>
<p>request.session.get (‘键’, 默认值)</p>
<ul>
<li>\3. 清除所有会话，在存储中删除值部分，保留键。</li>
</ul>
<p>request.session.clear()</p>
<ul>
<li>\4. 清除会话数据，在存储中删除会话的整条数据。</li>
</ul>
<p>request.session.flush()</p>
<ul>
<li>\5. 删除会话中的指定键及值，在存储中只删除某个键及对应的值。</li>
</ul>
<p>del request.session [‘键’]</p>
<ul>
<li>设置会话的超时时间，如果没有指定过期时间则两个星期后过期。</li>
<li>如果 value 是一个整数，会话将在 value 秒没有活动后过期。</li>
<li>如果 value 为 0，那么用户会话的 Cookie 将在用户的浏览器关闭时过期。</li>
<li>如果 value 为 None，那么会话永不过期。<br>request.session.set_expiry(value)</li>
</ul>
<h3 id="使用-Redis-存储-Session"><a href="#使用-Redis-存储-Session" class="headerlink" title="使用 Redis 存储 Session"></a>使用 Redis 存储 Session</h3><p>会话还支持文件、纯 cookie、Memcached、Redis 等方式存储，下面演示使用 redis 存储。</p>
<ul>
<li> 安装包。</li>
</ul>
<p>pip install django-redis-sessions</p>
<ul>
<li>修改项目 settings 文件，增加如下项：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置将session信息保存在redis数据库中</span><br><span class="line">SESSION_ENGINE = &#x27;redis_sessions.session&#x27; #讲session信息保存在redis数据库中</span><br><span class="line">SESSION_REDIS_HOST = &#x27;localhost&#x27; #redis数据库所在主机</span><br><span class="line">SESSION_REDIS_PORT = 6379 #redis数据库的端口号</span><br><span class="line">SESSION_REDIS_DB = 1 #使用哪个数据库</span><br><span class="line">SESSION_REDIS_PASSWORD = &#x27;&#x27; #密码</span><br><span class="line">SESSION_REDIS_PREFIX = &#x27;session&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li> 打开应用 app 下 views.py 文件，修改 session_test 视图如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def session_test(request):</span><br><span class="line">    request.session[&#x27;name&#x27;]=&#x27;xiaoke&#x27;</span><br><span class="line">    # name=request.session.get(&#x27;name&#x27;)</span><br><span class="line">    # del request.session[&#x27;name&#x27;]</span><br><span class="line">    # request.session.flush()</span><br><span class="line">    return HttpResponse(&#x27;成功&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>管理 redis 的命令，需要保证 redis 服务被开启。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看：ps ajx|grep redis</span><br><span class="line">启动：sudo service redis start</span><br><span class="line">停止：sudo service redis stop</span><br><span class="line">使用客户端连接服务器：redis-cli</span><br><span class="line">切换数据库：select 1</span><br><span class="line">查看所有的键：keys *</span><br><span class="line">获取指定键的值：get 键名</span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/u014745194/article/details/73854303">参考</a></p>
]]></content>
      <categories>
        <category>登录</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro常见面试题</title>
    <url>/2019/11/09/shiro%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="shiro教程"><a href="#shiro教程" class="headerlink" title="shiro教程"></a>shiro教程</h3><p><a href="http://wiki.jikexueyuan.com/project/shiro/cache-mechanism.html">极客学院完整shiro教程</a> （版本是1.2.2,太老了，并且1.2.4以后还有漏洞，安全扫面不会通过）</p>
<span id="more"></span>

<p><img src="/images/shiro%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/1573279654126.png" alt="1573279654126"></p>
<h3 id="shiro常见面试题"><a href="#shiro常见面试题" class="headerlink" title="shiro常见面试题"></a>shiro常见面试题</h3><h4 id="Shiro-的优点"><a href="#Shiro-的优点" class="headerlink" title="Shiro 的优点"></a>Shiro 的优点</h4><blockquote>
<p> 简单的身份认证，支持多种数据源<br>对角色的简单的授权，支持细粒度的授权 (方法级)<br>支持一级缓存，以提升应用程序的性能；<br>内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境<br>非常简单的加密 API<br>不跟任何的框架或者容器捆绑，可以独立运行 </p>
</blockquote>
<h4 id="Shiro-架构-核心组件"><a href="#Shiro-架构-核心组件" class="headerlink" title="Shiro 架构 核心组件:"></a>Shiro 架构 核心组件:</h4><blockquote>
<p>Authenticator: 管理登陆登出<br>Autorizer: 授权器赋予主体有那些权限<br>session Manager：shiro 自己实现 session 管理器<br>session DAO：提供了 session 的增删改插<br>Cache Manager：缓冲管理器<br>Raelms：和数据库交互的桥梁</p>
</blockquote>
<h4 id="shiro-认证过程"><a href="#shiro-认证过程" class="headerlink" title="shiro 认证过程"></a>shiro 认证过程</h4><p> 创建 SecurityManager -&gt; 主体提交认证 -&gt; SecurityManager 认证 -&gt; Authenticator 认证 -&gt; Realm 验证 </p>
<h4 id="shiro-授权过程"><a href="#shiro-授权过程" class="headerlink" title="shiro 授权过程"></a>shiro 授权过程</h4><p> 创建 SecurityManager -&gt; 主体授权 -&gt; securityManager 授权 -&gt; Authorizer 授权 -&gt;Realm 获取权限数据 </p>
<h3 id="简单介绍一下-Shiro-框架"><a href="#简单介绍一下-Shiro-框架" class="headerlink" title="简单介绍一下 Shiro 框架"></a>简单介绍一下 Shiro 框架</h3><p>Apache Shiro 是 Java 的一个安全框架。使用 shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p>
<p>三个核心组件：Subject, SecurityManager 和 Realms.</p>
<p>Subject：即 “当前操作用户”。但是，在 Shiro 中，Subject 这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着 “当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是 Shiro 的 “用户” 概念。<br>Subject 代表了当前用户的安全操作，SecurityManager 则管理所有用户的安全操作。</p>
<p>SecurityManager：它是 Shiro 框架的核心，典型的 Facade 模式，Shiro 通过 SecurityManager 来管理内部组件实例，并通过它来提供安全管理的各种服务。</p>
<p>Realm： Realm 充当了 Shiro 与应用安全数据间的 “桥梁” 或者 “连接器”。也就是说，当对用户执行认证（登<br>录）和授权（访问控制）验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。</p>
<h3 id="Shiro-主要的四个组件"><a href="#Shiro-主要的四个组件" class="headerlink" title="Shiro 主要的四个组件"></a>Shiro 主要的四个组件</h3><p>1）SecurityManager<br>典型的 Facade，Shiro 通过它对外提供安全管理的各种服务。</p>
<p>2）Authenticator<br>对 “Who are you ？” 进行核实。通常涉及用户名和密码。 这个组件负责收集 principals 和 credentials，并将它们提交给应用系统。如果提交的 credentials 跟应用系统中提供的 credentials 吻合，就能够继续访问，否则需要重新提交 principals 和 credentials， 或者直接终止访问。</p>
<p>3）Authorizer<br>身份份验证通过后，由这个组件对登录人员进行访问控制的筛查，比如 “who can do what”， 或者 “who can do which actions”。 Shiro 采用 “基于 Realm” 的方法，即用户（又称 Subject）、 用户组、角 色和 permission 的聚合体。</p>
<p>4）Session Manager<br>这个组件保证了异构客户端的访问，配置简单。它是基于 POJO/J2SE 的，不跟任何的客户 端或者协议绑定。</p>
<h3 id="Shiro-运行原理"><a href="#Shiro-运行原理" class="headerlink" title="Shiro 运行原理"></a>Shiro 运行原理</h3><p>1、Application Code: 应用程序代码，就是我们自己的编码，如果在程序中需要进 行权限控制，需要调用 Subject 的 API。</p>
<p>2、Subject: 主体，代表的了当前用户。所有的 Subject 都绑定到 SecurityManager， 与 Subject 的所有交互都会委托给 SecurityManager, 可以将 Subject 当成一个 门面，而真正执行者是 SecurityManager 。</p>
<p>3、SecurityManage: 安全管理器，所有与安全有关的操作都会与 SecurityManager 交互，并且它管理所有的 Subject 。</p>
<p>4、Realm: 域 shiro 是从 Realm 来获取安全数据（用户，角色，权限）。就是说 SecurityManager 要验证用户身份， 那么它需要从 Realm 获取相应的用户进行比较以确定用户 身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否 能进行操作； 可以把 Realm 看成 DataSource，即安全数据源 。</p>
<h3 id="Shiro-的四种权限控制方式"><a href="#Shiro-的四种权限控制方式" class="headerlink" title="Shiro 的四种权限控制方式"></a>Shiro 的四种权限控制方式</h3><p>1）在自定义的 realm 中进行权限控制<br>在 applicationContext.xml 文件中添加 /areaAction_pageQuery.action = perms [“area”]</p>
<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
    <!-- 注入shiro框架核心对象，安全管理器 -->
    <property name="securityManager" ref="securityManager"/>
    <!--private String loginUrl;登录页面
        private String successUrl;登录成功后跳转页面
        private String unauthorizedUrl;权限不足时的提示页面-->
    <property name="loginUrl" value="/login.html"/>
    <property name="successUrl" value="/index.html"/>
    <property name="unauthorizedUrl" value="/unauthorized.html"/>
    <!-- 指定URL拦截规则 -->
    <property name="filterChainDefinitions">
    <!--authc:代表shiro框架提供的一个过滤器，这个过滤器用于判断当前用户是否已经完成认证，
        如果当前用户已经认证，就放行，如果当前用户没有认证，跳转到登录页面
        anon:代表shiro框架提供的一个过滤器，允许匿名访问-->
        <value>
            /css/* = anon
            /images/* = anon
            /js/** = anon
            /validatecode.jsp* = anon
            /userAction_login.action = anon
            /areaAction_pageQuery.action = perms["area"]
            /** = authc
        </value>
    </property>
</bean>
此时访问 areaAction_pageQuery.action 是页面不会查询到数据，须要为用户授权

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection arg0)</span> </span>&#123;</span><br><span class="line">    SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">    <span class="comment">//为用户授权,只需将用户的权限添加info中即可</span></span><br><span class="line">    info.addStringPermission(<span class="string">&quot;area&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line">在自定义 realm 中为用户授权</span><br></pre></td></tr></table></figure>
<p>2）使用 shiro 注解为用户授权</p>
<ol>
<li><p>在 spring 配置文件 applicationContext.xml 中配置开启 shiro 注解支持</p>
 <!-- 基于spring自动代理方式为service创建代理对象,实现权限控制 -->
 <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator">
     <!-- 强制使用cglibdaili -->
     <property name="proxyTargetClass" value="true"></property>
 </bean>
 <!-- 配置切面 -->
 <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
     <property name="securityManager" ref="securityManager"></property>
 </bean></li>
<li><p>配置事物注解，强制使用 cglib 代理</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>在 service 上配置注解</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions(&quot;courier:delete&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBatch</span><span class="params">(String ids)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNoneBlank(ids))&#123;</span><br><span class="line">        String[] idsArrays = ids.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String id : idsArrays) &#123;</span><br><span class="line">            Integer courierid = Integer.parseInt(id);</span><br><span class="line">            dao.deleteCourier(courierid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3）使用 shiro 标签进行权限控制</span><br><span class="line"></span><br><span class="line">4. 在 jsp 页面中引入 shiro 标签库</span><br><span class="line"></span><br><span class="line">​```xml</span><br><span class="line">&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在页面中使用标签</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;</span><br><span class="line">    pageEncoding=&quot;utf-8&quot;%&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br></pre></td></tr></table></figure>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
    <!-- 判断当前用户是否已经认证,已认证就可以看到标签中的内容 -->
    <shiro:authenticated>
        看到内容就说明你已经认证成功了!
    </shiro:authenticated>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 判断当前用户是否拥有指定的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;area&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;这是判断权限的按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 判断当前用户是否拥有指定的角色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;这是判断角色的按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4）编程方式实现用户权限控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">//有权限</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//无权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>授权实现的流程<br>（1）什么是粗颗粒和细颗粒权限？<br>对资源类型的管理称为粗颗粒度权限控制，即只控制到菜单、按钮、方法，粗粒度的例子比如：用户具有用户管理的权限，具有导出订单明细的权限。对资源实例的控制称为细颗粒度权限管理，即控制到数据级别的权限，比如：用户只允许修改本部门的员工信息，用户只允许导出自己创建的订单明细。</li>
</ol>
<p>总结：<br>粗颗粒权限：针对 url 链接的控制。<br>细颗粒权限：针对数据级别的控制。</p>
<p>比如：查询用户权限。<br>卫生局可以查询所有用户。<br>卫生室可以查询本单位的用户。</p>
<p>通常在 service 中编程实现。</p>
<p>（2）粗颗粒和细颗粒如何授权？<br>对于粗颗粒度的授权可以很容易做系统架构级别的功能，即系统功能操作使用统一的粗颗粒度的权限管理。</p>
<p>对于细颗粒度的授权不建议做成系统架构级别的功能，因为对数据级别的控制是系统的业务需求，随着业务需求的变更业务功能变化的可能性很大，建议对数据级别的权限控制在业务层个性化开发，比如：用户只允许修改自己创建的商品信息可以在 service 接口添加校验实现，service 接口需要传入当前操作人的标识，与商品信息创建人标识对比，不一致则不允许修改商品信息。</p>
<p>粗颗粒权限：可以使用过虑器统一拦截 url。<br>细颗粒权限：在 service 中控制，在程序级别来控制，个性化编程。</p>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot 刚启动容器中找不到service</title>
    <url>/2019/09/26/spring%20boot%E5%88%9A%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%89%BE%E4%B8%8D%E5%88%B0service/</url>
    <content><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>​        重写ApplicationListener，在方法中通过@Autowired引入容器中的bean（导致空指针），用@Value获取配置文件中的值（输出为null）。@Value(“${appMode}”)，引入配置文件也是空的，所以才一直都没有报错</p>
<span id="more"></span>

<p>![1569472576120](/images/spring boot刚启动容器中找不到service/1569472576120.png)</p>
<h3 id="2-问题解决"><a href="#2-问题解决" class="headerlink" title="2.问题解决"></a>2.问题解决</h3><ol>
<li>event里获得springContent</li>
<li>从ApplicationContext里获得analysisService跟appMode</li>
</ol>
<p>![1569493180816](/images/spring boot刚启动容器中找不到service/1569493180816.png)</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>sql developer修改时间戳和日期显示格式</title>
    <url>/2019/10/01/sql%20developer%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E6%88%B3%E5%92%8C%E6%97%A5%E6%9C%9F%E6%98%BE%E7%A4%BA%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1、问题："><a href="#1、问题：" class="headerlink" title="1、问题："></a>1、问题：</h2><p>修改sql developer日期和时间戳显示格式：</p>
<span id="more"></span>

<p>![1571121901457](/images/sql developer修改时间戳和日期显示格式/1571121901457.png)</p>
<h2 id="2：解决："><a href="#2：解决：" class="headerlink" title="2：解决："></a>2：解决：</h2><p>工具–&gt;首选项–&gt;数据库–&gt;NLS：</p>
<p>![1571121951435](/images/sql developer修改时间戳和日期显示格式/1571121951435.png)</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>sql练习</title>
    <url>/2019/10/29/sql%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、常见sql学习"><a href="#一、常见sql学习" class="headerlink" title="一、常见sql学习"></a>一、常见sql学习</h2><span id="more"></span>

<h3 id="1、表联结关系"><a href="#1、表联结关系" class="headerlink" title="1、表联结关系"></a>1、表联结关系</h3><p><img src="/images/sql%E7%BB%83%E4%B9%A0/1572353035276.png" alt="1572353035276"></p>
<h3 id="2、建表及插入数据"><a href="#2、建表及插入数据" class="headerlink" title="2、建表及插入数据"></a>2、建表及插入数据</h3><ol>
<li><p>建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="type">int</span>,</span><br><span class="line">LastName <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">FirstName <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p> data_type 常见数据类型：</p>
</li>
</ol>
<p>   <img src="/images/sql%E7%BB%83%E4%B9%A0/1572353303779.png" alt="1572353303779"></p>
<ol start="3">
<li>插入数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(课程号,课程名称,教师号)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;0001&#x27;</span> , <span class="string">&#x27;语文&#x27;</span> , <span class="string">&#x27;0002&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3、简单查询"><a href="#3、简单查询" class="headerlink" title="3、简单查询"></a>3、简单查询</h3><p><img src="/images/sql%E7%BB%83%E4%B9%A0/1572354172543.png" alt="1572354172543"></p>
<p> <img src="/images/sql%E7%BB%83%E4%B9%A0/v2-74404bfe16150f5a9f4a473297e1e079_hd.jpg" alt="img"> </p>
<h3 id="4、汇总分析"><a href="#4、汇总分析" class="headerlink" title="4、汇总分析"></a>4、汇总分析</h3><ol>
<li>面试题：查询课程编号为“0002”的总成绩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [总成绩:汇总函数sum]</span><br><span class="line">from 从哪张表中查找数据[成绩表score]</span><br><span class="line">where 查询条件 [课程号是0002]</span><br><span class="line">*/</span><br><span class="line">select sum(成绩)</span><br><span class="line">from score</span><br><span class="line">where 课程号 = &#x27;0002&#x27;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询选了课程的学生人数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个题目翻译成大白话就是：查询有多少人选了课程</span><br><span class="line">select 学号，成绩表里学号有重复值需要去掉</span><br><span class="line">from 从课程表查找score;</span><br><span class="line">*/</span><br><span class="line">select count(distinct 学号) as 学生人数 </span><br><span class="line">from score;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 查询各科成绩最高和最低的分 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [课程ID：是课程号的别名,最高分：max(成绩) ,最低分：min(成绩)]</span><br><span class="line">from 从哪张表中查找数据 [成绩表score]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [各科成绩：也就是每门课程的成绩，需要按课程号分组];</span><br><span class="line">*/</span><br><span class="line">select 课程号,max(成绩) as 最高分,min(成绩) as 最低分</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li> 查询每门课程被选修的学生数 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [课程号，选修该课程的学生数：汇总函数count]</span><br><span class="line">from 从哪张表中查找数据 [成绩表score]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [每门课程：按课程号分组];</span><br><span class="line">*/</span><br><span class="line">select 课程号, count(学号)</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li> 查询男生、女生人数 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [性别，对应性别的人数：汇总函数count]</span><br><span class="line">from 从哪张表中查找数据 [性别在学生表中，所以查找的是学生表student]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [男生、女生人数：按性别分组]</span><br><span class="line">having 对分组结果指定条件 [没有]</span><br><span class="line">order by 对查询结果排序[没有];</span><br><span class="line">*/</span><br><span class="line">select 性别,count(*)</span><br><span class="line">from student</span><br><span class="line">group by 性别;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li> 查询平均成绩大于60分学生的学号和平均成绩 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">题目翻译成大白话：</span><br><span class="line">平均成绩：展开来说就是计算每个学生的平均成绩</span><br><span class="line">这里涉及到“每个”就是要分组了</span><br><span class="line">平均成绩大于60分，就是对分组结果指定条件</span><br><span class="line"></span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [学号，平均成绩：汇总函数avg(成绩)]</span><br><span class="line">from 从哪张表中查找数据 [成绩在成绩表中，所以查找的是成绩表score]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [平均成绩：先按学号分组，再计算平均成绩]</span><br><span class="line">having 对分组结果指定条件 [平均成绩大于60分]</span><br><span class="line">*/</span><br><span class="line">select 学号, avg(成绩)</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having avg(成绩)&gt;60;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li> 查询至少选修两门课程的学生学号 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">翻译成大白话：</span><br><span class="line">第1步，需要先计算出每个学生选修的课程数据，需要按学号分组</span><br><span class="line">第2步，至少选修两门课程：也就是每个学生选修课程数目&gt;=2，对分组结果指定条件</span><br><span class="line"></span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [学号,每个学生选修课程数目：汇总函数count]</span><br><span class="line">from 从哪张表中查找数据 [课程的学生学号：课程表score]</span><br><span class="line">where 查询条件 [至少选修两门课程：需要先计算出每个学生选修了多少门课，需要用分组，所以这里没有where子句]</span><br><span class="line">group by 分组 [每个学生选修课程数目：按课程号分组，然后用汇总函数count计算出选修了多少门课]</span><br><span class="line">having 对分组结果指定条件 [至少选修两门课程：每个学生选修课程数目&gt;=2]</span><br><span class="line">*/</span><br><span class="line">select 学号, count(课程号) as 选修课程数目</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;=2;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li> 查询同名同性学生名单并统计同名人数 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">翻译成大白话，问题解析：</span><br><span class="line">1）查找出姓名相同的学生有谁，每个姓名相同学生的人数</span><br><span class="line">查询结果：姓名,人数</span><br><span class="line">条件：怎么算姓名相同？按姓名分组后人数大于等于2，因为同名的人数大于等于2</span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [姓名,人数：汇总函数count(*)]</span><br><span class="line">from 从哪张表中查找数据 [学生表student]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [姓名相同：按姓名分组]</span><br><span class="line">having 对分组结果指定条件 [姓名相同：count(*)&gt;=2]</span><br><span class="line">order by 对查询结果排序[没有];</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">select 姓名,count(*) as 人数</span><br><span class="line">from student</span><br><span class="line">group by 姓名</span><br><span class="line">having count(*)&gt;=2;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li> 查询不及格的课程并按课程号从大到小排列 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [课程号]</span><br><span class="line">from 从哪张表中查找数据 [成绩表score]</span><br><span class="line">where 查询条件 [不及格：成绩 &lt;60]</span><br><span class="line">group by 分组 [没有]</span><br><span class="line">having 对分组结果指定条件 [没有]</span><br><span class="line">order by 对查询结果排序[课程号从大到小排列：降序desc];</span><br><span class="line">*/</span><br><span class="line">select 课程号</span><br><span class="line">from score </span><br><span class="line">where 成绩&lt;60</span><br><span class="line">order by 课程号 desc;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li> 查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [课程号,平均成绩：汇总函数avg(成绩)]</span><br><span class="line">from 从哪张表中查找数据 [成绩表score]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [每门课程：按课程号分组]</span><br><span class="line">having 对分组结果指定条件 [没有]</span><br><span class="line">order by 对查询结果排序[按平均成绩升序排序:asc，平均成绩相同时，按课程号降序排列:desc];</span><br><span class="line">*/</span><br><span class="line">select 课程号, avg(成绩) as 平均成绩</span><br><span class="line">from score</span><br><span class="line">group by 课程号</span><br><span class="line">order by 平均成绩 asc,课程号 desc;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li> 检索课程编号为“0004”且分数小于60的学生学号，结果按按分数降序排列 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 []</span><br><span class="line">from 从哪张表中查找数据 [成绩表score]</span><br><span class="line">where 查询条件 [课程编号为“04”且分数小于60]</span><br><span class="line">group by 分组 [没有]</span><br><span class="line">having 对分组结果指定条件 []</span><br><span class="line">order by 对查询结果排序[查询结果按按分数降序排列];</span><br><span class="line">*/</span><br><span class="line">select 学号</span><br><span class="line">from score</span><br><span class="line">where 课程号=&#x27;04&#x27; and 成绩 &lt;60</span><br><span class="line">order by 成绩 desc;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><p>统计每门课程的学生选修人数(超过2人的课程才统计)</p>
<p>要求输出课程号和选修人数，查询结果按人数降序排序，若人数相同，按课程号升序排序</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">分析思路</span><br><span class="line">select 查询结果 [要求输出课程号和选修人数]</span><br><span class="line">from 从哪张表中查找数据 []</span><br><span class="line">where 查询条件 []</span><br><span class="line">group by 分组 [每门课程：按课程号分组]</span><br><span class="line">having 对分组结果指定条件 [学生选修人数(超过2人的课程才统计)：每门课程学生人数&gt;2]</span><br><span class="line">order by 对查询结果排序[查询结果按人数降序排序，若人数相同，按课程号升序排序];</span><br><span class="line">*/</span><br><span class="line">select 课程号, count(学号) as &#x27;选修人数&#x27;</span><br><span class="line">from score</span><br><span class="line">group by 课程号</span><br><span class="line">having count(学号)&gt;2</span><br><span class="line">order by count(学号) desc,课程号 asc;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li> 查询两门以上不及格课程的同学的学号及其平均成绩 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">分析思路</span><br><span class="line">先分解题目：</span><br><span class="line">1）[两门以上][不及格课程]限制条件</span><br><span class="line">2）[同学的学号及其平均成绩]，也就是每个学生的平均成绩，显示学号，平均成绩</span><br><span class="line">分析过程：</span><br><span class="line">第1步：得到每个学生的平均成绩，显示学号，平均成绩</span><br><span class="line">第2步：再加上限制条件：</span><br><span class="line">1）不及格课程</span><br><span class="line">2）两门以上[不及格课程]：课程数目&gt;2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">第1步：得到每个学生的平均成绩，显示学号，平均成绩</span><br><span class="line">select 查询结果 [学号,平均成绩：汇总函数avg(成绩)]</span><br><span class="line">from 从哪张表中查找数据 [涉及到成绩：成绩表score]</span><br><span class="line">where 查询条件 [没有]</span><br><span class="line">group by 分组 [每个学生的平均：按学号分组]</span><br><span class="line">having 对分组结果指定条件 [没有]</span><br><span class="line">order by 对查询结果排序[没有];</span><br><span class="line">*/</span><br><span class="line">select 学号, avg(成绩) as 平均成绩</span><br><span class="line">from score</span><br><span class="line">group by 学号;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">第2步：再加上限制条件：</span><br><span class="line">1）不及格课程</span><br><span class="line">2）两门以上[不及格课程]</span><br><span class="line">select 查询结果 [学号,平均成绩：汇总函数avg(成绩)]</span><br><span class="line">from 从哪张表中查找数据 [涉及到成绩：成绩表score]</span><br><span class="line">where 查询条件 [限制条件：不及格课程，平均成绩&lt;60]</span><br><span class="line">group by 分组 [每个学生的平均：按学号分组]</span><br><span class="line">having 对分组结果指定条件 [限制条件：课程数目&gt;2,汇总函数count(课程号)&gt;2]</span><br><span class="line">order by 对查询结果排序[没有];</span><br><span class="line">*/</span><br><span class="line">select 学号, avg(成绩) as 平均成绩</span><br><span class="line">from score</span><br><span class="line">where 成绩 &lt;60</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)&gt;=2;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li> 查询所有课程成绩小于60分学生的学号、姓名 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【知识点】子查询</span><br><span class="line"></span><br><span class="line">1.翻译成大白话</span><br><span class="line">1）查询结果：学生学号，姓名</span><br><span class="line">2）查询条件：所有课程成绩 &lt; 60 的学生，需要从成绩表里查找，用到子查询</span><br><span class="line"></span><br><span class="line">第1步，写子查询（所有课程成绩 &lt; 60 的学生）</span><br><span class="line">select 查询结果[学号]</span><br><span class="line">from 从哪张表中查找数据[成绩表：score]</span><br><span class="line">where 查询条件[成绩 &lt; 60]</span><br><span class="line">group by 分组[没有]</span><br><span class="line">having 对分组结果指定条件[没有]</span><br><span class="line">order by 对查询结果排序[没有]</span><br><span class="line">limit 从查询结果中取出指定行[没有];</span><br><span class="line"></span><br><span class="line">select 学号 </span><br><span class="line">from student</span><br><span class="line">where 成绩 &lt; 60;</span><br><span class="line"></span><br><span class="line">第2步，查询结果：学生学号，姓名，条件是前面1步查到的学号</span><br><span class="line"></span><br><span class="line">select 查询结果[学号,姓名]</span><br><span class="line">from 从哪张表中查找数据[学生表:student]</span><br><span class="line">where 查询条件[用到运算符in]</span><br><span class="line">group by 分组[没有]</span><br><span class="line">having 对分组结果指定条件[没有]</span><br><span class="line">order by 对查询结果排序[没有]</span><br><span class="line">limit 从查询结果中取出指定行[没有];</span><br><span class="line">*/</span><br><span class="line">select 学号,姓名</span><br><span class="line">from student</span><br><span class="line">where  学号 in (</span><br><span class="line">select 学号 </span><br><span class="line">from student</span><br><span class="line">where 成绩 &lt; 60</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="15">
<li> 查询没有学全所有课的学生的学号、姓名 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">查找出学号，条件：没有学全所有课，也就是该学生选修的课程数 &lt; 总的课程数</span><br><span class="line">【考察知识点】in，子查询</span><br><span class="line">*/</span><br><span class="line">select 学号,姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号 </span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号) &lt; (select count(课程号) from course)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="16">
<li> 查询出只选修了两门课程的全部学生的学号和姓名 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 学号,姓名</span><br><span class="line">from student</span><br><span class="line">where 学号 in(</span><br><span class="line">select 学号</span><br><span class="line">from score</span><br><span class="line">group by 学号</span><br><span class="line">having count(课程号)=2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="17">
<li> 1990年出生的学生名单 </li>
</ol>
<p>mysql 日期显示：<img src="/images/sql%E7%BB%83%E4%B9%A0/1572354768646.png" alt="1572354768646"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">查找1990年出生的学生名单</span><br><span class="line">学生表中出生日期列的类型是datetime</span><br><span class="line">*/</span><br><span class="line">select 学号,姓名 </span><br><span class="line">from student </span><br><span class="line">where year(出生日期)=1990; </span><br></pre></td></tr></table></figure>

<ol start="18">
<li> 查询各科成绩前两名的记录 </li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/MuxjlFV0gi1GydOrYfiSeQ">参考微信公众号</a></p>
<h3 id="5、多表查询"><a href="#5、多表查询" class="headerlink" title="5、多表查询"></a>5、多表查询</h3><ol>
<li> 查询所有学生的学号、姓名、选课数、总成绩 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.学号,a.姓名,count(b.课程号) as 选课数,sum(b.成绩) as 总成绩</span><br><span class="line">from student as a left join score as b</span><br><span class="line">on a.学号 = b.学号</span><br><span class="line">group by a.学号;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 查询平均成绩大于85的所有学生的学号、姓名和平均成绩 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.学号,a.姓名, avg(b.成绩) as 平均成绩</span><br><span class="line">from student as a left join score as b</span><br><span class="line">on a.学号 = b.学号</span><br><span class="line">group by a.学号</span><br><span class="line">having avg(b.成绩)&gt;85;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 查询学生的选课情况：学号，姓名，课程号，课程名称 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.学号, a.姓名, c.课程号,c.课程名称</span><br><span class="line">from student a inner join score b on a.学号=b.学号</span><br><span class="line">inner join course c on b.课程号=c.课程号;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li> 查询出每门课程的及格人数和不及格人数 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select 课程号,</span><br><span class="line">sum(case when 成绩&gt;=60 then 1 </span><br><span class="line">	 else 0 </span><br><span class="line">    end) as 及格人数,</span><br><span class="line">sum(case when 成绩 &lt;  60 then 1 </span><br><span class="line">	 else 0 </span><br><span class="line">    end) as 不及格人数</span><br><span class="line">from score</span><br><span class="line">group by 课程号;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li> 使用分段[100-85],[85-70],[70-60],[&lt;60]来统计各科成绩，分别统计：各分数段人数，课程号和课程名称 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 考察case表达式</span><br><span class="line">select a.课程号,b.课程名称,</span><br><span class="line">sum(case when 成绩 between 85 and 100 </span><br><span class="line">	 then 1 else 0 end) as &#x27;[100-85]&#x27;,</span><br><span class="line">sum(case when 成绩 &gt;=70 and 成绩&lt;85 </span><br><span class="line">	 then 1 else 0 end) as &#x27;[85-70]&#x27;,</span><br><span class="line">sum(case when 成绩&gt;=60 and 成绩&lt;70  </span><br><span class="line">	 then 1 else 0 end) as &#x27;[70-60]&#x27;,</span><br><span class="line">sum(case when 成绩&lt;60 then 1 else 0 end) as &#x27;[&lt;60]&#x27;</span><br><span class="line">from score as a right join course as b </span><br><span class="line">on a.课程号=b.课程号</span><br><span class="line">group by a.课程号,b.课程名称;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li> 查询课程编号为0003且课程成绩在80分以上的学生的学号和姓名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.学号,a.姓名</span><br><span class="line">from student  as a inner join score as b on a.学号=b.学号</span><br><span class="line">where b.课程号=&#x27;0003&#x27; and b.成绩&gt;80;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>行列转换</li>
</ol>
<p><img src="/images/sql%E7%BB%83%E4%B9%A0/1572355005805.png"></p>
<p><img src="/images/sql%E7%BB%83%E4%B9%A0/1572355013320.png" alt="1572355013320"></p>
<p><a href="https://mp.weixin.qq.com/s/6Kll4Q6Xp37i2PiLUh4cMA">参考</a></p>
<p>本文参考自：<a href="https://zhuanlan.zhihu.com/p/38354000">猴子</a>，方便以后随时查看。</p>
<h3 id="整理："><a href="#整理：" class="headerlink" title="整理："></a>整理：</h3><p><a href="https://www.cnblogs.com/qdhxhz/p/6433222.html">Oracle基本操作</a></p>
<p><a href="https://www.cnblogs.com/qdhxhz/p/6438938.html">多表查询</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>”、 、null、区别”</title>
    <url>/2020/03/25/%E2%80%9C%E2%80%9D%E3%80%81%E2%80%9C%20%E2%80%9D%EF%BC%8Cnull%E3%80%81%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="“”与null区别"><a href="#“”与null区别" class="headerlink" title="“”与null区别"></a>“”与null区别</h3><ol>
<li>对象为空是指对象为null，不是””</li>
<li>isBlank与isEmpty结果一样</li>
</ol>
<span id="more"></span>

<ol>
<li></li>
</ol>
<p>![image.png](/images/“”、“ ”，null、区别/1584934921144-9dbd24fd-24d7-4ee5-be68-c858e46d1472.png)</p>
<h3 id="空格的区别"><a href="#空格的区别" class="headerlink" title="空格的区别"></a>空格的区别</h3><ol>
<li>空格is not blank，but is empty</li>
</ol>
<p>![image.png](/images/“”、“ ”，null、区别/1584935116068-82dfa96c-5a69-47a7-9f0f-ef1f129c34aa.png)</p>
<p>![image.png](/images/“”、“ ”，null、区别/1584935488553-cd7a8215-3da7-4ccd-8329-cd5dc759c813.png)</p>
<p>![image.png](/images/“”、“ ”，null、区别/1584935570377-61c4fd2d-e8c7-4c0d-a2d6-e3f9630d4b96.png)</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>《唐家三少谈网文趋势》</title>
    <url>/2019/11/10/%E3%80%8A%E5%94%90%E5%AE%B6%E4%B8%89%E5%B0%91%E8%B0%88%E7%BD%91%E6%96%87%E8%B6%8B%E5%8A%BF%E3%80%8B/</url>
    <content><![CDATA[<p> <em>本帖最后由 云中仙客 于 2015-01-25 08:28 编辑</em> </p>
<p>今晚白菜群唐家三少和天堂雨两位白金大神的讲课终于整理完毕了，</p>
<span id="more"></span>

<p>下面贴出唐家三少的讲课共大家预览学习，话说，看在鄙人整理讲课到如此之晚的份上，龙币可以砸过来不？另外，白菜群所有大神的讲课密码暂时有鄙人负责，寻找白菜群 36 讲大神讲课的密码的，可以在白菜群私聊我索取，每次讲课密码都不同，发私聊时，说明要哪次讲课的密码，我如果在线就回复了，没在线，上线看到后会及时回复的，再说一下白菜群加群要求，主站要求均订两千，女频均订五百就可以了，把后台订阅截图发给魔一世长安审核，也可以把后台订阅截图和 qq 号码站内短信给我，不过，我很久才上一次龙空，可能不容易看到，主站两千均订，女频五百均订是群主规定的哦，别打我，下面上干货：</p>
<p><strong>唐家三少:</strong></p>
<p>　　我来了！正好今天任务写完了, 跟大家随便聊几句吧, 写作心得其实没什么, 我曾经在西南民族大学做宣讲的时候说过，坚持就是胜利，很简单的几个字，但想做到很难。</p>
<p>　　长期的创作，一定会如同程序一般，并不是说写作像程序，而是生活，只有规律的生活，才能保持稳定的创作，大家可能平时看到的更多的只是我的成绩，但你们看不到的，是我如同机器人一般的生活。</p>
<p>　　我给大家简单分享一下，早年，我刚开始创作的时候，那会儿还年轻也经常熬夜，经常到夜里 1、2 点，不过最多也就是 2 点左右了，持续了大概 3、4 年的时间身体就渐渐扛不住了，我刚开始写书那会儿，可以说是我创立了每天更新的。</p>
<p>　　那时候根本没人天天更新，所以我的创作量就特别大，我用的又是最差的输入法，连词都没有，每个字要单独敲，很累，我最多一年，大概是 2005 年，写了 400 多万字，没有词组的情况下，等到 2007 年、2008 年，身体就有点受不了了。</p>
<p><strong>天堂羽:</strong></p>
<p>　　我记得好像三少以前是用智能 ABC？</p>
<p><strong>唐家三少:</strong></p>
<p>　　是啊，是智能 ABC，连词组都没有，现在有搜狗，幸福多了，智能 ABC 还是两空格出字，所以右手大拇指总是疼的，后来有了女儿，我搬到了遥远的郊区开始改变生活状态，因为不改不行了，我身材高，身体负荷比一般人本来就大，最严重的时候，睡觉都翻不了身，严重的气滞血瘀、颈椎、腰椎、都有问题，我现在也还都有问题，有点僵直了，所以，奉劝大家，一定要有合理的写作时间，不要熬夜，一定要锻炼身体，我就不再继续忆苦思甜了。</p>
<p><strong>丛林狼：</strong></p>
<p>　　赞同，我就规律的生活，每天万字更新，晚上不码字，保证足够的休息时间，坚持了一年，现在也就成为习惯了。这在以前是不敢想象的，以前最多日更六千字，大部分时间日更三千字，勤奋／稳定更新是王道。</p>
<p><strong>唐家三少:</strong></p>
<p>　　说说我现在的时间安排，大家可以借鉴一下。</p>
<p><strong>天堂羽:</strong></p>
<p>　　去年多个作者噩耗，也不是一年爆发出来的，都是多年累积。</p>
<p>　　<strong>唐家三少:</strong></p>
<p>　　在不需要外出洽谈合作的情况下，我每天八点起床，然后喝杯水出去跑步，大概 30 分钟回来洗漱、吃早饭，9 点 30 开始写作，一直到 10 点 40，然后锻炼器械半小时，11 点 20 到 11 点 50 再写半小时，12 点午饭，13 点 15 午睡，14 点 30 起床继续码字，4 点去打羽毛球，5 点 20 继续码字，6 点 30 吃饭，晚上有时候写，有时候不写，一般不超过 9 点 30，然后放松一小时，上床看会儿书睡觉，一般会在 11 点左右睡觉，每天如此，重复不过，我一周一般会有 3 到 5 次出门谈事儿，所以不能保证每天都这样，但在家的时候就一定会这样。</p>
<p>　　假如晚上出去谈事儿，那么，白天的工作量就一定完成，每周给自己制定一个字数目标，严格完成，每年给自己制定一个目标，严格完成，每天有固定的一起写书的伙伴，刚才看天堂兄说到创新，创新现在确实是挺难得。</p>
<p><strong>天堂羽:</strong></p>
<p>　　是啊。</p>
<p><strong>丛林狼:</strong></p>
<p>　　晚上最好别码字，锻炼身体，看看和网文无关的其他书籍，放松放松，换换脑子，或者和朋友们喝酒聊天，对接现实，离开网络，和家人一起，健康生活，健康心态，才能写出健康的文。</p>
<p><strong>唐家三少:</strong></p>
<p>　　我天火算是创新了，而且前面其实写的特别累，每两千字就一个小桥段、小故事, 我自己觉得写的非常好, 但是，我会发现，读者年龄普遍小, 很多表示看不懂。</p>
<p>　　所以我不得不略微扭转原本的思路，我原本打算是要把生活品位课老师这个职业一直写下去，但出于人气考虑，必须要有变化，还是要往热血机甲上靠拢。</p>
<p>　　我做过调查，购买我们这一类实体书的读者，平均年龄是 11 到 14 岁，你们没想到吧！</p>
<p>　　要考虑读者的喜好和承受能力，我写的天火大道有关生活品位上的一些东西，想必大家都能看懂，但如果是十几岁的孩子，就有点困难了，尽管我已经写的很浅显。</p>
<p>　　这本书我是自己想写一些喜欢的东西，才会这样，如果是纯粹商业写作，我不会这么写的，因为不是主流，主流最容易红的商业写作，还是要成长加设定，精彩的设定、故事背景，成长的有趣，动人的情感故事，亲情、友情、爱情，这些才是主流。</p>
<p>　　设定很重要，在这方面我比较擅长，我在写一本书之前，一定会有一个完整设定出来，我会把一部作品的主线比喻为脊椎，设定为骨骼，当这两部分你完成了，写作就是往里面填血肉的过程，一个好的设定，就可以撑起一部作品。</p>
<p>　　好设定加好情感，就是一部好小说，我一直认为，写作是没办法教的，因为每个人都有不同的思路，想要提升写作水平最简单的办法，就是修改，不断的修改，同一个内容，持续修改，就能提升。</p>
<p>　　但修改也是最枯燥的，所以一般人都不愿意做，也包括我…… 但大家如果想要写的更好，还是要在这方面多尝试。</p>
<p>　　接下来简单说一些网文未来的趋势吧，在这方面应该没人比我看的更清楚了。</p>
<p>　　网文经过十多年的发展，已经有了自己的体系，未来发展有几点很重要，首先，大家一定要注意，写作的时候，要正能量写作，这不是我矫情，而是正能量才能长久。</p>
<p>　　我昨天看一本书, 叫什么不说了，一个实力不错的作者写的, 都市小说, 写了一段以后，就开始杀警察…… 这种书是决不可能长久的，实体出版肯定出不来, 杀的是爽了，但距离被禁也就快了, 我从来都没觉得我写的有多好，很多作者实力都比我强, 但有一点我认为自己做的很好，我写书三观很正, 大家有兴趣可以注意一下, 所以，大家要尽可能的正能量写作，现在审查特别的严。</p>
<p><strong>凉茶:</strong></p>
<p>　　很多都市书，看着是赚钱，卖得好，也不黄，但是三观不正，这种书，一旦被注意了，是保不住的。</p>
<p><strong>唐家三少:</strong></p>
<p>　　我唯一有一本书，生肖守护神里面，涉及到一些擦边球的内容，现在出再版书，出到第四本，换了五个出版社了…… 编辑不断的改啊改，所以，大家一定要注意一点，国家现在对这方面控制的很严，虽然有偏左的感觉，但我们既然身在其中，只能改变自己来适应。</p>
<p><strong>丛林狼:</strong></p>
<p>　　正能量＋1，不暧昧，三观正才是长久之计。</p>
<p><strong>唐家三少:</strong></p>
<p>　　想必这几年大家也发现了，网文真正赚钱的，其实已经不是小说连载，想要有更好的发展，那么，网络连载却依旧是核心，这个核心，是扩大影响力的核心，因为网络是带给我们最大人气的来源，所以，这一点是不能放弃的，这样才能对读者有足够的粘性，同时在写作的时候，大家也要考虑一下你想要做的衍生。</p>
<p>　　其实现在最容易衍生的，还是玄幻小说，首先没那么多限制，其次，改游戏容易赚钱，而且可以告诉大家一点的是，很多人认为玄幻和影视无缘，但我可以告诉你们，未来中国影视的发展方向，必然是玄幻，连载式玄幻大片，复刻好莱坞，这是以后必然的趋势。</p>
<p>　　我的斗罗大陆第一部电影应该会在今年开拍，斗罗大陆会拍四部，算是给他家的一份尝试，做视效大片，就像刚才天堂说过的，好莱坞漫威那种，如果我成功了，那么，会再次带动整个行业一次提升，斗罗我之所以要写 2，未来还有 3 和 4，就是为了要完成一个大系列, 我希望他能够拍出 20、30 部电影, 在电影这方面，我和漫威的创始人之一聊过, 他跟我说，他一生做的电影一共有 75 亿美金的票房, 但衍生产品有 380 亿美金, 而国内这方面其实根本不行, 原因很简单，我们没有超级 IP, 所以我希望能够通过自己的努力，做出一个超级 IP 来, 那时候，我们这一类的作品都将火起来，我们也可以做很多好莱坞能够做的事情，我要做的不是漫威，我希望未来能够做一个迪斯尼出来。</p>
<p>　　如果我的电影火了，那么，我会全面开发周边产品，全国扑实体店，当我有一千家实体店，那么，我就可以去做以斗罗为核心的中国式迪斯尼商业地产，主题公园，这是我的一个畅想吧，但人总要有个目标，不然就没有奋斗的动力了，所以我要走的路还很远很远，一切都只是刚刚开始。</p>
<p>　　虽然我开销挺大的，但我的钱其实足够我花了，所以我希望能够通过自己的努力，为我们行业做些事情，大家可能去年都看到，游戏好红火，但游戏绝不是我们未来最重要的，尽管我在其中受益良多，但我还是要这么说。</p>
<p>　　电影才是我们未来最大的衍生，因为电影会带给我们最大的影响力，而这份影响力就会带给我们一切，中国复刻好莱坞发展，连载式玄幻大片是必不可少的，而内容来源，必然就是我们这些人，小时代很红火，但他只是个都市时装剧。</p>
<p>　　我要做的是玄幻视效大片，不是一个体量的东西，斗罗第一部电影的投资大概是 2 亿人民币，小时代一部的投资只有 2000 万，他六亿票房是大赚，而斗罗六亿票房才是回本。</p>
<p><strong>天堂羽:</strong></p>
<p>　　电影工业要起来，必须要视效大片，这会是国内必然的趋势。</p>
<p>　　<strong>唐家三少:</strong></p>
<p>　　有句话我很喜欢，先知先觉者经营、后知后觉者跟随、不知不觉者消费。</p>
<p>　　在我们这个行业，我曾经引领过三次变化，第一次是漫画，我是第一个做小说改编漫画的，斗罗大陆的漫画，单本销量过百万册，然后是小说，从神印王座开始，我的实体书销量极好，绝世唐门总销量破千万册，从而让这两方面，很多作者跟随受益。第三次就是游戏，在我唐门世界火起来之前，我们一个手游版权也就卖几万块，十万块都是多的了，但去年，大家应该看到了，游戏火成什么样，我之所以赚的比别人多，是因为我看的更远一点。</p>
<p>　　所以大家要相信我，未来的趋势，一定是电影！</p>
<p>　　中国在不久的将来，一定会成为全世界最大的电影消费市场，而且，电影带给我们的不只是钱，更是影响力，这个是最重要的。</p>
<p>　　而游戏未来发展的趋势，一定会是寡头市场，小游戏公司生存会越来越艰难，几大游戏公司瓜分市场。</p>
<p>　　我们一直说的多版权运营，一定是以网络为核心的多种渠道延伸，同时，在宣传自己的时候，要做到有节奏，我的一些做法可能大家没法直接借鉴，但我可以告诉大家目前我是怎么做的。</p>
<p>　　在这方面操作上，我应该是最好的，首先，一本新书上传之前，你必须要有存稿，而且不能低于 30 万字，这样才能给你操作的空间，我给大家提个醒，我在电影圈摸爬滚打了有两年多，如果你们的作品大火起来，一定不要先做动漫，也不要做网剧、电视剧这些，因为，这些会拉低你的品级，一定是先上大电影，而且是真人大电影。</p>
<p>　　在中国也好，全世界也罢，最高级别的，依旧是大电影，动漫电影都不行，当你大电影火了，再回头做其他的，无论是价格还是影响力，都不同，而反过来，如果先做了别的，电影就被拉下来，很难火。</p>
<p>　　譬如宫宫的电影票房差的一塌糊涂，这不是我聪明，是我合作的电影公司告诉我的，电影其实不太赚钱，但却很赚影响力，当然，郭敬明那种做法，还是能赚点钱的…… 他投入小，但是，影响力却不一样，我拍的再不好，我也是玄幻大片，他拍的再好也是时装剧，这不是一个体量的东西。</p>
<p>　　小时代是非常成功的，但问题是，他没有衍生了，他只能是在拍的时候，多接一些植入广告，小时代却终究没法成为一个强大的超级 IP，这是体裁本身的问题。</p>
<p>　　回归正题，接着说我操作一本作品的顺序，一般来说，我在网上上传一本作品之前，简体、漫画这两个版权一定是卖掉的，网络开始上传，20 万字左右，第一本实体书就正好配合出版了，与网络完全同步，漫画开始在杂志上连载，大约第三个月或者第四个月出版第一本，宣传作品，一定要一浪接一浪，在不同的平台进行宣传，效果才是最好的，不要一下全都砸出去。</p>
<p>　　未来我还要尝试一个模式，那就是在作品发表前一年，就找合作方开发游戏，游戏和小说同步上，做到最大的推广。</p>
<p>　　我 2016 年写斗罗大陆 3，会写两年，在 2017 年年初，斗罗大陆第一部电影会上映，斗罗大陆 3 的游戏我已经卖掉了，大概会在 2016 年 4 月左右上，这些时间点都是事先安排好的，写一个时代的进程。</p>
<p>　　<a href="http://www.yousuu.com/name/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86">《斗罗大陆》</a>第一部是冷兵器时代，第二部是热兵器时代，第三部是高科技时代，第四部星际时代，每一部相差一万年，中间还有一个外篇神界传说，今年出版，一共计划是一千八百八十万字，出版 93 本书，大概是这么个数，波动不会太大。</p>
<p>　　要告诉大家的是，一定要敢想，要多接触外面的世界，不能只是在家埋头写，要有计划，有目标，三年前，绍兴年会的时候，我跟黑心说，我要做连续电影，那时候，我估计没人觉得我是认真的，也没人认为我能成功，但三年后的今天，我的第一部电影要开拍了，一定要敢于设想，然后多接触社会吧，因为很多时候，你只是写得好是没用的，要有国家的支持，要有合作伙伴的辅助，一个人的力量终究是有限的，给自己制定好目标，朝着目标去努力，不成功也不气馁，坚持总会有收获，好啦，就说这么多吧。</p>
<p><a href="http://www.lkong.net/thread-1143565-1-1.html">摘自</a></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>上海药店APP开发总结</title>
    <url>/2019/11/15/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97APP%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><p>上海药店是上海市药监局推出的一款款便民服务 APP ，主要推出了药店查询，药品查询，市民问答，在线咨询等功能，可在各大应用平台下载。</p>
<span id="more"></span>

<h3 id="职责描述："><a href="#职责描述：" class="headerlink" title="职责描述："></a>职责描述：</h3><ul>
<li>APP通过前后端分离方式开发，分为企业端和监管端接口文档清晰，接口开发流程规范；</li>
<li>市民端开发药店药店查询、新闻和市民问答模块、药店举报评论模块接口；</li>
<li>药店端开发企业基本信息维护模块，回收药店信息模块，市民积分抵扣模块接口；</li>
</ul>
<h3 id="技术描述："><a href="#技术描述：" class="headerlink" title="技术描述："></a>技术描述：</h3><p>项目核心为spring boot，mybatis plus构成，数据库使用Oracle，mongodb多数据源。接口使用SM3国密码算法进行接口加密防篡改，用户重要数据全部加密后传输，集成了高德地图进行附件药店数据显示，通过极光推送jPush进行应用消息通知，集成环信即时通讯接口完成市民端和药店端的实时聊天功能。</p>
<h3 id="系统页面："><a href="#系统页面：" class="headerlink" title="系统页面："></a>系统页面：</h3><p><strong>接口文档：</strong></p>
<p><img src="/images/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97APP%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573800713207.png" alt="1573800713207"></p>
<p><strong>市民端：</strong></p>
<p><img src="/images/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97APP%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573787862304.png" alt="1573787862304"></p>
<p><strong>药店端：</strong></p>
<h3 id="项目架构："><a href="#项目架构：" class="headerlink" title="项目架构："></a>项目架构：</h3><p><img src="/images/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97APP%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573790732873.png" alt="1573790732873"></p>
<p>重难点分析：</p>
<ol>
<li>mongDB，存储药店位置信息</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>shyd总结</tag>
      </tags>
  </entry>
  <entry>
    <title>事物、Transaction的用法</title>
    <url>/2019/11/13/%E4%BA%8B%E7%89%A9%E3%80%81-Transaction%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>关键词：事务， 编程式事务，声明式事务、spring 事务管理、AOP 事务增强、@Transactional</p>
<p>在分析深入分析 @Transactional 的使用之前，我们先回顾一下事务的一些基本内容。</p>
<span id="more"></span>

<h1 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a><strong>事务的基本概念</strong></h1><p>先来回顾一下事务的基本概念和特性。数据库事务 (Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务，就必须具备 ACID 特性，即原子性（Atomicity）、一致性 (Consistency)、隔离性 (Isolation) 和持久性 (Durability)。</p>
<h1 id="编程式事务与声明式事务"><a href="#编程式事务与声明式事务" class="headerlink" title="编程式事务与声明式事务"></a><strong>编程式事务与声明式事务</strong></h1><p>Spring 与 Hibernate 的整合实现的事务管理是常用的一种功能。Hibernate 建议所有的数据库访问都应放在事务内进行，即使只进行只读操作。事务又应该尽可能短，因为长事务会导致长时间无法释放表内行级锁，从而降低系统并发的性能。 Spring 同时支持编程式事务和声明式事务。</p>
<p>编程式事务需要在代码中显式调用 beginTransaction ()、commit ()、rollback () 等事务管理相关的方法。Spring 的声明式事务管理在底层是建立在 AOP 的基础之上的，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。事务增强也是 AOP 的一大用武之处。</p>
<h1 id="使用声明式事务"><a href="#使用声明式事务" class="headerlink" title="使用声明式事务"></a><strong>使用声明式事务</strong></h1><p>声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明，很好的分离了业务逻辑和事务管理逻辑。以 spring+jpa 整合增加声明式事务为例，下面是使用声明式事务的配置方式以及使用。</p>
<h2 id="applicationContext-xml-配置"><a href="#applicationContext-xml-配置" class="headerlink" title="applicationContext.xml 配置"></a><strong>applicationContext.xml 配置</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 entityManagerFactory 配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;persistenceXmlLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/classes/persistence.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loadTimeWeaver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置声明式事务管理，使用 JpaTransactionManager 作为事务管理器的实现类 –&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/bean&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!-- 声明业务组件使用注解生成事务代理 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="使用-Transactional-配置声明式事务管理"><a href="#使用-Transactional-配置声明式事务管理" class="headerlink" title="使用 @Transactional 配置声明式事务管理"></a><strong>使用 @Transactional 配置声明式事务管理</strong></h2><p>在 spirng 的配置文件中配置了事务管理和注解驱动之后，我们就可以在业务层使用 @Transactional 配置声明式事务管理了。如下</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IBaseService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IBaseDao&lt;T&gt; baseDao;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Transactional-深入使用"><a href="#Transactional-深入使用" class="headerlink" title="@Transactional 深入使用"></a><strong>@Transactional 深入使用</strong></h1><p>上面我们已经知道了声明式事务管理的用法了，下面我们将进一步分析 @Transactional 在各种场景下用法。</p>
<h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a><strong>事务的传播行为</strong></h2><p>@Transactional 注解支持 9 个属性的设置，其中 Propagation 属性用来枚举事务的传播行为。所谓事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring 支持 7 种事务传播行为：</p>
<p><a href="http://images2015.cnblogs.com/blog/783994/201606/783994-20160629124739234-1670017714.jpg"><img src="/images/%E4%BA%8B%E7%89%A9%E3%80%81-Transaction%E7%9A%84%E7%94%A8%E6%B3%95/783994-20160629124739796-10641559.jpg" alt="wps9181.tmp"></a> </p>
<p>REQUIRED 是常用的事务传播行为，如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。其它传播行为大家可另查阅。</p>
<h2 id="多个事务方法的嵌套调用时的事务传播"><a href="#多个事务方法的嵌套调用时的事务传播" class="headerlink" title="多个事务方法的嵌套调用时的事务传播"></a><strong>多个事务方法的嵌套调用时的事务传播</strong></h2><p>有三个事务方法调用嵌套关系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PayHisInfoService.update()-&gt;PayHisInfoService.save()-&gt;PayInfoService.update()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;E&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayHisInfoService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">PayHisInfo</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayHisInfoDao payHisInfoDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PayInfoService payInfoService;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(PayHisInfo payHisInfo,PayInfo payInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   save(payHisInfo);</span><br><span class="line"></span><br><span class="line">      payInfoService.update(payInfo);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(PayHisInfo payHisInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> payHisInfoDao.insert(payHisInfo);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayInfoService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">PayInfo</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> PayInfoDao payInfoDao;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional(propagation=Propagation.SUPPORTS, readOnly=true)</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;PayInfo&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> payInfoDao.findAll();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(PayInfo payInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> payInfoDao.update(payInfo);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们按照上面的调用嵌套关系执行时，结果如下</p>
<p><img src="/images/%E4%BA%8B%E7%89%A9%E3%80%81-Transaction%E7%9A%84%E7%94%A8%E6%B3%95/783994-20160630094423937-1350472183.jpg" alt="img"></p>
<p>从日志中我们可以看出，PayHisInfoService.update () 执行时开启了一个事务，而 PayHisInfoService.save () 方法和 PayHisInfoService.update () 方法处于同一个类中，调用时没有发生事务传播，就像已经处于 PayHisInfoService.update () 方法的事务当中一样。而当执行 PayInfoService.update () 时，提示 “Participating in existing transaction”，这说明发生了事务传播，即 PayInfoService.update () 并没有新建一个事务，而是加入到已有的 PayHisInfoService.update () 事务中。</p>
<h2 id="多线程环境下的事务传播"><a href="#多线程环境下的事务传播" class="headerlink" title="多线程环境下的事务传播"></a><strong>多线程环境下的事务传播</strong></h2><p>现在我们将上面例子中的 PayHisInfoService.update () 用另一个线程来执行，如下</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayHisInfoService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">PayHisInfo</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> PayHisInfoDao payHisInfoDao;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> PayInfoService payInfoService;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(PayHisInfo payHisInfo,PayInfo payInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     save(payHisInfo);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//payInfoService.update(payInfo);</span></span><br><span class="line"></span><br><span class="line">     PayInfoThread pifth = <span class="keyword">new</span> PayInfoThread(payInfoService,payInfo);</span><br><span class="line"></span><br><span class="line">     pifth.start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(PayHisInfo payHisInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> payHisInfoDao.insert(payHisInfo);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PayInfoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayInfoService payInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayInfo payInfo;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PayInfoThread</span><span class="params">(PayInfoService payInfoService,PayInfo payInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.payInfoService = payInfoService;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.payInfo = payInfo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;PayInfoThread updating payInfo...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        payInfoService.update(payInfo);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们按照上面的调用嵌套关系执行时，结果如下</p>
<p><img src="https://images2015.cnblogs.com/blog/783994/201606/783994-20160630094424937-1217089867.jpg" alt="img"></p>
<p>从日志结果可以看出，在执行 PayHisInfoService.update () 和 PayInfoService.update () 时分别创建了各自的事务。而 PayHisInfoService.save () 和 PayHisInfoService.update () 则在同一个线程中执行。所以 spring 的事务管理是线程安全的。</p>
<p>在相同线程中进行相互嵌套调用的事务方法工作于相同的事务中。如果这些相互嵌套调用的方法工作在不同的线程中，不同线程下的事务方法工作在独立的事务中。</p>
<h2 id="Transactional-的继承关系"><a href="#Transactional-的继承关系" class="headerlink" title="@Transactional 的继承关系"></a><strong>@Transactional 的继承关系</strong></h2><p>或许你已经在上面的例子中看出了，我们只在父类 BaseService 中声明了 @Transactional，子类就自然得到事务增强。注解并没有继承这种说法，但此处用 “继承关系” 来形容父类 @Transactional 和子类方法之间的关系最恰当不过了：父类 Service 声明了 @Transactional，子类继承父类，父类的声明的 @Transactional 会对子类的所有方法进行事务增强。这个还有个很实用的用法，例如测试基类继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractTransactionalJUnit4SpringContextTests</span><br><span class="line"></span><br><span class="line">声明 <span class="meta">@Transactional</span> 可方便进行事务测试</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/applicationContext.xml&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@TransactionConfiguration(transactionManager = &quot;transactionManager&quot;, defaultRollback = true)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionalJUnit4SpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> applicationContext.getBean(beanName);</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 BaseTest 声明了 @Transactional 了之后，就会自动给我们自己编写的测试类中的所有测试方法进行事务增强。</p>
<h2 id="Transactional-的优先级"><a href="#Transactional-的优先级" class="headerlink" title="@Transactional 的优先级"></a><strong>@Transactional 的优先级</strong></h2><p>如果子类的方法重写了父类的方法并且声明了 @Transactional，那么子类的事务声明会优先于父类的事务声明。</p>
<h2 id="利用-spring-的-AOP-进行事务切面增强"><a href="#利用-spring-的-AOP-进行事务切面增强" class="headerlink" title="利用 spring 的 AOP 进行事务切面增强"></a><strong>利用 spring 的 AOP 进行事务切面增强</strong></h2><p>还是上面的列子，把父类声明的 @Transactional 去掉。在 applicationContext.xml 中配置事务增强切面，配置如下：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--②使用 aop 和 tx 命名空间语法为 PayHisInfoService 所有公用方法添加事务增强 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceJdbcMethod&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">expression</span>=<span class="string">&quot;execution(public * com.xxx.service.PayHisInfoService.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceJdbcMethod&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;jdbcAdvice&quot;</span> <span class="attr">order</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;jdbcAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行测试用例，结果如下：</p>
<p><img src="/images/%E4%BA%8B%E7%89%A9%E3%80%81-Transaction%E7%9A%84%E7%94%A8%E6%B3%95/783994-20160630094425968-1112376012.jpg" alt="img"></p>
<p>当有一条数据更新失败时，事务会自动回滚，如下：</p>
<p><a href="http://images2015.cnblogs.com/blog/783994/201606/783994-20160629124744499-833396908.jpg"><img src="/images/%E4%BA%8B%E7%89%A9%E3%80%81-Transaction%E7%9A%84%E7%94%A8%E6%B3%95/783994-20160629124745077-347326622.jpg" alt="wps9195.tmp"></a> </p>
<h2 id="Transactional-方法的可见度"><a href="#Transactional-方法的可见度" class="headerlink" title="@Transactional 方法的可见度"></a><strong>@Transactional 方法的可见度</strong></h2><p>上面为了测试演示方便，我们把 @Transactional 都声明在了类上。实际上 @Transactional 可以作用于接口、接口方法、类以及类方法上。但是 Spring 小组建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的（从上面的 Spring AOP 事务增强可以看出，就是针对方法的）。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>（1）声明式事务优于编程式事务</p>
<p>（2）事务方法的嵌套调用会产生事务传播</p>
<p>（3）spring 的事务管理是线程安全的</p>
<p>（4）父类的声明的 @Transactional 会对子类的所有方法进行事务增强</p>
<p>（5）从 Spring AOP 本质看，@Transactional 注解应该只被应用到 public 方法上</p>
<p><a href="https://www.cnblogs.com/hjwublog/p/5626465.html">参考</a></p>
]]></content>
      <categories>
        <category>事物</category>
      </categories>
      <tags>
        <tag>事物</tag>
        <tag>Transactional</tag>
      </tags>
  </entry>
  <entry>
    <title>器械召回系统总结</title>
    <url>/2019/11/07/%E5%99%A8%E6%A2%B0%E5%8F%AC%E5%9B%9E%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><p>项目为器械主动召回监管系统，分为企业端和监管端，系统开发目的是为了代替以前线下上报纸质材料的繁琐，变成线上企业与监管部门的上报报与审核过程。</p>
<span id="more"></span>

<p>企业端分为企业召回信息上报，召回管理功能，共五个报告信息，分三次上报，审核不通过时需填写修改说明后重新上报。</p>
<p>监管端分为报告审核（初审、复审），企业信息提醒，企业召回管理，项目公示信息，数据统计。</p>
<h4 id="上报流程图："><a href="#上报流程图：" class="headerlink" title="上报流程图："></a>上报流程图：</h4><p><img src="/images/%E5%99%A8%E6%A2%B0%E5%8F%AC%E5%9B%9E%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573719368018.png" alt="1573719368018"></p>
<h3 id="职责描述："><a href="#职责描述：" class="headerlink" title="职责描述："></a>职责描述：</h3><ul>
<li>需求分析，原型设计，确认系统开发功能；</li>
<li>数据库设计，系统底层搭建和功能开发；</li>
<li>客户对接，优化功能，后期维护，细节优化；</li>
<li>通过状态模式进行状态模式审核流程控制；</li>
<li>新增接口供第三方平台调用；</li>
</ul>
<h3 id="技术分析："><a href="#技术分析：" class="headerlink" title="技术分析："></a>技术分析：</h3><p>这是由我全部独立开发，完成的第一个项目(经理协助指导)。</p>
<p>器械召回为追溯系统的子系统，与其他系统相互关联，通过同源域名cookie共享原则从主系统跳转后登录，调用权限管理接口获取权限，通过shiro鉴权，通过新增接口获取其他系统信息，每天执行定时任务检测报告是否超过上报日期，数据库用Oracle开发，通过dblink关联其他系统数据库。主要设计框架和技术与追溯申报类似，但通过jar包方式部署，更加方便。</p>
<p>后期接口权限通过spring cloud gateway网关调用，由网关统一管理，添加接口权限校验，记录接口调用日志。</p>
<h3 id="系统图示："><a href="#系统图示：" class="headerlink" title="系统图示："></a>系统图示：</h3><ol>
<li>企业端</li>
</ol>
<p><img src="/images/%E5%99%A8%E6%A2%B0%E5%8F%AC%E5%9B%9E%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573718611774.png" alt="1573718611774"></p>
<p><img src="/images/%E5%99%A8%E6%A2%B0%E5%8F%AC%E5%9B%9E%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573718825363.png" alt="1573718825363"></p>
<ol start="2">
<li>监管端</li>
</ol>
<p><img src="/images/%E5%99%A8%E6%A2%B0%E5%8F%AC%E5%9B%9E%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573720521352.png" alt="1573720521352"></p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>器械召回</tag>
      </tags>
  </entry>
  <entry>
    <title>单列索引和联合索引区别</title>
    <url>/2019/11/05/%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="不同情况联合索引是否有效"><a href="#不同情况联合索引是否有效" class="headerlink" title="不同情况联合索引是否有效"></a>不同情况联合索引是否有效</h3><span id="more"></span>

<p><img src="/images/%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB/1572940311855.png" alt="1572940311855"></p>
<p><img src="/images/%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB/1572940360178.png" alt="1572940360178"><img src="/images/%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB/1572940455500.png" alt="1572940455500"></p>
<h4 id="详细sql测试参考-！！！"><a href="#详细sql测试参考-！！！" class="headerlink" title="详细sql测试参考 ！！！"></a><a href="https://blog.csdn.net/Abysscarry/article/details/80792876">详细sql测试参考</a> ！！！</h4><h4 id="概念参考"><a href="#概念参考" class="headerlink" title="概念参考"></a><a href="https://suiwo.xyz/2019/04/13/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%EF%BC%89/">概念参考</a></h4>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>五笔输入法学习</title>
    <url>/2019/12/01/%E4%BA%94%E7%AC%94%E8%BE%93%E5%85%A5%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title>子系统实现cookie共享和SSO单点登录应用</title>
    <url>/2019/11/08/%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0cookie%E5%85%B1%E4%BA%AB%E5%92%8CSSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="cookie-的两个重要属性："><a href="#cookie-的两个重要属性：" class="headerlink" title="cookie 的两个重要属性："></a><strong>cookie</strong> 的两个重要属性：</h3><span id="more"></span>

<ul>
<li>domain 表示的是 cookie 所在的域，默认为请求的地址，如网址为 <a href="http://www.test.com/test/test.aspx%EF%BC%8C%E9%82%A3%E4%B9%88">www.test.com/test/test.aspx，那么</a> domain 默认为 <a href="http://www.test.com.而跨域访问,如域/">www.test.com。而跨域访问，如域</a> A 为 t1.test.com，域 B 为 t2.test.com，<strong>那么在域 A 生产一个令域 A 和域 B 都能访问的 cookie 就要将该 cookie 的 domain 设置为.test.com</strong>；如果要在域 A 生产一个令域 A 不能访问而域 B 能访问的 cookie 就要将该 cookie 的 domain 设置为 t2.test.com。</li>
</ul>
<h3 id="目前开发项目解决方案："><a href="#目前开发项目解决方案：" class="headerlink" title="目前开发项目解决方案："></a>目前开发项目解决方案：</h3><ol>
<li><strong>cookie</strong>里确实设置的domain是***.com类似后缀结尾的，相关系统的也就是其他子系统的后缀，这样在访问子系统是cookie就是共享的了。</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemSecondUrl</span>=<span class="string">.smda.sh.cn</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/1573176692611.png" alt="1573176692611"></p>
<ol start="2">
<li><p>跳转子系统过程</p>
<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/1573177099764.png" alt="1573177099764"></p>
</li>
<li><p>在跳转过来后，怎么获取当前用户的呢？其实这里首先会被shiro拦截器拦截，</p>
<p><img src="/images/Session%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/1573177421842.png" alt="1573177421842"></p>
</li>
<li><p>子系统从cookie中获取当前用户</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">            String userId = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String userInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String loginUrl = <span class="keyword">this</span>.loginUrl;</span><br><span class="line">            <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果cookie为空，直接返回登录页面</span></span><br><span class="line">                <span class="keyword">if</span>(cookies == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    response.sendRedirect(loginUrl);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               	<span class="comment">// 从cookie中获取当</span></span><br><span class="line">                <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(SysConstant.COOKIE_USER_ID.equals(cookie.getName())</span><br><span class="line">                            &amp;&amp; StringUtils.isNotBlank(cookie.getValue()))&#123;</span><br><span class="line">                        userId = cookie.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(SysConstant.COOKIE_USER_INFO.equals(cookie.getName())</span><br><span class="line">                            &amp;&amp; StringUtils.isNotBlank(cookie.getValue()))&#123;</span><br><span class="line">                        userInfo = cookie.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取缓存是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(StringUtils.isBlank(userInfo)</span><br><span class="line">                        || StringUtils.isBlank(userId))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            session.invalidate(); <span class="comment">//（???）</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    response.sendRedirect(loginUrl);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//shiro解密</span></span><br><span class="line">                String userInfoStr = ShfdaConfusionUtil.deconfuse(userInfo);</span><br><span class="line">                String[] userInfos = userInfoStr.split(<span class="string">&quot;\\|\\|\\|&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(userInfos !=<span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; userInfos.length &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(userInfos[<span class="number">0</span>], userInfos[<span class="number">1</span>],<span class="keyword">false</span>);</span><br><span class="line">                    Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">                    currentUser.login(token);</span><br><span class="line">                    <span class="keyword">if</span>(currentUser.isAuthenticated())&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                response.sendRedirect(loginUrl);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里子系统只做校验，校验通过后，在shiro中校验当前用户名密码是否正确，设置当前用户登录，直接调到到链接登录。</p>
<p>校验代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Logger log = LoggerFactory.getLogger(UserRealm.class);</span><br><span class="line">	<span class="keyword">private</span> QxglSignUtil qxglApiUtil;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 为当前登录的Subject授予角色和权限</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 经测试:本例中该方法的调用时机为需授权资源被访问时</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 经测试:并且每次访问需授权资源时都会执行该方法中的逻辑,这表明本例中默认并未启用AuthorizationCache</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 个人感觉若使用了Spring3.1开始提供的ConcurrentMapCache支持,则可灵活决定是否启用AuthorizationCache</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 比如说这里从数据库获取权限信息时,先去访问Spring3.1提供的缓存,而不使用Shior提供的AuthorizationCache</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span></span>&#123;</span><br><span class="line">	    	Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">	    	User user = (User)currentUser.getSession().getAttribute(SysConstant.CURRENT_USER);</span><br><span class="line">	    	List&lt;String&gt; shirorolespermis = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		    <span class="keyword">if</span>(user !=<span class="keyword">null</span>)&#123;</span><br><span class="line">		    	log.info(<span class="string">&quot;doGetAuthorizationInfo================start--&quot;</span>+user.getUserName());</span><br><span class="line">		    	log.info(<span class="string">&quot;doGetAuthorizationInfo================start--&quot;</span>+user.getPassword());</span><br><span class="line">		    	<span class="comment">//获取权限</span></span><br><span class="line">		    	ResponseShfdaPermission rsp = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					qxglApiUtil = SysParameter.getInstance().getQxglApiUtil();</span><br><span class="line">					rsp = qxglApiUtil.getUserPermissions(user.getUserId(),</span><br><span class="line">							user.getUserName(), user.getPassword());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (ApiServiceException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		    	<span class="keyword">if</span>(rsp != <span class="keyword">null</span> &amp;&amp; rsp.getShfdaPermissions() != <span class="keyword">null</span> &amp;&amp; rsp.getShfdaPermissions().size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			    	<span class="keyword">for</span>(ShfdaPermission sp: rsp.getShfdaPermissions())&#123;</span><br><span class="line">			    		<span class="keyword">if</span>(StringUtils.isNotBlank(sp.getPerValue()))&#123;</span><br><span class="line">			    			shirorolespermis.add(sp.getPerValue());</span><br><span class="line">			    		&#125;</span><br><span class="line">			        &#125;</span><br><span class="line">		    	&#125;</span><br><span class="line">		    	SimpleAuthorizationInfo simpleAuthorInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">		    	simpleAuthorInfo.addStringPermissions(shirorolespermis);</span><br><span class="line">		    	<span class="keyword">return</span> simpleAuthorInfo;</span><br><span class="line">		    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		    	 <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 验证当前登录的Subject</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 经测试:本例中该方法的调用时机为LoginController.login()方法中执行Subject.login()时</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authcToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	    	UsernamePasswordToken token = (UsernamePasswordToken)authcToken;</span><br><span class="line">	        ShfdaUser shfdaUser = <span class="keyword">null</span>;</span><br><span class="line">	        qxglApiUtil = SysParameter.getInstance().getQxglApiUtil();</span><br><span class="line">	        <span class="keyword">try</span>&#123;</span><br><span class="line">	        	shfdaUser = qxglApiUtil.getUserInAllViewByUserName(token.getUsername(),</span><br><span class="line">	        			token.getUsername(),<span class="keyword">new</span> String(token.getPassword()));</span><br><span class="line">	        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">	        	ex.printStackTrace();</span><br><span class="line">	        	<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();<span class="comment">//没找到帐号</span></span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(!<span class="string">&quot;0&quot;</span>.equals(shfdaUser.getReturnCode())) &#123;</span><br><span class="line">	            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();<span class="comment">//没找到帐号</span></span><br><span class="line">	        &#125;</span><br><span class="line">	        AuthenticationInfo authcInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(shfdaUser.getUserName(), shfdaUser.getPassword(), <span class="keyword">this</span>.getName());</span><br><span class="line">	        <span class="keyword">if</span>(!shfdaUser.isHasRole())&#123;</span><br><span class="line">	        	<span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">	        &#125;</span><br><span class="line">	        User user = <span class="keyword">new</span> User();</span><br><span class="line">	        <span class="keyword">if</span>(<span class="string">&quot;SHFDA&quot;</span>.equals(shfdaUser.getUserCategory()))&#123;</span><br><span class="line">	        	JSONObject userJson = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					userJson = qxglApiUtil.getUserJsonByUserId(shfdaUser.getUserId(),</span><br><span class="line">							shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">					user = User.fromJson(userJson);</span><br><span class="line">					<span class="comment">//用户 市局处室、监管部门</span></span><br><span class="line">					<span class="keyword">if</span>(ShfdaUser.USER_TYPE_SJCS_DEPART_IDS.contains(user.getDepartId()))&#123;</span><br><span class="line">						user.setUserType(ShfdaUser.USER_TYPE_SJCS);</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ShfdaUser.USER_TYPE_ZSDW_ORG_IDS.contains(user.getOrgId()))&#123;</span><br><span class="line">						user.setUserType(ShfdaUser.USER_TYPE_ZSDW);</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						user.setUserType(ShfdaUser.USER_TYPE_SCJ);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(StringUtils.isNotBlank(user.getOrgId()))&#123;</span><br><span class="line">						ShfdaOrg shfdaOrg= qxglApiUtil.getOrgByOrgId(user.getOrgId(), shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">						<span class="keyword">if</span>(shfdaOrg!=<span class="keyword">null</span>)&#123;</span><br><span class="line">							user.setRegionId(shfdaOrg.getRegionId());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">		        	user.setUserCategory(<span class="string">&quot;SHFDA&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (ApiServiceException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">				&#125;</span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	        	user.setUserId(shfdaUser.getUserId());</span><br><span class="line">                YlqxEnpSdk ylqxEnp = <span class="keyword">null</span>;</span><br><span class="line">                QxscEnpSdk qxscEnp = <span class="keyword">null</span>;</span><br><span class="line">                EnpUser enpUser = <span class="keyword">null</span>;</span><br><span class="line">                DsfptSdk dsfptSdk = <span class="keyword">null</span>;</span><br><span class="line">                QyglApiUtil qyglApiUtil = SysParameter.getInstance().getQyglApiUtil();</span><br><span class="line">                QxscApiUtil qxscApiUtil = SysParameter.getInstance().getQxscApiUtil();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    enpUser = qxglApiUtil.getEnpUserById(shfdaUser.getUserId(),</span><br><span class="line">                            shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">                    <span class="keyword">if</span>(enpUser == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">//没找到帐号</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ylqxEnp = qyglApiUtil.getSimpleEnpById(shfdaUser.getUserId(),</span><br><span class="line">                            shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">                    qxscEnp = qxscApiUtil.getSimpleById(shfdaUser.getUserId(),</span><br><span class="line">                            shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">					dsfptSdk = qyglApiUtil.getSimpleByEnpPkId(shfdaUser.getUserId(),</span><br><span class="line">							shfdaUser.getUserName(), shfdaUser.getPassword());</span><br><span class="line">					<span class="keyword">if</span>(ylqxEnp != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(ylqxEnp.getEnpPkId()))&#123;</span><br><span class="line">                        user.setRegionId(ylqxEnp.getRegionCode());</span><br><span class="line">                        user.setOrgId(ylqxEnp.getOrgId());</span><br><span class="line">						user.setDepartId(ylqxEnp.getSupervision());</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(qxscEnp != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(qxscEnp.getEnpPkId()))&#123;</span><br><span class="line">                        user.setRegionId(qxscEnp.getRegionCode());</span><br><span class="line">                        user.setOrgId(qxscEnp.getOrgId());</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !(dsfptSdk != <span class="keyword">null</span> &amp;&amp; StringUtils.isNotBlank(dsfptSdk.getEnpPkId())))&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EnpNotExistException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    user.setEnp(ylqxEnp);</span><br><span class="line">                    user.setQxscEnp(qxscEnp);</span><br><span class="line">					user.setDsfptSdk(dsfptSdk);</span><br><span class="line">                    user.setUserName(shfdaUser.getUserName());</span><br><span class="line">                    user.setPassword(shfdaUser.getPassword());</span><br><span class="line">                    user.setUserCategory(<span class="string">&quot;ENP&quot;</span>);</span><br><span class="line">                    user.setContact(enpUser.getContact());</span><br><span class="line">                    user.setEmail(enpUser.getEmail());</span><br><span class="line">                    user.setStatus(enpUser.getStatus());</span><br><span class="line">                    user.setIsModifPwd(enpUser.getIsModifyPwd());</span><br><span class="line">                    user.setTel(enpUser.getTel());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ApiServiceException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException();</span><br><span class="line">                &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">this</span>.setSession(SysConstant.CURRENT_USER, user);</span><br><span class="line">	        <span class="keyword">return</span> authcInfo;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 将一些数据放到ShiroSession中,以便于其它地方使用</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@see</span> 比如Controller,使用时直接用HttpSession.getAttribute(key)就可以取到</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSession</span><span class="params">(Object key, Object value)</span></span>&#123;</span><br><span class="line">	        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">	        <span class="keyword">if</span>(<span class="keyword">null</span> != currentUser)&#123;</span><br><span class="line">	            Session session = currentUser.getSession();</span><br><span class="line">	            <span class="keyword">if</span>(<span class="keyword">null</span> != session)&#123;</span><br><span class="line">	                session.setAttribute(key, value);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="5">
<li>父级系统登录时设置,设置用户信息到cookie中（userId，userInfo）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentUser.login(token);</span><br><span class="line">     	<span class="keyword">if</span>(currentUser.isAuthenticated())&#123; </span><br><span class="line">         	js.put(<span class="string">&quot;returnCode&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">          	js.put(<span class="string">&quot;returnMessage&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">          	loginLog.setRemark(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">          	loginLog.setLogType(<span class="number">0</span>);</span><br><span class="line">          	<span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         		 User currUser = (User)session.getAttribute(SysConstant.CURRENT_USER);</span><br><span class="line">         		 String userInfo = ShfdaConfusionUtil.getLoginStr(username,pwd);</span><br><span class="line">         		 Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_ID&quot;</span>, currUser.getUserId());</span><br><span class="line">         		 cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">         		 <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">         			 cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">         		 &#125;</span><br><span class="line">         		 response.addCookie(cookie);</span><br><span class="line">         		 cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_INFO&quot;</span>, userInfo);</span><br><span class="line">         		 cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">         		 <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">         			 cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">         		 &#125;</span><br><span class="line">             	 response.addCookie(cookie);</span><br><span class="line">		cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_RANGE&quot;</span>, currUser.getInfoQueryRange());</span><br><span class="line">		cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">			cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">		&#125;</span><br><span class="line">		response.addCookie(cookie);</span><br><span class="line">		<span class="comment">//获取全部权限</span></span><br><span class="line">		JSONObject json= qxglApiUtil.getAllPerssion( <span class="string">&quot;ADMIN_INNER&quot;</span>, <span class="string">&quot;ADMIN_INNER&quot;</span>);</span><br><span class="line">		JSONArray array=json.getJSONArray(<span class="string">&quot;jsonArray&quot;</span>);</span><br><span class="line">		JSONObject jsonPermission=<span class="keyword">null</span>;</span><br><span class="line">		List&lt;ShfdaPermission&gt; allPermissions=<span class="keyword">new</span> ArrayList&lt;ShfdaPermission&gt;();</span><br><span class="line">		String url = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		List&lt;String&gt; allURL = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="comment">//将json数组格式化成权限类型</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.size();i++)&#123;</span><br><span class="line">			jsonPermission=array.getJSONObject(i);</span><br><span class="line">			allPermissions.add(ShfdaPermission.fromJson(jsonPermission));</span><br><span class="line">			url = allPermissions.get(i).getUrl();</span><br><span class="line">			<span class="keyword">if</span>(url!=<span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(url))&#123;</span><br><span class="line">				allURL.add(url);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		session.setAttribute(<span class="string">&quot;allURL&quot;</span>, allURL);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>子系统单点登录功能，其实是和登录方法是一样的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/nssologin&quot;,method=&#123;RequestMethod.POST,RequestMethod.GET&#125;,produces=&#123;MediaType.APPLICATION_JSON_VALUE&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">nssologin</span><span class="params">(<span class="meta">@RequestParam(&quot;loginStr&quot;)</span> String loginStr, HttpSession session, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String[] userInfos = SsoUtil.getUserInfo(loginStr);</span><br><span class="line">           String userName = userInfos[<span class="number">0</span>];</span><br><span class="line">           qxglApiUtil = SysParameter.getInstance().getQxglApiUtil();</span><br><span class="line">           ShfdaUser user = qxglApiUtil.getUserByUserName(userName,<span class="string">&quot;ADMIN_INNER&quot;</span>,<span class="string">&quot;ADMIN_INNER&quot;</span>);</span><br><span class="line">           UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(user.getUserName(),</span><br><span class="line">                   user.getPassword(),<span class="keyword">false</span>);</span><br><span class="line">           Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">           currentUser.login(token);</span><br><span class="line">           <span class="keyword">if</span>(currentUser.isAuthenticated())&#123;</span><br><span class="line">               ServletContext application = session.getServletContext();</span><br><span class="line">               application.setAttribute(userName,session.getId());</span><br><span class="line">               <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   ShfdaUser currUser = getCurrentUser(session);</span><br><span class="line">                   String userInfo = ShfdaConfusionUtil.getLoginStr(userName,user.getPassword());</span><br><span class="line">                   Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_ID&quot;</span>, currUser.getUserId());</span><br><span class="line">                   cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                   <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">                       cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">                   response.addCookie(cookie);</span><br><span class="line">                   cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;USER_INFO&quot;</span>, userInfo);</span><br><span class="line">                   cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                   <span class="keyword">if</span>(StringUtils.isNotBlank(propertiesConfig.systemSecondUrl))&#123;</span><br><span class="line">                       cookie.setDomain(propertiesConfig.systemSecondUrl);</span><br><span class="line">                   &#125;</span><br><span class="line">                   response.addCookie(cookie);</span><br><span class="line">                   <span class="comment">//清除错误次数缓存</span></span><br><span class="line">                   qxglApiUtil.clearLoginErrorCountCache(userName, currUser.getUserName(), currUser.getPassword());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;redirect:/login&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>登录</category>
      </categories>
      <tags>
        <tag>cookie共享</tag>
        <tag>SSO单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title>小米笔记本风扇声音响调整</title>
    <url>/2019/11/30/%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%A3%8E%E6%89%87%E5%A3%B0%E9%9F%B3%E5%93%8D%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h3 id="小米笔记本风扇太响"><a href="#小米笔记本风扇太响" class="headerlink" title="小米笔记本风扇太响"></a>小米笔记本风扇太响</h3><p>好长时间一直在和小米笔记本风扇太响作斗争，之前网上有看过清灰，风扇加润滑油，售后等，但几乎都没什么用。</p>
<span id="more"></span>

<p>网上和小米的风扇太响作斗争的人太多，不过最新的小米游戏本好像不错，风扇没这么响，想能好像也还不错，但就是沉，很沉。</p>
<h3 id="过程中遇到的大坑"><a href="#过程中遇到的大坑" class="headerlink" title="过程中遇到的大坑"></a>过程中遇到的大坑</h3><p>就是有人建议<strong>调低cpu 处理器最大状态</strong>，有说调到99的，又是调到88的。</p>
<p>最近idea运行代码时，电脑卡的一批，找原因时发现了：</p>
<p><img src="/images/%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%A3%8E%E6%89%87%E5%A3%B0%E9%9F%B3%E5%93%8D%E8%B0%83%E6%95%B4/1575125528435.png" alt="1575125528435"></p>
<p><img src="/images/%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%A3%8E%E6%89%87%E5%A3%B0%E9%9F%B3%E5%93%8D%E8%B0%83%E6%95%B4/1575125553924.png" alt="1575125553924"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>重新调成100%，风扇状态改成主动降热，重新打开idea ，运行两个项目，发现代码一点都不卡，基本确定是因为这个原因。</p>
<p>CPU也达到了最高：</p>
<p><img src="/images/%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%A3%8E%E6%89%87%E5%A3%B0%E9%9F%B3%E5%93%8D%E8%B0%83%E6%95%B4/1575125716442.png" alt="1575125716442"></p>
<p><img src="/images/%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%A3%8E%E6%89%87%E5%A3%B0%E9%9F%B3%E5%93%8D%E8%B0%83%E6%95%B4/1575125747061.png" alt="1575125747061"></p>
<p>不卡了，明天再去找个地方给电脑清清灰，希望声音会小点。</p>
<p>拆机教程： <a href="https://zhuanlan.zhihu.com/p/85128943">https://zhuanlan.zhihu.com/p/85128943</a> </p>
<p>网上真要拆修一般是因为风扇已经是咔咔响了，如果只是声音大，建议还是不要拆开，拆机需谨慎。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>小米笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title>实现session共享、Nginx使用</title>
    <url>/2019/11/06/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>​        将sessionID当如redis中，所有的页面请求时都从redis获取，获取不到直接踢出；</p>
<span id="more"></span>

<p>​        用户重新登录后，重新保存到redis中。</p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573027317783.png" alt="1573027317783"></p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573027415486.png" alt="1573027415486"></p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p> <strong>Spring Session</strong> </p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573027450982.png" alt="1573027450982"></p>
<p>配置完成后直接使用就好了：<img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573027619706.png" alt="1573027619706"></p>
<h3 id="Nginx使用"><a href="#Nginx使用" class="headerlink" title="Nginx使用"></a>Nginx使用</h3><p>​        进入 Nginx 的安装目录的 conf 目录下（默认是在 <code>/usr/local/nginx/conf</code>），编辑 nginx.conf 文件:</p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573027848967.png" alt="1573027848967"></p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573027994588.png" alt="1573027994588"><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573092647459.png" alt="1573092647459"></p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573092685328.png" alt="1573092685328"></p>
<p><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573092694599.png" alt="1573092694599"></p>
<p><a href="https://zhuanlan.zhihu.com/p/68003585">参考</a></p>
<h3 id="其他方式："><a href="#其他方式：" class="headerlink" title="其他方式："></a>其他方式：</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/1573196340967.png" alt="1573196340967"></h3>]]></content>
      <categories>
        <category>session</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>session共享</tag>
        <tag>spring session</tag>
      </tags>
  </entry>
  <entry>
    <title>支付宝支付流程开发</title>
    <url>/2019/12/03/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="支付宝支付流程"><a href="#支付宝支付流程" class="headerlink" title="支付宝支付流程"></a>支付宝支付流程</h3><span id="more"></span>

<p><img src="/images/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%BC%80%E5%8F%91/image-20191203104911387.png" alt="image-20191203104911387"></p>
<ol>
<li>用户调用并选择后，APP请求到商户客户端，获取签名后的订单信息（后端生成签名订单）</li>
</ol>
<img src="/images/支付宝支付流程开发/image-20191203150503645.png" alt="image-20191203150503645" style="zoom: 67%;" />



<h3 id="预支付订单"><a href="#预支付订单" class="headerlink" title="预支付订单"></a>预支付订单</h3><p>伙伴出行，形成预支付接口</p>
<p>里程预支付是在司机接单的时候，后台生成支付订单，其实这里就是使用里程支付的意思。送达目的地后还需要确认支付</p>
<h4 id="创建预支付订单："><a href="#创建预支付订单：" class="headerlink" title="创建预支付订单："></a>创建预支付订单：</h4><ol>
<li>判断将支付的里程数和订单数，是否与平台里程，总里程；是否与平台金额，总金额一致，如不一致则可能中途修改金额，不能支付；</li>
<li>创建里程预支付订单：<ol>
<li>判断乘客是否已经支付行程费用 ：判断是否已在里程支付记录表里存在（MileagePaymentRecord）</li>
<li>判断是否在司机和乘客是否在同一亲情组，在一个亲情组只能用现金支付（UserFamilyMemberDTO）</li>
<li>确认乘客使用哪个里程账户支付，如果有亲情组则用亲情组支付</li>
<li>获取个人/亲情组 里程账户  (MileageAccountTotal)</li>
<li>获取平台里程账户信息，（MileageAccountTotal）</li>
<li>生成本次<strong>里程支付记录</strong>，（MileagePaymentRecord）</li>
<li>里程账户操作历史，生成流水记录</li>
<li>生成里程操作记录，即转账记录</li>
<li>如里程账户余额不足，创建现金订单，预支付结束。</li>
</ol>
</li>
</ol>
<h3 id="确认支付"><a href="#确认支付" class="headerlink" title="确认支付"></a>确认支付</h3><h5 id="1-里程支付："><a href="#1-里程支付：" class="headerlink" title="1.里程支付："></a>1.里程支付：</h5><ol>
<li>查找里程预支付记录，并确认形成未完成支付</li>
<li>把里程从平台账户转入车主里程账户<ol>
<li>获取车主账户，获取平台账户，记录流水（MileageAccountTotal，MileageAccountOperateRecordDTO）</li>
<li>生成流水并转账（generateMileageAccountOperateRecord）</li>
<li>生成里程支付结算记录（MileagePaymentSettle）</li>
<li>如果启用了使用里程支付收取平台信息费，则生成平台欠款</li>
<li>判断是否收取里程信息费（未启用）</li>
<li>修改里程账单支付状态（mileagePaymentRecord.PAY_FINISH），更新</li>
</ol>
</li>
</ol>
<h5 id="2-现金支付"><a href="#2-现金支付" class="headerlink" title="2.现金支付"></a>2.现金支付</h5><p>与里程支付类似，保存的表不同</p>
<h3 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h3><h4 id="1-现金退款流程"><a href="#1-现金退款流程" class="headerlink" title="1.现金退款流程"></a>1.现金退款流程</h4><ol>
<li>确认支付订单存在且本次形成未结束</li>
<li>确认：支付金额 &gt; 补偿其他用户金额 + 平台信息费</li>
<li>退款金额= 支付金额  -（补偿+平台费的）</li>
</ol>
<p><img src="/images/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%BC%80%E5%8F%91/image-20191204142746467.png" alt="image-20191204142746467"></p>
<ol start="4">
<li> 原路退回</li>
<li>添加退款记录表（RefundRecord）</li>
<li>调用支付宝或者微信退款接口</li>
<li> 新增现金支付结算流水（CashPaymentSettle）</li>
<li>新增平台账户流水（PlatformAccountDetail）</li>
<li>平台账户支出：将平台账户的钱减少，并新增平台账户支付流水</li>
<li>保存退款记录</li>
<li>补偿车主金额<ol>
<li>记录用户资金流水（UserCashAccountDetail）</li>
<li>获取用户现金记录总表信息（UserCashAccountTotal）</li>
<li>转账</li>
<li>创建支付结算记录</li>
</ol>
</li>
<li>补偿平台金额<ol>
<li> 创建现金支付结算信息</li>
</ol>
</li>
<li>更新现金支付记录</li>
</ol>
<p><img src="/images/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%BC%80%E5%8F%91/image-20191204151821654.png" alt="image-20191204151821654"></p>
]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>支付宝支付</tag>
      </tags>
  </entry>
  <entry>
    <title>左连接、右连接总结</title>
    <url>/2019/11/05/%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="常见连接图示："><a href="#常见连接图示：" class="headerlink" title="常见连接图示："></a>常见连接图示：</h3> <span id="more"></span>![img](/images/左连接、右连接总结/1090617-20190520233002027-1421406253.jpg) 

<h3 id="一对多问题："><a href="#一对多问题：" class="headerlink" title="一对多问题："></a>一对多问题：</h3><ul>
<li>group by</li>
</ul>
<p><strong>语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> o.`order_id`,o.`sale_amount`,l.`logistics_company_name` <span class="keyword">from</span> t_order o <span class="keyword">left</span> <span class="keyword">join</span> t_logistics l <span class="keyword">on</span> o.`order_id`<span class="operator">=</span>l.`order_id` <span class="keyword">group</span> <span class="keyword">by</span> o.`order_id`;</span><br></pre></td></tr></table></figure>



<p><img src="/images/%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%80%BB%E7%BB%93/1572934803804.png" alt="1572934803804"></p>
<ul>
<li><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> o.`order_id`,o.`sale_amount`,l.`logistics_company_name` <span class="keyword">from</span> t_order o <span class="keyword">left</span> <span class="keyword">join</span> t_logistics l <span class="keyword">on</span> o.`order_id`<span class="operator">=</span>l.`order_id`;</span><br></pre></td></tr></table></figure>



<p><img src="/images/%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%80%BB%E7%BB%93/1572934847097.png" alt="1572934847097"></p>
<ul>
<li><h4 id="group-by-和-distinct-比较"><a href="#group-by-和-distinct-比较" class="headerlink" title="group by 和 distinct 比较"></a>group by 和 distinct 比较</h4></li>
</ul>
<p><strong>1）、不同</strong></p>
<ul>
<li>distinct需要将col列中的全部内容都存储在一个内存中，可以理解为一个<code>hash结构，key为col的值</code>，最后计算hash结构中有多少个key即可得到结果。很明显，需要将所有不同的值都存起来。内存消耗可能较大。</li>
<li>而group by的方式是先将<code>col排序</code>。而数据库中的group一般使用sort的方法，即数据库会先对col进行排序。而排序的基本理论是，时间复杂为nlogn，空间为1。然后只要单纯的计数就可以了。优点是空间复杂度小，缺点是要进行一次排序，执行时间会较长。</li>
</ul>
<p><strong>2）、使用场景</strong></p>
<table>
<thead>
<tr>
<th>数据分布</th>
<th>去重方式</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>离散</td>
<td>group</td>
<td>distinct空间占用较大，在时间复杂度允许的情况下，group 可以发挥空间复杂度优势</td>
</tr>
<tr>
<td>集中</td>
<td>distinct</td>
<td>distinct空间占用较小，可以发挥时间复杂度优势</td>
</tr>
</tbody></table>
<p><strong>3）、两个极端</strong></p>
<ul>
<li>数据列的所有数据都一样，即去重计数的结果为1时，用distinct最佳。</li>
<li>如果数据列唯一，没有相同数值，用group 最好。</li>
</ul>
<ul>
<li><h3 id="distinct用法"><a href="#distinct用法" class="headerlink" title="distinct用法"></a>distinct用法</h3></li>
</ul>
<h4 id="1、作用于单列"><a href="#1、作用于单列" class="headerlink" title="1、作用于单列"></a>1、作用于单列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct name from A   #name去重</span><br></pre></td></tr></table></figure>

<h4 id="2、作用于多列"><a href="#2、作用于多列" class="headerlink" title="2、作用于多列"></a>2、作用于多列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct name, age from A  #根据name和age两个字段来去重的</span><br></pre></td></tr></table></figure>

<h4 id="3、COUNT统计"><a href="#3、COUNT统计" class="headerlink" title="3、COUNT统计"></a>3、COUNT统计</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> name) <span class="keyword">from</span> A;   #表中name去重后的数目</span><br></pre></td></tr></table></figure>

<p><code>注意</code>： count是不能统计多个字段的，下面的SQL在SQL Server和Access中都无法运行。</p>
<p>若想使用多个字段，请使用嵌套查询，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> name, age <span class="keyword">from</span> A) <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure>

<h4 id="4、distinct必须放在开头"><a href="#4、distinct必须放在开头" class="headerlink" title="4、distinct必须放在开头"></a>4、distinct必须放在开头</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age, <span class="keyword">distinct</span> name <span class="keyword">from</span> A;   #会提示错误，因为<span class="keyword">distinct</span>必须放在开头</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>1、能用<code>inner join</code> 尽量用inner join。<br>2、重复数据可能是表结构一对多造成的，这种情况往往是有意义的，比如订单和订单商品明细，算总价的时候，是需要sum多个明细的。<br>3、如果一对多的多确实没有意义，那就可以考虑用group by 或者 distinct。<br>4、具体结构问题具体分析。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>左连接、右连接</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库命名及设计规范</title>
    <url>/2019/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>整理如下：</p>
<h3 id="字段大小写："><a href="#字段大小写：" class="headerlink" title="字段大小写："></a>字段大小写：</h3><span id="more"></span>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682284231.png" alt="1572682284231"></p>
<h3 id="不同环境权限："><a href="#不同环境权限：" class="headerlink" title="不同环境权限："></a>不同环境权限：</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682418541.png" alt="1572682418541"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682483006.png" alt="1572682483006"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682497788.png" alt="1572682497788"></p>
<h3 id="表的命名："><a href="#表的命名：" class="headerlink" title="表的命名："></a>表的命名：</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682699459.png" alt="1572682699459"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682723290.png" alt="1572682723290"></p>
<h3 id="关于表字段的命名-："><a href="#关于表字段的命名-：" class="headerlink" title="关于表字段的命名 ："></a>关于表字段的命名 ：</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682756344.png" alt="1572682756344"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682844882.png" alt="1572682844882"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572682938948.png" alt="1572682938948"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572683760241.png" alt="1572683760241"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572683773226.png" alt="1572683773226"></p>
<h3 id="参考1"><a href="#参考1" class="headerlink" title="参考1"></a><a href="https://www.zhihu.com/question/26026443">参考1</a></h3><h3 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a><a href="https://www.zhihu.com/question/39967106/answer/121674339">参考2</a></h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572475362986.png" alt="1572475362986"></p>
<h3 id="参考3"><a href="#参考3" class="headerlink" title="参考3"></a><a href="https://blog.csdn.net/hunjianglong1991/article/details/79215141">参考3</a></h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1572475740948.png" alt="1572475740948"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引基本概念</title>
    <url>/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="为什么要使用索引？"><a href="#为什么要使用索引？" class="headerlink" title="为什么要使用索引？"></a>为什么要使用索引？</h3><ul>
<li>建立唯一性索引，保证数据每一行的唯一性</li>
<li>极大加快数据检索速度</li>
</ul>
<span id="more"></span>

<ul>
<li>将随机IO变为顺序IO</li>
<li>帮助服务器避免排序和临时表</li>
</ul>
<h3 id="为什么不对表中的每一个列创建索引呢？"><a href="#为什么不对表中的每一个列创建索引呢？" class="headerlink" title="为什么不对表中的每一个列创建索引呢？"></a>为什么不对表中的每一个列创建索引呢？</h3><ul>
<li>对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。 </li>
<li>索引需要占物理空间，数据表占数据空间之外，每一个索引还要占一定的物理空间，要建立聚簇索引，需要的空间会更大。 </li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
</ul>
<h3 id="索引是如何提高查询速度的？"><a href="#索引是如何提高查询速度的？" class="headerlink" title="索引是如何提高查询速度的？"></a>索引是如何提高查询速度的？</h3><ul>
<li>将无序的数据变成相对有序的数据（就像查目录一样）—&gt;类似于字典的目录</li>
</ul>
<h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3><ul>
<li>在经常搜索的列上加索引，提高搜索速度</li>
<li>经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度</li>
<li>经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度</li>
<li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>避免 where 子句中使用函数，造成索引失效</li>
<li>在使用InnoDB时使用与业务无关的自增主键作为主键，使用逻辑主键，不要使用业务主键</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗， MySQL 5.7可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h3 id="Mysql索引主要使用的两种数据结构"><a href="#Mysql索引主要使用的两种数据结构" class="headerlink" title="Mysql索引主要使用的两种数据结构"></a>Mysql索引主要使用的两种数据结构</h3><ol>
<li>哈希索引</li>
</ol>
<p>对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<ol start="2">
<li>BTree索引</li>
</ol>
<p>Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</p>
<h3 id="覆盖索引介绍"><a href="#覆盖索引介绍" class="headerlink" title="覆盖索引介绍"></a>覆盖索引介绍</h3><ol>
<li>什么是覆盖索引</li>
</ol>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<p>我们知道在InnoDB存储引擎中，<strong>如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。</strong>这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<ol start="2">
<li>覆盖索引使用实例 </li>
</ol>
<p>现在我创建了索引(username,age)，在查询数据的时候：select username , age from user where username = ‘Java’ and age = 22。<strong>要查询出的列在叶子节点都存在！所以，就不用回表。</strong></p>
<h3 id="选择索引和编写利用这些索引的查询的3个原则"><a href="#选择索引和编写利用这些索引的查询的3个原则" class="headerlink" title="选择索引和编写利用这些索引的查询的3个原则"></a>选择索引和编写利用这些索引的查询的3个原则</h3><ul>
<li><p>单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。</p>
</li>
<li><p>按顺序访问范围数据是很快的，这有两个原因。第一，顺序1/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。</p>
</li>
<li><p>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。</p>
</li>
</ul>
<p>参考字：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/1572922432321.png" alt="1572922432321"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>未来城市机器人墙住宅</title>
    <url>/2019/09/21/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/</url>
    <content><![CDATA[<p>​        关于未来城市未来城市住房问题，MIT社会学专家提出了方案，将住宅与机器人结合，在不增加过多住宅面积的同时，提供更多的生活必须空间，本质上就是与收纳问题类似，但通过了更高阶的解决方案。</p>
<span id="more"></span>

<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572613870047.png" alt="1572613870047"></p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572613898317.png" alt="1572613898317"></p>
<p>​        这种方案确实有效的从另一个方面解决未来重要城市的高房价，住宅紧缺问题，更神气的是，这个方案是五年年思考提出的成熟方案，在2019年已经实际基本完成并投入实践。</p>
<p>​        都知道学历是个好东西，但究竟好在哪里，大概只是好找工作而已，再深一点就是作为筛选条件，找出那些综合素质高的人，或许也不见得是真高。</p>
<p>​        但实际上，多学了那么多的东西，平时并不觉得，真正遇到问题的时候，才能显示出来，就是能够用更多的解决方案去解决问题，而不是依靠人的本能硬抗。</p>
<p>​        机器人墙的住宅，就是一个解决高放假问题很好的解决，虽然是社会学家，但并没有纠结于房价高是否公平，如何逆经济规律降低房价问题，而是提出了，在顺应社会规律的前提下，提高个人生活品质，在已有条件下，满足个人生活的几乎所有生活空间，其价值与袁隆平提高水稻产量有类似的效果。区别在于遇到问题，一个在于顶着困难，迎难而上，最终突破，一个是另辟蹊径，解决问题。</p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572614640217.png" alt="1572614640217"></p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572614670468.png" alt="1572614670468"></p>
<p>​        生活在大城市的打工仔，其实是很可怜的，每天对的生活就是公司和出租屋，甚至于同事平时问起都不是问什么时候到家，而是什么时候到宿舍。离家千百里，每月挣钱大几千，月月光。早八点赶地铁，玩八点到住处。眼镜几乎是天天对着屏幕，工作日从早起睁开眼到晚上睡觉，电脑屏幕+手机屏幕，所以我一直觉得电子设备，屏幕太重要了。</p>
<p>​        生活不该如此，二十多岁的年纪，才刚刚开始就要被结束。不应该吧！</p>
<p>​        会到出租屋，面对的也是惨白的墙壁和空旷的屋子，可能还有凌乱的衣服，这也不应该吧。所以谋求改变的第一个，应该是自律，总能够日常洗衣服，整理自己生活垃圾开始，比较上海这里的干湿分离，还是有点硬的。。日常生活整洁，东西不乱放，有助于生活规律。</p>
<p>​        生活规律起来，饮食习惯注意，例如晚上吃的太咸，或者味道过于刺激，会导致晚上睡眠不好，第二天起床后“睡不醒”的情况。晚上一大碗白米粥，第二天起来很舒服。</p>
<p>​        晚上尽量早点睡，非工作情况熬夜也是不自律，懒惰的一种表现，<a href="https://www.zhihu.com/question/267346432/answer/426452693">具体参考</a>，第一个回答。</p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572615782127.png" alt="1572615782127"><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572615813646.png" alt="1572615813646"></p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572615845701.png" alt="1572615845701"></p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572615864800.png" alt="1572615864800"></p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572615885426.png" alt="1572615885426"></p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572615900941.png" alt="1572615900941"></p>
<p>​        写的真是太好了，混乱的生活，是导致亮点一线，浑浑噩噩生活的根本原因。足够的自律，必然能够带动生活工作等方方面面。而未来城市机器人住宅，提高了这种可能性。</p>
<p>附视频地址： <a href="https://www.youtube.com/watch?v=Po6rzg87X5s">https://www.youtube.com/watch?v=Po6rzg87X5s</a> </p>
<p>（从第28分钟以后）</p>
<p><img src="/images/%E6%9C%AA%E6%9D%A5%E5%9F%8E%E5%B8%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A2%99%E4%BD%8F%E5%AE%85/1572617487488.png" alt="1572617487488"></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>权限管理系统总结</title>
    <url>/2019/11/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><p>权限管理负责所有系统用户的权限管理，菜单权限，重点操作权限，同时添加登录日志，权限授权日志，重点功能日志。</p>
<span id="more"></span>

<p>所有需要登录的、有审核功能的系统都会通过权限管理系统获取权限，报错操作信息，所以权限管理系统作为基础服务支撑，特别重要。</p>
<h3 id="职责描述："><a href="#职责描述：" class="headerlink" title="职责描述："></a>职责描述：</h3><ul>
<li>优化用户授权功能，修复bug，添加权限缓存功能；</li>
<li>开发登录、授权、重点功能日志审计功能；</li>
<li>新增系统接口授权功能。</li>
<li>部署并测试涉及到的所有系统，确保功能正常；</li>
</ul>
<h3 id="技术描述："><a href="#技术描述：" class="headerlink" title="技术描述："></a>技术描述：</h3><p>项目使用spring mvc开发方式，集成了shiro进行权限控制，通过redis管理缓存，底层通过spring data jpa，spring jdbc调用数据，集成logback输出日志文件，在tomcat上运行，部署多个供所有系统获取权限、接口鉴权使用。</p>
<h3 id="系统页面："><a href="#系统页面：" class="headerlink" title="系统页面："></a>系统页面：</h3><p><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573725806823.png" alt="1573725806823"></p>
]]></content>
      <categories>
        <category>项目总结</category>
        <category>权限管理</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>索引何时会失效</title>
    <url>/2019/11/07/%E7%B4%A2%E5%BC%95%E4%BD%95%E6%97%B6%E4%BC%9A%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<p>虽然你这列上建了索引，查询条件也是索引列，但最终执行计划没有走它的索引。下面是引起这种问题的几个关键点。</p>
<span id="more"></span>

<p><strong>列与列对比</strong><br>某个表中，有两列（id 和 c_id）都建了单独索引，下面这种查询条件不会走索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span>c_id;</span><br></pre></td></tr></table></figure>

<p>这种情况会被认为还不如走全表扫描。</p>
<p><strong>存在 NULL 值条件</strong><br>我们在设计数据库表时，应该尽力避免 NULL 值出现，如果非要不可避免的要出现 NULL 值，也要给一个 DEFAULT 值，数值型可以给 0、-1 之类的， 字符串有时候给空串有问题，就给一个空格或其他。如果索引列是可空的，是不会给其建索引的，索引值是少于表的 count (*) 值的，所以这种情况下，执行计划自然就去扫描全表了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>NOT 条件</strong><br>我们知道建立索引时，给每一个索引列建立一个条目，如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应的条目。反过来当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：&lt;&gt;、NOT、in、not exists</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">&lt;&gt;</span><span class="number">500</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test_02 <span class="keyword">where</span> test_02.id<span class="operator">=</span>test.id);</span><br></pre></td></tr></table></figure>

<p><strong>LIKE 通配符</strong><br>当使用模糊搜索时，尽量采用后置的通配符，例如：name||’%’，因为走索引时，其会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么查索引就会很麻烦，比如查询所有姓张的人，就可以去搜索’张 %’。相反如果你查询所有叫‘明’的人，那么只能是 % 明。这时候索引如何定位呢？前匹配的情况下，执行计划会更倾向于选择全表扫描。后匹配可以走 INDEX RANGE SCAN。<br>所以业务设计的时候，尽量考虑到模糊搜索的问题，要更多的使用后置通配符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> name <span class="keyword">like</span> 张<span class="operator">||</span><span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>条件上包括函数</strong><br>查询条件上尽量不要对索引列使用函数，比如下面这个 SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="built_in">upper</span>(name)<span class="operator">=</span><span class="string">&#x27;SUNYANG&#x27;</span>;</span><br></pre></td></tr></table></figure>


<p>这样是不会走索引的，因为索引在建立时会和计算后可能不同，无法定位到索引。但如果查询条件不是对索引列进行计算，那么依然可以走索引。比如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> name<span class="operator">=</span><span class="built_in">upper</span>(<span class="string">&#x27;sunyang&#x27;</span>);</span><br><span class="line"><span class="comment">--INDEX RANGE SCAN</span></span><br></pre></td></tr></table></figure>


<p>这样的函数还有：to_char、to_date、to_number、trunc 等</p>
<p><strong>复合索引前导列区分大</strong><br>当复合索引前导列区分小的时候，我们有 INDEX SKIP SCAN，当前导列区分度大，且查后导列的时候，前导列的分裂会非常耗资源，执行计划想，还不如全表扫描来的快，然后就索引失效了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> owner<span class="operator">=</span><span class="string">&#x27;sunyang&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>数据类型的转换</strong><br>当查询条件存在隐式转换时，索引会失效。比如在数据库里 id 存的 number 类型，但是在查询时，却用了下面的形式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sunyang <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Connect By Level</strong><br>使用 connect by level 时，不会走索引。</p>
<p><strong>谓词运算</strong><br>我们在上面说，不能对索引列进行函数运算，这也包括加减乘除的谓词运算，这也会使索引失效。建立一个 sunyang 表，索引为 id，看这个 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sunyang <span class="keyword">where</span> id<span class="operator">/</span><span class="number">2</span><span class="operator">=</span>:type_id;</span><br></pre></td></tr></table></figure>


<p>这里很明显对索引列 id 进行了’/2’除二运算，这时候就会索引失效，这种情况应该改写为：</p>
<p><code>select * from sunyang where id=:type_id*2;</code><br>就可以使用索引了。</p>
<p><strong>Vistual Index</strong><br>先说明一下，虚拟索引的建立是否有用，需要看具体的执行计划，如果起作用就可以建一个，如果不起作用就算了。<br>普通索引这么建：</p>
<p><code>create index idx_test_id on test(id);</code><br>虚拟索引 Vistual Index 这么建：</p>
<p>create index idx_test_id on test(id) nosegment;<br>做了一个实验，首先创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_1116( </span><br><span class="line">id number, </span><br><span class="line">a number </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test_1116_id <span class="keyword">on</span> test_1116(id); </span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_test_1116_a <span class="keyword">on</span> test_1116(a)nosegment; </span><br></pre></td></tr></table></figure>

<p>其中 id 为普通索引，a 为虚拟索引。<br>在表中插入十万条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> .. <span class="number">100000</span> loop </span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> test_1116 <span class="keyword">values</span> (i,i); </span><br><span class="line"><span class="keyword">end</span> loop; </span><br><span class="line"><span class="keyword">commit</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br></pre></td></tr></table></figure>


<p>接着分别去执行下面的 SQL 看时间，由于在内网机做实验，图贴不出来，数据保证真实性。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> test_1116;</span><br><span class="line"><span class="comment">--第一次耗时：0.061秒</span></span><br><span class="line"><span class="comment">--第二次耗时：0.016秒</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(a) <span class="keyword">from</span> test_1116; </span><br><span class="line"><span class="comment">--第一次耗时：0.031秒</span></span><br><span class="line"><span class="comment">--第二次耗时：0.016秒</span></span><br></pre></td></tr></table></figure>

<p>因为在执行过一次后，oracle 对结果集缓存了，所以第二次执行耗时不走索引，走内存就都一样了。<br>可以看到在这种情况下，虚拟索引比普通索引快了一倍。<br>具体虚拟索引的使用细节，这里不再展开讨论。</p>
<p><strong>Invisible Index</strong><br>Invisible Index 是 oracle 11g 提供的新功能，对优化器（还接到前面博客里讲到的 CBO 吗）不可见，我感觉这个功能更主要的是测试用，假如一个表上有那么多索引，一个一个去看执行计划调试就很慢了，这时候不如建一个对表和查询都没有影响的 Invisible Index 来进行调试，就显得很好了。<br>通过下面的语句来操作索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> index idx_test_id invisible;</span><br><span class="line"><span class="keyword">alter</span> index idx_test_id visible;</span><br></pre></td></tr></table></figure>


<p>如果想让 CBO 看到 Invisible Index，需要加入这句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> optimizer_use_invisible_indexes <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>





<p><a href="https://blog.csdn.net/bless2015/article/details/84134361?locationNum=3">参考</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>药店智能监管系统开发总结</title>
    <url>/2019/11/15/%E8%8D%AF%E5%BA%97%E6%99%BA%E8%83%BD%E7%9B%91%E7%AE%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><p>为上海药店APP提供业务及数据支撑，数据及图片审核，新闻发布等功能。APP上出现的所有信息、图片，审核后才能显示，包括市民上传图片，市民对药店的评论，药店回复，反馈意见，市民积分，过期药品回收上报等。</p>
<span id="more"></span>

<h3 id="职责描述："><a href="#职责描述：" class="headerlink" title="职责描述："></a>职责描述：</h3><ul>
<li>开发新闻发布、新闻、问答审核功能；</li>
<li>开发市民评论，药店回复审核功能；</li>
<li>开发图片审核，药店回收上报，审核历史功能；</li>
<li>开发市民积分抵扣，过期药品回收，市民积分管理功能；</li>
</ul>
<h3 id="技术描述："><a href="#技术描述：" class="headerlink" title="技术描述："></a>技术描述：</h3><p>系统主要为spring boot，mybatis plus，layUI 构成，集成redis保存验证码等缓存信息，添加敏感词过滤功能识别市民评论等信息，添加百度Ueditor进行新闻文本编辑功能，生成Excel导出，解析导入Excel信息功能。</p>
<h3 id="系统页面："><a href="#系统页面：" class="headerlink" title="系统页面："></a>系统页面：</h3><p><img src="/images/%E8%8D%AF%E5%BA%97%E6%99%BA%E8%83%BD%E7%9B%91%E7%AE%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573909534405.png" alt="1573909534405"></p>
<p><img src="/images/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573797919501.png" alt="1573797919501"></p>
<p><img src="/images/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573797954060.png" alt="1573797954060"></p>
<p><img src="/images/%E4%B8%8A%E6%B5%B7%E8%8D%AF%E5%BA%97%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/1573797965419.png" alt="1573797965419"></p>
]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>药店智能监管总结</tag>
      </tags>
  </entry>
  <entry>
    <title>权限管理系统整体设计</title>
    <url>/2019/11/09/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="** 前言**"></a>** 前言**</h3><p>目前在公司负责权限这块，所以对权限这块的设计比较熟悉，公司采用微服务架构，权限系统自然就独立出来了，</p>
<span id="more"></span>

<p>其他业务系统包括商品中心，订单中心，用户中心，仓库系统，小程序，多个 APP 等十几个系统和终端。</p>
<h3 id="权限模型"><a href="#权限模型" class="headerlink" title="** 权限模型**"></a>** 权限模型**</h3><p>迄今为止最为普及的权限设计模型是 RBAC 模型，基于角色的访问控制（Role-Based Access Control)。</p>
<h4 id="1、-RBAC0-模型"><a href="#1、-RBAC0-模型" class="headerlink" title="1、 RBAC0 模型"></a>1、 RBAC0 模型</h4><p>RBAC0 模型如下:</p>
<p><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382313.webp" alt="img"></p>
<p>这是权限最基础也是最核心的模型，它包括用户 / 角色 / 权限，其中用户和角色是多对多的关系，角色和权限也是多对多的关系。</p>
<p>用户是发起操作的主体，按类型分可分为 2B 和 2C 用户，可以是后台管理系统的用户，可以是 OA 系统的内部员工，也可以是面向 C 端的用户，比如阿里云的用户。<br>角色起到了桥梁的作用，连接了用户和权限的关系，每个角色可以关联多个权限，同时一个用户关联多个角色，那么这个用户就有了多个角色的多个权限。有人会问了为什么用户不直接关联权限呢？</p>
<p>在用户基数小的系统，比如 20 个人的小系统，管理员可以直接把用户和权限关联，工作量并不大，选择一个用户勾选下需要的权限就完事了。但是在实际企业系统中，用户基数比较大，其中很多人的权限都是一样的，就是个普通访问权限，如果管理员给 100 人甚至更多授权，工作量巨大。这就引入了 “角色 (Role)” 概念，一个角色可以与多个用户关联，管理员只需要把该角色赋予用户，那么用户就有了该角色下的所有权限，这样设计既提升了效率，也有很大的拓展性。<br>权限是用户可以访问的资源，包括页面权限、操作权限、数据权限。</p>
<p>页面权限：即用户登录系统可以看到的页面，由菜单来控制，菜单包括一级菜单和二级菜单，只要用户有一级和二级菜单的权限，那么用户就可以访问页面</p>
<p>操作权限： 即页面的功能按钮，包括查看、新增、修改、删除、审核等，用户点击删除按钮时，后台会校验用户角色下的所有权限是否包含该删除权限，如果是，就可以进行下一步操作，反之提示无权限。有的系统要求 “可见即可操作”，意思是如果页面上能够看到操作按钮，那么用户就可以操作，要实现此需求，这里就需要前端来配合，前端开发把用户的权限信息缓存，在页面判断用户是否包含此权限，如果有，就显示该按钮，如果没有，就隐藏该按钮。某种程度上提升了用户体验，但是在实际场景可自行选择是否需要这样做。</p>
<p>数据权限：数据权限就是用户在同一页面看到的数据是不同的，比如财务部只能看到其部门下的用户数据，采购部只看采购部的数据，在一些大型的公司，全国有很多城市和分公司，比如杭州用户登录系统只能看到杭州的数据，上海用户只能看到上海的数据，解决方案一般是把数据和具体的组织架构关联起来，举个例子，再给用户授权的时候，用户选择某个角色同时绑定组织如财务部或者合肥分公司，那么该用户就有了该角色下财务部或合肥分公司下的的数据权限。<br><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382322.webp" alt="img"></p>
<p>以上是 RBAC 的核心设计及模型分析，此模型也叫做 RBAC0，而基于核心概念之上，RBAC 还提供了扩展模式。包括 RBAC1、RBAC2、RBAC3 模型。</p>
<p>下面介绍这三种类型</p>
<h4 id="2、RBAC1-模型"><a href="#2、RBAC1-模型" class="headerlink" title="2、RBAC1 模型"></a>2、RBAC1 模型</h4><p><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382336.webp" alt="img"></p>
<p>此模型引入了角色继承 (Hierarchical Role) 概念，即角色具有上下级的关系，角色间的继承关系可分为一般继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构，实现角色间的单继承。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。</p>
<h4 id="3、-RBAC2-模型"><a href="#3、-RBAC2-模型" class="headerlink" title="3、 RBAC2 模型"></a>3、 RBAC2 模型</h4><p>基于核心模型的基础上，进行了角色的约束控制，RBAC2 模型中添加了责任分离关系，其规定了权限被赋予角色时，或角色被赋予用户时，以及当用户在某一时刻激活一个角色时所应遵循的强制性规则。责任分离包括静态责任分离和动态责任分离。</p>
<p>主要包括以下约束:</p>
<p>互斥角色：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。比如财务部有会计和审核员两个角色，他们是互斥角色，那么用户不能同时拥有这两个角色，体现了职责分离原则。</p>
<p>基数约束：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配</p>
<p>先决条件角色：即用户想获得某上级角色，必须先获得其下一级的角色。</p>
<h4 id="4、RBAC3-模型"><a href="#4、RBAC3-模型" class="headerlink" title="4、RBAC3 模型"></a>4、RBAC3 模型</h4><p>即最全面的权限管理，它是基于 RBAC0, 将 RBAC1 和 RBAC2 进行了整合</p>
<h4 id="5、用户组"><a href="#5、用户组" class="headerlink" title="5、用户组"></a>5、用户组</h4><p>当平台用户基数增大，角色类型增多时，而且有一部分人具有相同的属性，比如财务部的所有员工，如果直接给用户分配角色，管理员的工作量就会很大，如果把相同属性的用户归类到某用户组，那么管理员直接给用户组分配角色，用户组里的每个用户即可拥有该角色，以后其他用户加入用户组后，即可自动获取用户组的所有角色，退出用户组，同时也撤销了用户组下的角色，无须管理员手动管理角色。<br>根据用户组是否有上下级关系，可以分为有上下级的用户组和普通用户组。</p>
<p>具有上下级关系的用户组：最典型的例子就是部门和职位，可能多数人没有把部门职位和用户组关联起来吧。当然用户组是可以拓展的，部门和职位常用于内部的管理系统，如果是面向 C 端的系统，比如淘宝网的商家，商家自身也有一套组织架构，比如采购部，销售部，客服部，后勤部等，有些人拥有客服权限，有些人拥有上架权限等等，所以用户组是可以拓展的。</p>
<p>普通用户组：即没有上下级关系，和组织架构，职位都没有关系，也就是说可以跨部门，跨职位，举个例子，某电商后台管理系统，有拼团活动管理角色，我们可以设置一个拼团用户组，该组可以包括研发部的后台开发人员，运营部的运营人员，采购部的人员等等。</p>
<p>每个公司都会涉及到到组织和职位，下面就重点介绍这两个。</p>
<h4 id="5-1-组织"><a href="#5-1-组织" class="headerlink" title="5.1 组织"></a>5.1 组织</h4><p>常见的组织架构如下图:<br><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382348.webp" alt="img"></p>
<p>我们可以把组织与角色进行关联，用户加入组织后，就会自动获得该组织的全部角色，无须管理员手动授予，大大减少工作量，同时用户在调岗时，只需调整组织，角色即可批量调整。组织的另外一个作用是控制数据权限，把角色关联到组织，那么该角色只能看到该组织下的数据权限。</p>
<h4 id="5-2-职位"><a href="#5-2-职位" class="headerlink" title="5.2 职位"></a>5.2 职位</h4><p>假设财务部的职位如下图:</p>
<p><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382367.webp" alt="img"></p>
<p>每个组织部门下都会有多个职位，比如财务部有总监，会计，出纳等职位，虽然都在同一部门，但是每个职位的权限是不同的，职位高的拥有更多的权限。总监拥有所有权限，会计和出纳拥有部分权限。特殊情况下，一个人可能身兼多职。</p>
<h4 id="6、含有组织-职位-用户组的模型"><a href="#6、含有组织-职位-用户组的模型" class="headerlink" title="6、含有组织 / 职位 / 用户组的模型"></a>6、含有组织 / 职位 / 用户组的模型</h4><p>根据以上场景，新的权限模型就可以设计出来了，如下图:<br><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382370.webp" alt="img"><br>根据系统的复杂度不同，其中的多对多关系和一对一关系可能会有变化。</p>
<p>在单系统且用户类型单一的情况下，用户和组织是一对一关系，组织和职位是一对多关系，用户和职位是一对一关系，组织和角色是一对一关系，职位和角色是一对一关系，用户和用户组是多对对关系，用户组和角色是一对一关系，当然这些关系也可以根据具体业务进行调整。模型设计并不是死的，如果小系统不需要用户组，这块是可以去掉的。</p>
<p>分布式系统且用户类型单一的情况下，到这里权限系统就会变得很复杂，这里就要引入了一个 “系统” 概念，此时系统架构是个分布式系统，权限系统独立出来，负责所有的系统的权限控制，其他业务系统比如商品中心，订单中心，用户中心，每个系统都有自己的角色和权限，那么权限系统就可以配置其他系统的角色和权限。</p>
<p>分布式系统且用户类型多个的情况下，比如淘宝网，它的用户类型包括内部用户、商家、普通用户、内部用户登录多个后台管理系统，商家登录商家中心，这些做权限控制，如果你作为架构师，该如何来设计呢？大神可以在评论区留言交流哦！</p>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="** 授权流程**"></a>** 授权流程**</h3><p>授权即给用户授予角色，按流程可分为手动授权和审批授权。权限中心可同时配置这两种，可提高授权的灵活性。</p>
<p>手动授权：管理员登录权限中心为用户授权，根据在哪个页面授权分为两种方式：给用户添加角色，给角色添加用户。</p>
<p>给用户添加角色就是在用户管理页面，点击某个用户去授予角色，可以一次为用户添加多个角色；给角色添加用户就是在角色管理页面，点击某个角色，选择多个用户，实现了给批量用户授予角色的目的。</p>
<p>审批授权：即用户申请某个职位角色，那么用户通过 OA 流程申请该角色，然后由上级审批，该用户即可拥有该角色，不需要系统管理员手动授予。</p>
<h3 id="表结构"><a href="#表结构" class="headerlink" title="** 表结构**"></a>** 表结构**</h3><p>有了上述的权限模型，设计表结构就不难了，下面是多系统下的表结构，简单设计下，主要提供思路。</p>
<p><img src="/images/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/640-1573273382381.webp" alt="img"></p>
<h3 id="权限框架"><a href="#权限框架" class="headerlink" title="** 权限框架**"></a>** 权限框架**</h3><p><strong>Apache Shrio</strong></p>
<p><strong>Spring Security</strong></p>
<p>在项目中可以采用其中一种框架，它们的优缺点以及如何使用会在后面的文章中详细介绍。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="** 结语**"></a>** 结语**</h3><p>权限系统可以说是整个系统中最基础，同时也可以很复杂的，在实际项目中，会遇到多个系统，多个用户类型，多个使用场景，这就需要具体问题具体分析，但最核心的 RBAC 模型是不变的，我们可以在其基础上进行扩展来满足需求。</p>
<p><a href="https://mp.weixin.qq.com/s/7sWwq6Ou8YqrXyE19V7LZQ">参考</a></p>
]]></content>
      <categories>
        <category>权限管理</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备阶段总结</title>
    <url>/2019/11/07/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="2019-11-7"><a href="#2019-11-7" class="headerlink" title="2019.11.7"></a>2019.11.7</h3><p>整理大项 </p>
<span id="more"></span>

<p>分步查询，但感觉并没有学到实际的东西，还是皮毛</p>
<p>找到公众号，准们针对面试进行总结，之后在扩展</p>
<p>类似应试教育，，，从面试题开始，扩散，问的不外乎还是那些东西</p>
<ol>
<li>我的优势，在于现在项目中用的是微服务，分布式的开发部署方式，把这块好好搞清楚。包括权限管理，网关，分布式session共享，数据库设计，项目前后端整体开发流程，线上项目排错；</li>
<li>需要补的就是面试常见的这些东西，优势方面还需要加强。</li>
</ol>
<h3 id="2019-11-9"><a href="#2019-11-9" class="headerlink" title="2019.11.9"></a>2019.11.9</h3><p>今天上午九点半起来，忙完就快十一点了，然后学习到近三点，吃饭吃撑了，然后看视频到六点多，现在在写写日记看看知乎，准备继续学习，身体有点疲惫，同时想到，我觉得我不应该这么菜，这么点学习任务，一直又拖了一周才完成大部分，我不应该这么菜吧。</p>
<p>到八点出去转转，应该把自己的生活安排满一点，这样时间也就能够更加高效节约。</p>
<p>又兜兜转转看看卖ipad的，看到八点十分了。</p>
<p>我发现学习个三四个小时之后，还是要运动一下，不然接下来效率很低，还有在家自学的时候，还是要把番茄工作法用起来的，不然时间过得很快。</p>
<p>分辨率高屏幕真的很清</p>
<p>吃的太多真的很当务事</p>
<p>运动有利于自身的专注</p>
<p>还有早点睡</p>
<p>要吃的清单，有利于专注</p>
<p>品栋数码的要比尾巴贵个至少两百，但是买着很放心（ipad pro9.7）</p>
<p>晚上尽量看半个小时的书，早上运动一下，阶段性的运行是提高</p>
<p>晚上睡前打坐20分钟，早上站桩30分钟，身体好</p>
<h3 id="2019-11-10"><a href="#2019-11-10" class="headerlink" title="2019.11.10"></a>2019.11.10</h3><p>把分辨率调到100%，13村的屏幕也很清晰，所以屏幕不清也可能是分辨率的问题。</p>
<p>今天    整理之余要学学五笔打字，放了太久，又得重新学了。</p>
<ul>
<li>spring aop实现</li>
<li>hashMap相关，list的排序取值</li>
<li>二十个经典的问题整理</li>
<li>多线程面试题</li>
</ul>
<p>九点半起来，洗刷收拾，然后去吃包子。</p>
<p>整理了一片唐家三少15年的回复，算是自己经常想起来的东西，找着很麻烦，不如收藏了 <a href="https://getemoji.com/">😋</a>  😂 </p>
<p>刚整理了hashMap的hashCode和equals的用法，已经三四个小时了，已经学不进去了。出去转转，买点鱼煎煎。</p>
<p>问题整理：</p>
<p>一、介绍自己对 spring 的理解？<del>你怎么理解 Ioc</del>，AOP？</p>
<p>二、异常？项目中如何处理异常？运行时异常和受检查异常的区别？为什么要处理异常？</p>
<p>三、你对 dubbo、zookeeper、restful 的理解？以及使用这些的好处？</p>
<p>四、线程？场景举例，我现在记得的是这样的一个例子。有一个含有十个元素的数组，现在有两个线程？如何同时输出前五个元素和后五个元素？如何先输出前五个，再输出后五个？</p>
<p>五、hashMap 的实现原理？concurrentHashMap 的原理？</p>
<p>六、数据库优化怎么做？</p>
<p>七、除了 ssh 这些你还会什么？</p>
<p><img src="/images/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/1573386187876.png" alt="1573386187876"></p>
<p><del><a href="https://futuresuperstar.github.io/html/http">关于 http</a></del></p>
<p><a href="https://futuresuperstar.github.io/html/negativepositivelock">悲观锁和乐观锁</a></p>
<p><a href="https://futuresuperstar.github.io/html/interview">面试题总结</a></p>
<p><a href="https://futuresuperstar.github.io/html/springboot/problems">springboot 常见问题</a></p>
<p>websocket </p>
<p>今天看了这么多，发现对于一些hashCode的实现原理、算法，spring aop实现原理，还是看不懂，一些比较深的东西，看完整理了但效果并不大，还是需要从比较基础的看起，对于一些比较深入的方面，比如spring，看书还是最快的途径，对于多线程的东西，要从是什么，怎么实现看起，而不是一开始就去看决绝哪些案例，问题等等。</p>
<p>还有下周，看书的同时，要开始把自己的项目，项目中用到的技术，项目中遇到的问题，整个整理出来，要对自己做过的项目有足够清晰的认识，这个我觉得还是可以的，问题不大，因为项目中的问题虽然之前疏于整理，但都是思考过得，也要看一看之前的记录。</p>
<p>面试题太多了，看不完的，要有自己的进度，一步一步来。主要是要能有效的输入，想办法把效率提升上来。</p>
<h3 id="2019-11-12"><a href="#2019-11-12" class="headerlink" title="2019.11.12"></a>2019.11.12</h3><p>今天是开始总结项目的第一天，效率并不高，但是弄懂了登录相关的内容，包括cookie和session的使用，看了form表单的提交方式，ajax的知识复习了一下，晚上睡一会儿真的是一天最好的休息。</p>
<p>看了看maven，发现旧的知识真的是没法看，如果发现现在看的东西看不懂，那就立马放弃，再继续找时间点新的，相关内容的知识，不然不仅不利于理解，还浪费时间，博客园的文章，相对深度还是好一点。</p>
<ul>
<li><p><del>mybatis</del></p>
</li>
<li><p><del>redis</del></p>
</li>
<li><p>http与https区别</p>
</li>
<li><p>mybatis plus</p>
</li>
<li><p>多线程</p>
</li>
<li><p>foward跳转的区别</p>
</li>
<li><p>整理追溯申报内容</p>
</li>
<li><p>Oracle怎么取出重复内容，分页</p>
</li>
<li><p>AOP</p>
</li>
<li><p> 事务的理解 </p>
</li>
<li><p> 数据库锁 </p>
</li>
<li><p><a href="https://github.com/Snailclimb/JavaGuide">面试题整理</a></p>
</li>
<li><p><a href="https://frank-lam.github.io/fullstack-tutorial/#/introduction?id=%e5%8d%81%e3%80%81%e5%b7%a5%e5%85%b7">Java基础</a> <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md">基础2</a>  <a href="https://www.nowcoder.com/tutorial/94/c2a86e4040ee4bdcbd06906a5b5064d6">基础3</a> </p>
</li>
<li><p><a href="https://www.v2ex.com/t/530811">问题整理</a> <a href="https://www.v2ex.com/t/609752">问题2</a> <a href="https://www.nowcoder.com/discuss/339947?type=all&order=time&pos=&page=1">问题3</a> </p>
</li>
<li><p><a href="https://github.com/crossoverJie/JCSprout">扩展</a> </p>
</li>
<li><p><a href="http://c.biancheng.net/view/1338.html">数据结构、设计模式</a></p>
</li>
</ul>
<p><strong>系统总结：</strong></p>
<ul>
<li><p><del>追溯申报：</del></p>
<p>重点：spring boot ，restful，redis，分布式，Nginx，spring data jpa，shiro，logback，oracle</p>
<p>产品管理，权限管理，企业管理，参数管理，其他业务系统</p>
<p>自查报告</p>
<p>重点：Nginx，负责两个月内近两万家企业进行上报流程，shiro，redis，oracle，dblink，存储过程生产报表</p>
</li>
<li><p>上海药店</p>
<p>重点：前后端分离，接口开发，后台管理功能开发，Echart图表，</p>
</li>
<li><p>后台管理</p>
<p>重点：layUI，Ueditor，mybatis plus，mybatis，高德地图接口，echart图表，后台管理，</p>
</li>
<li><p><del>器械召回</del></p>
<p>重点：全程独立开发，需求分析–&gt;原型设计–&gt;数据库设计–&gt;底层搭建–&gt;功能开发–&gt;功能完善–&gt;后期维护</p>
<p> <strong>Axure</strong>原型设计，powerDesigner数据库设计，状态模式审核流程控制，thyemleaf，ace前端框架，redis，spring boot，echart，poi，</p>
</li>
<li><p><del>权限管理</del></p>
<p>重点：用户授权，登录日志，授权日志，重点功能日志，接口权限管理</p>
<p>其他系统，在跳转连接时，校验是否有该权限，否则会导致任何用户只要显示菜单就能使用功能的问题。</p>
</li>
<li><p><del>gateway网关</del></p>
<p>重点：独立开发，spring cloud gateway，feign，第三方接口权限校验(密钥)，eurake</p>
</li>
</ul>
<ol>
<li>简历</li>
<li>博客里介绍系统，描述自己做了哪些功能，功能细节</li>
<li>重点用了哪些技术</li>
<li>重点技术回顾</li>
</ol>
<p>那个叫岛娘的真的很厉害，这个没办法，得认。</p>
<p>关于libra币的听证会，其实这个自己是很早就知道的，所以听不懂英语，真是很难受，这已经是自己需要的工具了。</p>
<p>我并不希望自己变成一个很老派的人，变得很难去接受新知识，这是不对的，我更希望自己是一个探索者，所有的东西，原理是共通的，我希望把这个道找出来，探索。</p>
<p>尽管现在在听红楼梦，真的很享受，但是。。。</p>
<p>用hokilo芦荟胶，，真的会让脸变得很干。</p>
<p>V2EX，要有足够的敏感，大佬常逛的论坛，必定不错。</p>
<h3 id="2019-11-13"><a href="#2019-11-13" class="headerlink" title="2019.11.13"></a>2019.11.13</h3><p>十点半睡觉还是好的，不能等到12点半了，早上闹钟都没听到。</p>
<ul>
<li><p>找十套Java开发面试题做做，，，太难了</p>
<p>每天一套面试题吧</p>
</li>
</ul>
<p>我太难了。。。</p>
<p>现在想买个ipad，可能也就2000块，但是对我现在来说，还欠着6000的助学贷款，2k真的很难，唯有努力复习，好好面试，争取涨工资，唯一途径了。</p>
<p>现在面试需要会的太多了，但是别怂，一口吃不成胖子，还是要扎扎实实，好好看，好好总结。</p>
<hr>
<h3 id="2019-11-16"><a href="#2019-11-16" class="headerlink" title="2019.11.16"></a>2019.11.16</h3><ul>
<li>负责系统功能维护，细节优化、线上bug修复，其他系统数据对接接口开发，新增子系统开发，代码优化等。系统使用spring boot微服务框架、maven搭建，通过spring data jpa和spring jdbc进行数据交互,在用户登录和获取用户权限时通过Redis获取缓存和权限数据，通过shiro自定义拦截器进行权限认证和授权，添加Lombok进行实体类的优化，通过RestTemplate进行产品管理，参数管理、权限管理、短信系统等接口服务的调用实现数据交互。前端通过Thymeleaf和Model实现数据交互，通过ajax进行数据异步调用。</li>
<li>企业自查报告上报子系统：18年年末调整了子系统“上海市企业自查报告录入模块”功能，负责整个系统的业务功能调整，企业上报中产生的问题解决，通过Nginx实现负载均衡，解决并发量较高问题，最终实现两个月内近两万家企业完成上报，期间未出现较大的问题。</li>
<li>医疗器械召回子系统：该系统是从需求分析，原型设计，数据库设计，代码底层开发到业务功能实现由本人独自完成的，并在系统完成后与客户对接，进行需求确认及功能调整。解决了从药品企业进行产品召回的申请到监管部门审核的整个业务流程，完成了整个企业端和监管端业务管理系统的开发。</li>
<li>不同系统接口调用和规则校验调整：负责调整系统和多个服务间接口调用规则，系统使用RestTemplate进行数据传输和接口调用，header中添加requestTime和token进行加密，服务端通过拦截器获取，校验requestTime十分中内有效，并通过特定规则加密与token对比，确认链接校验权限，提高接口安全性。</li>
</ul>
<p>漏洞：</p>
<ol>
<li>权限</li>
<li>文件下载</li>
<li>cors</li>
<li>shiro升级</li>
</ol>
<h3 id="2019-11-17"><a href="#2019-11-17" class="headerlink" title="2019.11.17"></a>2019.11.17</h3><ol>
<li><del>把mybatis plus看完</del></li>
<li><del>运动，吃饭</del></li>
<li>把spring aop看完</li>
<li>把多线程，锁机制看完</li>
<li>根据顺序，把自己在简历上写过的东西，整个看一遍</li>
<li>投简历</li>
<li>Java 8特性</li>
<li>雪花算法</li>
</ol>
<h3 id="2019-11-18"><a href="#2019-11-18" class="headerlink" title="2019.11.18"></a>2019.11.18</h3><p>把自己项目中的东西总结下来</p>
<h4 id="上海药店"><a href="#上海药店" class="headerlink" title="上海药店"></a>上海药店</h4><ol>
<li><p>IM环信群聊功能</p>
<ul>
<li>注册</li>
<li>建群</li>
<li>是否在线</li>
</ul>
<p>1<del>、确定环信群组是否存在</del><img src="/images/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/1574042949311.png" alt="1574042949311"><img src="/images/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/1574042960798.png" alt="1574042960798"></p>
<ol start="2">
<li><del>极光推送jPush</del></li>
<li>大数据分析</li>
<li>高德地图，点位获取</li>
<li>生成二维码，扫描获取信息</li>
<li>图片服务器</li>
<li>layUI使用</li>
<li>拦截器登录</li>
</ol>
</li>
</ol>
<h3 id="泛微面试准备"><a href="#泛微面试准备" class="headerlink" title="泛微面试准备"></a>泛微面试准备</h3><ol>
<li><a href="https://www.cnblogs.com/javazhiyin/p/11865307.html?utm_source=gold_browser_extension">基础100题</a> </li>
<li><a href="https://blog.csdn.net/u011514810/article/details/60777176">多线程题</a> <a href="https://juejin.im/post/5a73cbbff265da4e807783f5">2</a></li>
<li>泛微整理出的题</li>
<li><a href="https://www.wentz.top/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">项目总结</a></li>
</ol>
<p>地铁上把自己的博客好好看看</p>
<h3 id="蜂社信息面试准备"><a href="#蜂社信息面试准备" class="headerlink" title="蜂社信息面试准备"></a>蜂社信息面试准备</h3><ol>
<li><p>数据结构、算法</p>
<p>基本排序类型</p>
</li>
<li><p>设计模式</p>
<p>看三个</p>
</li>
<li><p><del>spring AOP</del></p>
</li>
<li><p><del>spring boot常见面试题</del></p>
</li>
<li><p>spring cloud常见</p>
</li>
<li><p>mybatis</p>
</li>
<li><p>maven常见面试题</p>
</li>
<li><p>git常见面试题</p>
</li>
<li><p>mongDB</p>
</li>
<li><p>postgresql</p>
</li>
<li><p>代码编写规范</p>
</li>
<li><p>多线程，分布式，高并发，高负载，系统调优，解决办法</p>
</li>
<li><p>微服务框架搭建</p>
<ol>
<li>所谓空间点算法，广度深度优先算法</li>
</ol>
</li>
</ol>
<h3 id="新致-交行外包"><a href="#新致-交行外包" class="headerlink" title="新致 - 交行外包"></a>新致 - 交行外包</h3><p>更新语句：</p>
<p>update TBL_ENP_WT t set case_id = (select case_id from tbl_zcbg_case where enp_id=t.business_key and year=2018)</p>
<p>SELECT t1.business_key,t2.enp_id,t2.case_id FROM TBL_ENP_WT t1</p>
<p>left join tbl_zcbg_case t2<br>on t1.business_key = t2.enp_id<br>and year = 2018</p>
<p><img src="/images/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/1574149518227.png" alt="1574149518227"></p>
<p><a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU1Nzg4NjgyMw==&amp;scene=124#wechat_redirect">https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU1Nzg4NjgyMw==&amp;scene=124#wechat_redirect</a></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>追溯申报系统总结</title>
    <url>/2019/11/11/%E8%BF%BD%E6%BA%AF%E7%94%B3%E6%8A%A5%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="项目描述："><a href="#项目描述：" class="headerlink" title="项目描述："></a>项目描述：</h3><p>项目为器械经营企业产品追溯申报系统，分为企业端和监管端。</p>
<span id="more"></span>

<p>企业端主要负责本企业购销产品和申报新增产品，管理企业人员信息，上报企业自查信息，网络销售备案信息，对已销售产品进行召回，查看监管端公告和对监管端留言等功能；</p>
<p>监管端分为企业信息管理，企业上报信息管理，上报产品查询，发送短信，审核企业自查报告，主动召回产品报告，网络备案信息，发布公告和查看留言等。</p>
<h3 id="职责描述："><a href="#职责描述：" class="headerlink" title="职责描述："></a>职责描述：</h3><ul>
<li>开发企业和监管用户权限管理功能，修复用户权限漏洞；</li>
<li>优化产品购销关系导入导出功能，代码优化，sql优化；</li>
<li>优化注册、登录功能，添加滑动框校验登录；</li>
<li>开发企业检查信息上报功能，监管端信息管理功能；</li>
<li>独立负责后期日常系统维护，新增需求开发；</li>
<li>修复系统安全检索出的漏洞；</li>
</ul>
<h3 id="技术分析："><a href="#技术分析：" class="headerlink" title="技术分析："></a>技术分析：</h3><p>整体为追溯申报系统，子系统分为：器械召回系统，网络备案系统，自查报告系统，三方平台自查上报系统；服务系统分为权限管理，产品管理，企业管理，短信发送平台，参数管理，gateway网关。</p>
<p>系统用到的技术：spring boot，restTemplate API，spring date jpa，lombok，redis，joda-time，shiro，scheduled，logback，前端模版thymeleaf，Excel文件导入导出，sso单点登录，nginx。</p>
<p>系统采用spring boot框架开发，分布式部署的方式，将底层支撑拆分为微服务形式，不同系统之间调用通过restful api形式，底层通过spring data jpa和spring jdbc调用数据，实体类通过lombok优化基础方法。登录时通过调用权限管理获取登录用户权限，注册时用redis保存手机验证码。通过ScheduledTasks执行定时任务，多线程解析用户导入Excel文件。上报企业过多时通过nginx进行负载均衡，线上问题通过arthas排错，tomcat方式部署。</p>
<h3 id="系统："><a href="#系统：" class="headerlink" title="系统："></a>系统：</h3><ol>
<li>企业端</li>
</ol>
<p><img src="/images/%E8%BF%BD%E6%BA%AF%E7%94%B3%E6%8A%A5%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573714818614.png" alt="1573714818614"></p>
<ol start="2">
<li>监管端</li>
</ol>
<p><img src="/images/%E8%BF%BD%E6%BA%AF%E7%94%B3%E6%8A%A5%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/1573714959670.png" alt="1573714959670"></p>
<p>登录过程：</p>
<ol>
<li>填写用户名密码，前端通过DES加密，船只后端，后端通过自定义密钥解密，获取用户名密码后，交给shiro获取用户权限角色等信息；</li>
<li>在用户请求链接时，会首先进行shiro拦截并鉴权，获取当前session中是否有用户；</li>
<li>获取后通过shiro进行登录，在跳转至链接</li>
</ol>
<ul>
<li>cookie是保存在客户端，session保存在服务器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">String userId = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String userInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String loginUrl = <span class="keyword">this</span>.loginUrl;</span><br><span class="line"><span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cookies == <span class="keyword">null</span>)&#123;</span><br><span class="line">        response.sendRedirect(loginUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        <span class="keyword">if</span>(SysConstant.COOKIE_USER_ID.equals(cookie.getName())</span><br><span class="line">           &amp;&amp; StringUtils.isNotBlank(cookie.getValue()))&#123;</span><br><span class="line">            userId = cookie.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(SysConstant.COOKIE_USER_INFO.equals(cookie.getName())</span><br><span class="line">           &amp;&amp; StringUtils.isNotBlank(cookie.getValue()))&#123;</span><br><span class="line">            userInfo = cookie.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取缓存是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(userInfo)</span><br><span class="line">       || StringUtils.isBlank(userId))&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(SysConstant.CURRENT_USER)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.invalidate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response.sendRedirect(loginUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String userInfoStr = ShfdaConfusionUtil.deconfuse(userInfo);</span><br><span class="line">    String[] userInfos = userInfoStr.split(<span class="string">&quot;\\|\\|\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(userInfos !=<span class="keyword">null</span> </span><br><span class="line">       &amp;&amp; userInfos.length &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(userInfos[<span class="number">0</span>], userInfos[<span class="number">1</span>],<span class="keyword">false</span>);</span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();  </span><br><span class="line">        currentUser.login(token);</span><br><span class="line">        <span class="keyword">if</span>(currentUser.isAuthenticated())&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response.sendRedirect(loginUrl);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>器械追溯申报</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题（一）</title>
    <url>/2019/11/10/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li><p>在多线程环境中使用 HashMap 会有什么问题？在什么情况下使用 get () 方法会产生无限循环？ </p>
<span id="more"></span></li>
</ul>
<p> HashMap 本身没有什么问题，有没有问题取决于你是如何使用它的。比如，你在一个线程里初始化了一个 HashMap 然后在多个其他线程里对其进行读取，这肯定没有任何问题。有个例子就是使用 HashMap 来存储系统配置项。当有多于一个线程对 HashMap 进行修改操作的时候才会真正产生问题，比如增加、删除、更新键值对的时候。因为 put () 操作可以造成重新分配存储大小 (re-sizeing) 的动作，因此有可能造成无限循环的发生，所以这时需要使用 Hashtable 或者 ConcurrentHashMap，而后者更优。 </p>
<ul>
<li> 不重写 Bean 的 hashCode () 方法是否会对性能带来影响？ </li>
</ul>
<p> 这个问题非常好，每个人可能都会有自己的体会。按照我掌握的知识来说，如果一个计算 hash 的方法写得不好，直接的影响是，当向 HashMap 中添加元素的时候会更频繁地造成冲突，因此最终增加了耗时。但是自从 Java 8 开始，这种影响不再像前几个版本那样显著了，因为当冲突的发生超出了一定的限度之后，链表类的实现将会被替换成二叉树 (binary tree) 实现，这时你仍可以得到 O (logN) 的开销，优于链表类的 O (n)。 </p>
<ul>
<li> 对于一个不可修改的类，它的每个对象是不是都必须声明成 final 的？ </li>
</ul>
<p> 不尽然，因为你可以通过将成员声明成非 final 且 private，并且不要在除了构造函数的其他地方来修改它。不要为它们提供 setter 方法，同时不会通过任何函数泄露出对此成员的引用。需要记住的是，把对象声明成 final 仅仅保证了它不会被重新赋上另外一个值，你仍然可以通过此引用来修改引用对象的属性。这一点是关键，面试官通常喜欢听到你强调这一点。</p>
<ul>
<li> String 的 substring () 方法内部是如何实现的？ </li>
</ul>
<p> 又一个 Java 面试的好问题，你应该答出 “substring 方法通过原字符串创建了一个新的对象”，否则你的回答肯定是不能令人满意的。这个问题也经常被拿来测试应聘者对于 substring () 可能带来的内存泄漏风险是否有所了解。直到 Java 1.7 版本之前，substring 会保存一份原字符串的字符数组的引用，这意味着，如果你从 1GB 大小的字符串里截取了 5 个字符，而这 5 个字符也会阻止那 1GB 内存被回收，因为这个引用是强引用。 </p>
<ul>
<li> 你在写存储过程或者在 Java 里调用存储过程的时候如何来处理错误情况？ </li>
</ul>
<p> 这是个很棘手的 Java 面试题，答案也并不固定。我的答案是，写存储过程的时候一旦有操作失败，则一定要返回错误码。但是在调用存储过程的时候出错的话捕捉 SQLException 却是唯一能做的。 </p>
<ul>
<li> Executor.submit () 和 Executor.execute () 这两个方法有什么区别？ </li>
</ul>
<p> 此问题来自另外一篇文章，《15 个最流行的 java 多线程面试问题》，现在对熟练掌握并发技能的开发者的需求越来越大，因此这个问题也越来越引起大家的重视。答案是：前者返回一个 Future 对象，可以通过这个对象来获得工作线程执行的结果。</p>
<p>当我们考察异常处理的时候，又会发现另外一个不同。当你使用 execute 提交的任务抛出异常时，此异常将会交由未捕捉异常处理过程来处理 (uncaught exception handler)，当你没有显式指定一个异常处理器的话，默认情况下仅仅会通过 System.err 打印出错误堆栈。当你用 submit 来提交一个任务的时候，这个任务一旦抛出异常 (无论是否是运行时异常)，那这个异常是任务返回对象的一部分。对这样一种情形，当你调用 Future.get () 方法的时候，这个方法会重新抛出这个异常，并且会使用 ExecutionException 进行包装。 </p>
<ul>
<li> 工厂模式和抽象工厂模式有何不同？ </li>
</ul>
<p> 抽象工厂模式提供了多一级的抽象。不同的工厂类都继承了同一个抽象工厂方法，但是却根据工厂的类别创建不同的对象。例如，AutomobileFactory, UserFactory, RoleFactory 都继承了 AbstractFactory，但是每个工厂类创建自己对应类型的对象。下面是工厂模式和抽象工厂模式对应的 UML 图。 </p>
<ul>
<li> 什么是单例模式？创建单例对象的时候是将整个方法都标记为 synchronized 好还是仅仅把创建的的语句标记为 synchronized 好？ </li>
</ul>
<p> 在 Java 中，单例类是指那些在整个 Java 程序中只存在一份实例的类，例如 java.lang.Runtime 就是一个单例类。在 Java 4 版本及以前创建单例会有些麻烦，但是自从 Java 5 引入了 Enum 类型之后，事情就变得简单了。可以去看看我的关于如何使用 Enum 来创建单例类的文章，同时再看看问题五来看看如何在创建单例类的时候进行双重检查。 </p>
<ul>
<li> 能否写一段用 Java 4 或 5 来遍历一个 HashMap 的代码？ </li>
</ul>
<p> 事实上，用 Java 可以有四种方式来遍历任何一个 Map，一种是使用 keySet () 方法获取所有的键，然后遍历这些键，再依次通过 get () 方法来获取对应的值。第二种方法可以使用 entrySet () 来获取键值对的集合，然后使用 for each 语句来遍历这个集合，遍历的时候获得的每个键值对已经包含了键和值。这种算是一种更优的方式，因为每轮遍历的时候同时获得了 key 和 value，无需再调用 get () 方法，get () 方法在那种如果 bucket 位置有一个巨大的链表的时候的性能开销是 O (n)。第三种方法是获取 entrySet 之后用 iterator 依次获取每个键值对。第四种方法是获得 key set 之后用 iterator 依次获取每个 key，然后再根据 key 来调用 get 方法。 </p>
<ul>
<li> 你在什么时候会重写 hashCode () 和 equals () 方法？ </li>
</ul>
<p> 当你需要根据业务逻辑来进行相等性判断、而不是根据对象相等性来判断的时候你就需要重写这两个函数了。例如，两个 Employee 对象相等的依据是它们拥有相同的 emp_id，尽管它们有可能是两个不同的 Object 对象，并且分别在不同的地方被创建。同时，如果你准备把它们当作 HashMap 中的 key 来使用的话，你也必须重写这两个方法。现在，作为 Java 中 equals-hashcode 的一个约定，当你重写 equals 的时候必须也重写 hashcode，否则你会打破诸如 Set, Map 等集合赖以正常工作的约定。你可以看看我的另外一篇博文来理解这两个方法之间的微妙区别与联系。 </p>
<ul>
<li> 如果不重写 hashCode 方法会有什么问题？ </li>
</ul>
<p> 如果不重写 equals 方法的话，equals 和 hashCode 之间的约定就会被打破：当通过 equals 方法返回相等的两个对象，他们的 hashCode 也必须一样。如果不重写 hashCode 方法的话，即使是使用 equals 方法返回值为 true 的两个对象，当它们插入同一个 map 的时候，因为 hashCode 返回不同所以仍然会被插入到两个不同的位置。这样就打破了 HashMap 的本来目的，因为 Map 本身不允许存进去两个 key 相同的值。当使用 put 方法插入一个的时候，HashMap 会先计算对象的 hashcode，然后根据它来找到存储位置 (bucket)，然后遍历此存储位置上所有的 Map.Entry 对象来查看是否与待插入对象相同。如果没有提供 hashCode 的话，这些就都做不到了。 </p>
<ul>
<li> 我们要同步整个 getInstance () 方法，还是只同步 getInstance () 方法中的关键部分？ </li>
</ul>
<p> 仅仅同步关键部分 (Critical Section)。这是因为，如果我们同步整个方法的话，每次有线程调用 getInstance () 方法的时候都会等待其他线程调用完成才行，即使在此方法中并没有执行对象的创建操作。换句话说，我们只需要同步那些创建对象的代码，而创建对象的代码只会执行一次。一旦对象创建完成之后，根本没有必要再对方法进行同步保护了。事实上，从性能上来说，对方法进行同步保护这种编码方法非常要命，因为它会使性能降低 10 到 20 倍。下面是单例模式的 UML 图。</p>
<p>再补充一下，创建线程安全的单例对象有多种方法，你也可以顺便提一下。 </p>
<ul>
<li> HashMap，在调用 get () 方法的时候 equals () 和 hashCode () 方法都起了什么样的作用？ </li>
</ul>
<p> 这个问题算是对问题十二的补充，应聘者应该知道的是，一旦你提到了 hashCode () 方法，人们很可能要问 HashMap 是如何使用这个函数的。当你向 HashMap 插入一个 key 的时候，首先，这个对象的 hashCode () 方法会被调用，调用结果用来计算将要存储的位置 (bucket)。</p>
<p>因为某个位置上可能以链表的方式已经包含了多个 Map.Entry 对象，所以 HashMap 会使用 equals () 方法来将此对象与所有这些 Map.Entry 所包含的 key 进行对比，以确定此 key 对象是否已经存在。 </p>
<ul>
<li> 在 Java 中如何避免死锁？ </li>
</ul>
<p> 你可以通过打破互相等待的局面来避免死锁。为了达到这一点，你需要在代码中合理地安排获取和释放锁的顺序。如果获得锁的顺序是固定的，并且获得的顺序和释放的顺序刚好相反的话，就不会产生出现死锁的条件了。 </p>
<ul>
<li> 创建字符串对象的时候，使用字面值和使用 new String () 构造器这两种方式有什么不同？ </li>
</ul>
<p> 当我们使用 new String 构造器来创建字符串的时候，字符串的值会在堆中创建，而不会加入 JVM 的字符串池中。相反，使用字面值创建的 String 对象会被放入堆的 PermGen 段中。例如： </p>
<p> String str=new String(“Test”);</p>
<p>这句代码创建的对象 str 不会放入字符串池中，我们需要显式调用 String.intern () 方法来将它放入字符串池中。仅仅当你使用字面值创建字符串时，Java 才会自动将它放入字符串池中，比如：String s=”Test”。顺便提一下，这里有个容易被忽视的地方，当我们将参数 “Test” 传入构造器的时候，这个参数是个字面值，因此它也会在字符串池中保存另外一份。想了解更多关于字面值字符串和字符串对象之间的差别，请看这篇文章。 </p>
<ul>
<li> 什么是不可修改对象 (Immutable Object)? 你能否写一个例子？ </li>
</ul>
<p> 不可修改对象是那些一旦被创建就不能修改的对象。对这种对象的任何改动的后果都是会创建一个新的对象，而不是在原对象本身做修改。例如 Java 中的 String 类就是不可修改的。大多数这样的类通常都是 final 类型的，因为这样可以避免自己被继承继而被覆盖方法，在覆盖的方法里，不可修改的特性就难以得到保证了。你通常也可以通过将类的成员设置成 private 但是非 final 的来获得同样的效果。</p>
<p>另外，你同样要保证你的类不要通过任何方法暴露成员，特别是那些可修改类型的成员。同样地，当你的方法接收客户类传入的可修改对象的话，你应该使用一个复制的对象来防止客户代码来修改这个刚传入的可修改类。比如，传入 java.util.Date 对象的话，你应该自己使用 clone () 方法来获得一个副本。</p>
<p>当你通过类函数返回一个可修改对象的时候，你也要采取类似的防护措施，返回一个类成功的副本，防止客户代码通过此引用修改了成员对象的属性。千万不要直接把你的可修改成员直接返回给客户代码。 </p>
<ul>
<li> 如何在不使用任何分析工具的情况下用最简单的方式计算某个方法的执行所花费的时间？ </li>
</ul>
<p> 在执行此方法之前和之后获取一个系统时间，取这两个时间的差值，即可得到此方法所花费的时间。</p>
<p>需要注意的是，如果执行此方法花费的时间非常短，那么得到的时间值有可能是 0ms。这时你可以在一个计算量比较大的方法上试一下效果。</p>
<p>long start=System.currentTimeMillis();</p>
<p>method();</p>
<p>long end=System.currentTimeMillis();</p>
<p>System.out.println(“Time taken for execution is “+(end-start));</p>
<ul>
<li> 当你要把某个类作为 HashMap 的 key 使用的话，你需要重写这个类的哪两个方法？ </li>
</ul>
<p>为了使类可以在 HashMap 或 Hashtable 中作为 key 使用，必须要实现这个类自己的 equals () 和 hashCode () 方法。具体请参考问题十四。 </p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
